/**
 * 
 */
package uk.ac.manchester.dstoolkit.service.impl.query.querytranslator;

import static org.junit.Assert.assertArrayEquals;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.springframework.util.Assert.isInstanceOf;

import java.util.Collection;
import java.util.Map;
import java.util.Set;

import org.antlr.runtime.tree.CommonTree;
import org.apache.log4j.Logger;
import org.junit.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;

import uk.ac.manchester.dstoolkit.AbstractIntegrationTest;
import uk.ac.manchester.dstoolkit.domain.models.canonical.DataType;
import uk.ac.manchester.dstoolkit.domain.models.canonical.SuperLexical;
import uk.ac.manchester.dstoolkit.domain.models.meta.DataSource;
import uk.ac.manchester.dstoolkit.domain.models.meta.Schema;
import uk.ac.manchester.dstoolkit.domain.models.morphisms.mapping.operators.JoinOperator;
import uk.ac.manchester.dstoolkit.domain.models.morphisms.mapping.operators.MappingOperator;
import uk.ac.manchester.dstoolkit.domain.models.morphisms.mapping.operators.Predicate;
import uk.ac.manchester.dstoolkit.domain.models.morphisms.mapping.operators.ReduceOperator;
import uk.ac.manchester.dstoolkit.domain.models.morphisms.mapping.operators.ScanOperator;
import uk.ac.manchester.dstoolkit.domain.models.morphisms.mapping.operators.SetOperator;
import uk.ac.manchester.dstoolkit.domain.models.query.Query;
import uk.ac.manchester.dstoolkit.domain.models.query.queryresults.ResultField;
import uk.ac.manchester.dstoolkit.domain.models.query.queryresults.ResultType;
import uk.ac.manchester.dstoolkit.repository.meta.DataSourceRepository;
import uk.ac.manchester.dstoolkit.repository.meta.SchemaRepository;
import uk.ac.manchester.dstoolkit.service.query.queryparser.SQLQueryParserService;
import uk.ac.manchester.dstoolkit.service.query.querytranslator.GlobalQueryTranslatorService;

/**
 * @author chedeler
 *
 */
//@RunWith(SpringJUnit4ClassRunner.class)
public class GlobalQueryTranslatorIntegrationTest extends AbstractIntegrationTest {

	static Logger logger = Logger.getLogger(GlobalQueryTranslatorIntegrationTest.class);

	@Autowired
	@Qualifier("globalQueryTranslatorService")
	private GlobalQueryTranslatorService globalTranslator;

	@Autowired
	@Qualifier("sqlQueryParserService")
	private SQLQueryParserService parser;

	@Autowired
	@Qualifier("dataSourceRepository")
	private DataSourceRepository dataSourceRepository;

	@Autowired
	@Qualifier("schemaRepository")
	private SchemaRepository schemaRepository;

	//TODO add selection on borders

	//---------------------------------------------------------------------

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectStarQueryOneSource() {
		String selectStarFromQuery = "Select * from citye";
		String queryName = "AllCities";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS.getSchema().getName(): "
				+ mondialCityProvinceCountryContinentEuropeWithRenameDS.getSchema().getName());
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS.getConnectionURL(): "
				+ mondialCityProvinceCountryContinentEuropeWithRenameDS.getConnectionURL());

		Query query = new Query(queryName, selectStarFromQuery);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectStarQueryAst = parser.parseSQL(selectStarFromQuery);
		logger.debug("selectStarQueryAst: " + selectStarQueryAst.toStringTree());

		query = globalTranslator.translateAstIntoQuery(query, selectStarFromQuery, selectStarQueryAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(6, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals("citye.namee, citye.countrye, citye.provincee, citye.populatione, citye.longitudee, citye.latitudee",
				((ReduceOperator) rootOperator).getReconcilingExpression().getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[6];
		String[] superAbstractNamesArray = new String[6];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[6];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione",
				"citye.longitudee", "citye.latitudee" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType0 = rootOperator.getResultType();
		assertEquals(6, resultType0.getResultFields().size());
		String[] expectedResultFieldNamesArray0 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee" };
		DataType[] expectedResultFieldTypesArray0 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray0 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray0 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray0 = new String[6];
		DataType[] actualResultFieldTypesArray0 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray0 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray0 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields0 = resultType0.getResultFields();
		Set<String> resultFieldNames0 = resultFields0.keySet();
		for (String resultFieldName : resultFieldNames0) {
			actualResultFieldNamesArray0[i] = resultFieldName;
			actualResultFieldTypesArray0[i] = resultFields0.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultFields0.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields0.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultFields0.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}
		/*
		for (ResultField resultField : resultFields0) {
			actualResultFieldNamesArray0[i] = resultField.getFieldName();
			actualResultFieldTypesArray0[i] = resultField.getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultField.getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultField.getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultField.getCanonicalModelConstruct()).getSuperAbstract()
					.getName();
			i++;
		}
		*/

		assertArrayEquals(expectedResultFieldNamesArray0, actualResultFieldNamesArray0);
		assertArrayEquals(expectedResultFieldTypesArray0, actualResultFieldTypesArray0);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray0, actualCanonicalModelConstructNamesArray0);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray0, actualParentCanonicalModelConstructNamesArray0);

		MappingOperator input0Operator = rootOperator.getLhsInput();

		isInstanceOf(ScanOperator.class, input0Operator);
		assertEquals("citye", input0Operator.getVariableName());
		assertNull(input0Operator.getLhsInput());
		assertNull(input0Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input0Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input0Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input0Operator).getPredicates().size());

		assertNotNull(input0Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input0Operator.getDataSource());

		assertNotNull(input0Operator.getResultType());
		ResultType resultType = input0Operator.getResultType();
		assertEquals(6, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray = new String[6];
		DataType[] actualResultFieldTypesArray = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray = new String[6];

		i = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[i] = resultFieldName;
			actualResultFieldTypesArray[i] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}
		/*
		for (ResultField resultField : resultFields) {
			actualResultFieldNamesArray[i] = resultField.getFieldName();
			actualResultFieldTypesArray[i] = resultField.getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultField.getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultField.getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultField.getCanonicalModelConstruct()).getSuperAbstract().getName();
			i++;
		}
		*/

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectStarFromWhereQueryOneSource() {
		String selectStarFromWhereQuery = "Select * from citye where citye.countrye = 'GB'";
		String queryName = "AllCitiesInGB";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectStarFromWhereQuery);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectStarFromWhereQueryAst = parser.parseSQL(selectStarFromWhereQuery);
		logger.debug("selectStarFromWhereQueryAst: " + selectStarFromWhereQueryAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectStarFromWhereQuery, selectStarFromWhereQueryAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(6, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals("citye.namee, citye.countrye, citye.provincee, citye.populatione, citye.longitudee, citye.latitudee",
				((ReduceOperator) rootOperator).getReconcilingExpression().getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[6];
		String[] superAbstractNamesArray = new String[6];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[6];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione",
				"citye.longitudee", "citye.latitudee" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType0 = rootOperator.getResultType();
		assertEquals(6, resultType0.getResultFields().size());
		String[] expectedResultFieldNamesArray0 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee" };
		DataType[] expectedResultFieldTypesArray0 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray0 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray0 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray0 = new String[6];
		DataType[] actualResultFieldTypesArray0 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray0 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray0 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields0 = resultType0.getResultFields();
		Set<String> resultFieldNames0 = resultFields0.keySet();
		for (String resultFieldName : resultFieldNames0) {
			actualResultFieldNamesArray0[i] = resultFieldName;
			actualResultFieldTypesArray0[i] = resultFields0.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultFields0.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields0.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultFields0.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}
		/*
		for (ResultField resultField : resultFields0) {
			actualResultFieldNamesArray0[i] = resultField.getFieldName();
			actualResultFieldTypesArray0[i] = resultField.getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultField.getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultField.getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultField.getCanonicalModelConstruct()).getSuperAbstract()
					.getName();
			i++;
		}
		*/

		assertArrayEquals(expectedResultFieldNamesArray0, actualResultFieldNamesArray0);
		assertArrayEquals(expectedResultFieldTypesArray0, actualResultFieldTypesArray0);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray0, actualCanonicalModelConstructNamesArray0);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray0, actualParentCanonicalModelConstructNamesArray0);

		MappingOperator input0Operator = rootOperator.getLhsInput();

		isInstanceOf(ScanOperator.class, input0Operator);
		assertEquals("citye", input0Operator.getVariableName());
		assertNull(input0Operator.getLhsInput());
		assertNull(input0Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input0Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input0Operator).getReconcilingExpression());
		assertEquals("citye.countrye = 'GB'", ((ScanOperator) input0Operator).getReconcilingExpression().getExpression());

		assertNotNull(input0Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input0Operator.getDataSource());

		assertEquals(1, ((ScanOperator) input0Operator).getPredicates().size());
		Predicate predicate1 = ((ScanOperator) input0Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate1.getSuperLexical1().getName());
		assertEquals("citye", predicate1.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate1.getOperator());
		assertEquals("'GB'", predicate1.getLiteral2());
		assertNull(predicate1.getLiteral1());
		assertNull(predicate1.getSuperLexical2());

		assertNotNull(input0Operator.getResultType());
		ResultType resultType = input0Operator.getResultType();
		assertEquals(6, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray = new String[6];
		DataType[] actualResultFieldTypesArray = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray = new String[6];

		i = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[i] = resultFieldName;
			actualResultFieldTypesArray[i] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}
		/*
		for (ResultField resultField : resultFields) {
			actualResultFieldNamesArray[i] = resultField.getFieldName();
			actualResultFieldTypesArray[i] = resultField.getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultField.getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultField.getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultField.getCanonicalModelConstruct()).getSuperAbstract().getName();
			i++;
		}
		*/

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectStarFromWhereAndQueryOneSource() {
		String selectStarFromWhereAndQuery = "Select * from citye where citye.countrye = 'GB' and citye.namee = 'Manchester'";
		String queryName = "CityInGBWithNameManchester";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectStarFromWhereAndQuery);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectStarFromWhereAndQueryAst = parser.parseSQL(selectStarFromWhereAndQuery);
		logger.debug("selectStarFromWhereAndQueryAst: " + selectStarFromWhereAndQueryAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectStarFromWhereAndQuery, selectStarFromWhereAndQueryAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(6, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals("citye.namee, citye.countrye, citye.provincee, citye.populatione, citye.longitudee, citye.latitudee",
				((ReduceOperator) rootOperator).getReconcilingExpression().getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[6];
		String[] superAbstractNamesArray = new String[6];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[6];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione",
				"citye.longitudee", "citye.latitudee" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType0 = rootOperator.getResultType();
		assertEquals(6, resultType0.getResultFields().size());
		String[] expectedResultFieldNamesArray0 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee" };
		DataType[] expectedResultFieldTypesArray0 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray0 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray0 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray0 = new String[6];
		DataType[] actualResultFieldTypesArray0 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray0 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray0 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields0 = resultType0.getResultFields();
		Set<String> resultFieldNames0 = resultFields0.keySet();
		for (String resultFieldName : resultFieldNames0) {
			actualResultFieldNamesArray0[i] = resultFieldName;
			actualResultFieldTypesArray0[i] = resultFields0.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultFields0.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields0.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultFields0.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray0, actualResultFieldNamesArray0);
		assertArrayEquals(expectedResultFieldTypesArray0, actualResultFieldTypesArray0);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray0, actualCanonicalModelConstructNamesArray0);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray0, actualParentCanonicalModelConstructNamesArray0);

		MappingOperator input0Operator = rootOperator.getLhsInput();

		isInstanceOf(ScanOperator.class, input0Operator);
		assertEquals("citye", input0Operator.getVariableName());
		assertNull(input0Operator.getLhsInput());
		assertNull(input0Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input0Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input0Operator).getReconcilingExpression());
		assertEquals("citye.countrye = 'GB' and citye.namee = 'Manchester'", ((ScanOperator) input0Operator).getReconcilingExpression()
				.getExpression());

		assertNotNull(input0Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input0Operator.getDataSource());

		assertEquals(2, ((ScanOperator) input0Operator).getPredicates().size());

		Set<Predicate> predicates = ((ScanOperator) input0Operator).getPredicates();

		int k = 0;

		for (Predicate predicate : predicates) {
			if (k == 0) {
				//Predicate predicate1 = ((ScanOperator) input0Operator).getPredicates().get(0);
				assertEquals("countrye", predicate.getSuperLexical1().getName());
				assertEquals("citye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
				assertEquals("=", predicate.getOperator());
				assertEquals("'GB'", predicate.getLiteral2());
				assertNull(predicate.getLiteral1());
				assertNull(predicate.getSuperLexical2());
			} else if (k == 1) {
				//Predicate predicate2 = ((ScanOperator) input0Operator).getPredicates().get(1);
				assertEquals("namee", predicate.getSuperLexical1().getName());
				assertEquals("citye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
				assertEquals("=", predicate.getOperator());
				assertEquals("'Manchester'", predicate.getLiteral2());
				assertEquals("and", predicate.getAndOr());
				assertNull(predicate.getLiteral1());
				assertNull(predicate.getSuperLexical2());
			}
			k++;
		}

		assertNotNull(input0Operator.getResultType());
		ResultType resultType = input0Operator.getResultType();
		assertEquals(6, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray = new String[6];
		DataType[] actualResultFieldTypesArray = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray = new String[6];

		i = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[i] = resultFieldName;
			actualResultFieldTypesArray[i] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectStarFromWhereOrQueryOneSource() {
		String selectStarFromWhereOrQuery = "Select * from citye where citye.countrye = 'GB' or citye.countrye = 'D'";
		String queryName = "CityInGBOrD";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectStarFromWhereOrQuery);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectStarFromWhereOrQueryAst = parser.parseSQL(selectStarFromWhereOrQuery);
		logger.debug("selectStarFromWhereOrQueryAst: " + selectStarFromWhereOrQueryAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectStarFromWhereOrQuery, selectStarFromWhereOrQueryAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(6, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals("citye.namee, citye.countrye, citye.provincee, citye.populatione, citye.longitudee, citye.latitudee",
				((ReduceOperator) rootOperator).getReconcilingExpression().getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[6];
		String[] superAbstractNamesArray = new String[6];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[6];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione",
				"citye.longitudee", "citye.latitudee" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType0 = rootOperator.getResultType();
		assertEquals(6, resultType0.getResultFields().size());
		String[] expectedResultFieldNamesArray0 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee" };
		DataType[] expectedResultFieldTypesArray0 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray0 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray0 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray0 = new String[6];
		DataType[] actualResultFieldTypesArray0 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray0 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray0 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields0 = resultType0.getResultFields();
		Set<String> resultFieldNames0 = resultFields0.keySet();
		for (String resultFieldName : resultFieldNames0) {
			actualResultFieldNamesArray0[i] = resultFieldName;
			actualResultFieldTypesArray0[i] = resultFields0.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultFields0.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields0.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultFields0.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray0, actualResultFieldNamesArray0);
		assertArrayEquals(expectedResultFieldTypesArray0, actualResultFieldTypesArray0);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray0, actualCanonicalModelConstructNamesArray0);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray0, actualParentCanonicalModelConstructNamesArray0);

		MappingOperator input0Operator = rootOperator.getLhsInput();

		isInstanceOf(ScanOperator.class, input0Operator);
		assertEquals("citye", input0Operator.getVariableName());
		assertNull(input0Operator.getLhsInput());
		assertNull(input0Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input0Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input0Operator).getReconcilingExpression());
		assertEquals("citye.countrye = 'GB' or citye.countrye = 'D'", ((ScanOperator) input0Operator).getReconcilingExpression().getExpression());

		assertNotNull(input0Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input0Operator.getDataSource());

		assertEquals(2, ((ScanOperator) input0Operator).getPredicates().size());

		Set<Predicate> predicates = ((ScanOperator) input0Operator).getPredicates();

		int k = 0;

		for (Predicate predicate : predicates) {
			if (k == 0) {
				//Predicate predicate1 = ((ScanOperator) input0Operator).getPredicates().get(0);
				assertEquals("countrye", predicate.getSuperLexical1().getName());
				assertEquals("citye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
				assertEquals("=", predicate.getOperator());
				assertEquals("'GB'", predicate.getLiteral2());
				assertNull(predicate.getLiteral1());
				assertNull(predicate.getSuperLexical2());
			} else if (k == 1) {
				//Predicate predicate2 = ((ScanOperator) input0Operator).getPredicates().get(1);
				assertEquals("countrye", predicate.getSuperLexical1().getName());
				assertEquals("citye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
				assertEquals("=", predicate.getOperator());
				assertEquals("'D'", predicate.getLiteral2());
				assertEquals("or", predicate.getAndOr());
				assertNull(predicate.getLiteral1());
				assertNull(predicate.getSuperLexical2());
			}
			k++;
		}

		assertNotNull(input0Operator.getResultType());
		ResultType resultType = input0Operator.getResultType();
		assertEquals(6, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray = new String[6];
		DataType[] actualResultFieldTypesArray = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray = new String[6];

		i = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[i] = resultFieldName;
			actualResultFieldTypesArray[i] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);
	}

	//---------------------------------------------------------------------

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectSuperLexicalsFromQueryOneSource() {
		String selectSuperLexicalsFromQuery = "Select namee, countrye, provincee, populatione from citye";
		String queryName = "NameCountryProvinceOfCity";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectSuperLexicalsFromQuery);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectSuperLexicalsFromQueryAst = parser.parseSQL(selectSuperLexicalsFromQuery);
		logger.debug("selectSuperLexicalsFromQueryAst: " + selectSuperLexicalsFromQueryAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectSuperLexicalsFromQuery, selectSuperLexicalsFromQueryAst);

		MappingOperator rootOperator = query.getRootOperator();
		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(4, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals("citye.namee, citye.countrye, citye.provincee, citye.populatione", ((ReduceOperator) rootOperator).getReconcilingExpression()
				.getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[4];
		String[] superAbstractNamesArray = new String[4];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "populatione" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "citye" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[4];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType = rootOperator.getResultType();
		assertEquals(4, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray = new String[4];
		DataType[] actualResultFieldTypesArray = new DataType[4];
		String[] actualCanonicalModelConstructNamesArray = new String[4];
		String[] actualParentCanonicalModelConstructNamesArray = new String[4];

		i = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[i] = resultFieldName;
			actualResultFieldTypesArray[i] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input1Operator = rootOperator.getLhsInput();
		isInstanceOf(ScanOperator.class, input1Operator);
		assertEquals("citye", input1Operator.getVariableName());
		assertNull(input1Operator.getLhsInput());
		assertNull(input1Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input1Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input1Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input1Operator).getPredicates().size());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertNotNull(input1Operator.getResultType());
		ResultType resultType2 = input1Operator.getResultType();
		assertEquals(6, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] expectedParentCanonicalModelConstructNamesArray2 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray2 = new String[6];
		DataType[] actualResultFieldTypesArray2 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray2 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(expectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectSuperLexicalsFromWhereQueryOneSource() {
		String selectSuperLexicalsFromWhereQuery = "Select namee, countrye, provincee, populatione from citye where citye.countrye = 'GB'";
		String queryName = "NameCountryProvinceOfCityInGB";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectSuperLexicalsFromWhereQuery);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectSuperLexicalsFromWhereQueryAst = parser.parseSQL(selectSuperLexicalsFromWhereQuery);
		logger.debug("selectSuperLexicalsFromWhereQuery: " + selectSuperLexicalsFromWhereQueryAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectSuperLexicalsFromWhereQuery, selectSuperLexicalsFromWhereQueryAst);

		MappingOperator rootOperator = query.getRootOperator();
		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(4, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals("citye.namee, citye.countrye, citye.provincee, citye.populatione", ((ReduceOperator) rootOperator).getReconcilingExpression()
				.getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[4];
		String[] superAbstractNamesArray = new String[4];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "populatione" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "citye" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[4];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType = rootOperator.getResultType();
		assertEquals(4, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray = new String[4];
		DataType[] actualResultFieldTypesArray = new DataType[4];
		String[] actualCanonicalModelConstructNamesArray = new String[4];
		String[] actualParentCanonicalModelConstructNamesArray = new String[4];

		i = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[i] = resultFieldName;
			actualResultFieldTypesArray[i] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input1Operator = rootOperator.getLhsInput();
		isInstanceOf(ScanOperator.class, input1Operator);
		assertEquals("citye", input1Operator.getVariableName());
		assertNull(input1Operator.getLhsInput());
		assertNull(input1Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input1Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input1Operator).getReconcilingExpression());
		assertEquals("citye.countrye = 'GB'", ((ScanOperator) input1Operator).getReconcilingExpression().getExpression());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertEquals(1, ((ScanOperator) input1Operator).getPredicates().size());
		Predicate predicate1 = ((ScanOperator) input1Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate1.getSuperLexical1().getName());
		assertEquals("citye", predicate1.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate1.getOperator());
		assertEquals("'GB'", predicate1.getLiteral2());
		assertNull(predicate1.getLiteral1());
		assertNull(predicate1.getSuperLexical2());

		assertNotNull(input1Operator.getResultType());
		ResultType resultType2 = input1Operator.getResultType();
		assertEquals(6, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] expectedParentCanonicalModelConstructNamesArray2 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray2 = new String[6];
		DataType[] actualResultFieldTypesArray2 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray2 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(expectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectSuperLexicalsFromWhereAndQueryOneSource() {
		String selectSuperLexicalsFromWhereAndQuery = "Select namee, countrye, provincee, populatione from citye where citye.countrye = 'GB' and citye.namee = 'Manchester'";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectSuperLexicalsFromWhereAndQuery);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectSuperLexicalsFromWhereAndQueryAst = parser.parseSQL(selectSuperLexicalsFromWhereAndQuery);
		logger.debug("selectSuperLexicalsFromWhereAndQuery: " + selectSuperLexicalsFromWhereAndQueryAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectSuperLexicalsFromWhereAndQuery, selectSuperLexicalsFromWhereAndQueryAst);

		MappingOperator rootOperator = query.getRootOperator();
		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(4, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals("citye.namee, citye.countrye, citye.provincee, citye.populatione", ((ReduceOperator) rootOperator).getReconcilingExpression()
				.getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[4];
		String[] superAbstractNamesArray = new String[4];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "populatione" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "citye" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[4];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType = rootOperator.getResultType();
		assertEquals(4, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray = new String[4];
		DataType[] actualResultFieldTypesArray = new DataType[4];
		String[] actualCanonicalModelConstructNamesArray = new String[4];
		String[] actualParentCanonicalModelConstructNamesArray = new String[4];

		i = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[i] = resultFieldName;
			actualResultFieldTypesArray[i] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input1Operator = rootOperator.getLhsInput();
		isInstanceOf(ScanOperator.class, input1Operator);
		assertEquals("citye", input1Operator.getVariableName());
		assertNull(input1Operator.getLhsInput());
		assertNull(input1Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input1Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input1Operator).getReconcilingExpression());
		assertEquals("citye.countrye = 'GB' and citye.namee = 'Manchester'", ((ScanOperator) input1Operator).getReconcilingExpression()
				.getExpression());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		Set<Predicate> predicates = ((ScanOperator) input1Operator).getPredicates();

		assertEquals(2, ((ScanOperator) input1Operator).getPredicates().size());

		int k = 0;

		for (Predicate predicate : predicates) {
			if (k == 0) {
				//Predicate predicate1 = ((ScanOperator) input1Operator).getPredicates().get(0);
				assertEquals("countrye", predicate.getSuperLexical1().getName());
				assertEquals("citye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
				assertEquals("=", predicate.getOperator());
				assertEquals("'GB'", predicate.getLiteral2());
				assertNull(predicate.getLiteral1());
				assertNull(predicate.getSuperLexical2());
			} else if (k == 1) {
				//Predicate predicate2 = ((ScanOperator) input1Operator).getPredicates().get(1);
				assertEquals("namee", predicate.getSuperLexical1().getName());
				assertEquals("citye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
				assertEquals("=", predicate.getOperator());
				assertEquals("'Manchester'", predicate.getLiteral2());
				assertEquals("and", predicate.getAndOr());
				assertNull(predicate.getLiteral1());
				assertNull(predicate.getSuperLexical2());
			}
			k++;
		}

		assertNotNull(input1Operator.getResultType());
		ResultType resultType2 = input1Operator.getResultType();
		assertEquals(6, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] expectedParentCanonicalModelConstructNamesArray2 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray2 = new String[6];
		DataType[] actualResultFieldTypesArray2 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray2 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(expectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectSuperLexicalsFromWhereOrQueryOneSource() {
		String selectSuperLexicalsFromWhereOrQuery = "Select namee, countrye, provincee, populatione from citye where citye.countrye = 'GB' or citye.countrye = 'D'";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectSuperLexicalsFromWhereOrQuery);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectSuperLexicalsFromWhereOrQueryAst = parser.parseSQL(selectSuperLexicalsFromWhereOrQuery);
		logger.debug("selectSuperLexicalsFromWhereOrQuery: " + selectSuperLexicalsFromWhereOrQueryAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectSuperLexicalsFromWhereOrQuery, selectSuperLexicalsFromWhereOrQueryAst);

		MappingOperator rootOperator = query.getRootOperator();
		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(4, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals("citye.namee, citye.countrye, citye.provincee, citye.populatione", ((ReduceOperator) rootOperator).getReconcilingExpression()
				.getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[4];
		String[] superAbstractNamesArray = new String[4];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "populatione" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "citye" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[4];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType = rootOperator.getResultType();
		assertEquals(4, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray = new String[4];
		DataType[] actualResultFieldTypesArray = new DataType[4];
		String[] actualCanonicalModelConstructNamesArray = new String[4];
		String[] actualParentCanonicalModelConstructNamesArray = new String[4];

		i = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[i] = resultFieldName;
			actualResultFieldTypesArray[i] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input1Operator = rootOperator.getLhsInput();
		isInstanceOf(ScanOperator.class, input1Operator);
		assertEquals("citye", input1Operator.getVariableName());
		assertNull(input1Operator.getLhsInput());
		assertNull(input1Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input1Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input1Operator).getReconcilingExpression());
		assertEquals("citye.countrye = 'GB' or citye.countrye = 'D'", ((ScanOperator) input1Operator).getReconcilingExpression().getExpression());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertEquals(2, ((ScanOperator) input1Operator).getPredicates().size());

		Set<Predicate> predicates = ((ScanOperator) input1Operator).getPredicates();

		int k = 0;

		for (Predicate predicate : predicates) {
			if (k == 0) {
				//Predicate predicate1 = ((ScanOperator) input1Operator).getPredicates().get(0);
				assertEquals("countrye", predicate.getSuperLexical1().getName());
				assertEquals("citye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
				assertEquals("=", predicate.getOperator());
				assertEquals("'GB'", predicate.getLiteral2());
				assertNull(predicate.getLiteral1());
				assertNull(predicate.getSuperLexical2());
			} else if (k == 1) {
				//Predicate predicate2 = ((ScanOperator) input1Operator).getPredicates().get(1);
				assertEquals("countrye", predicate.getSuperLexical1().getName());
				assertEquals("citye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
				assertEquals("=", predicate.getOperator());
				assertEquals("'D'", predicate.getLiteral2());
				assertEquals("or", predicate.getAndOr());
				assertNull(predicate.getLiteral1());
				assertNull(predicate.getSuperLexical2());
			}
			k++;
		}

		assertNotNull(input1Operator.getResultType());
		ResultType resultType2 = input1Operator.getResultType();
		assertEquals(6, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] expectedParentCanonicalModelConstructNamesArray2 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray2 = new String[6];
		DataType[] actualResultFieldTypesArray2 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray2 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(expectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);
	}

	//---------------------------------------------------------------------

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectStarFromQueryWithVariableNameOneSource() {
		String selectStarFromQueryWithVariableName = "Select * from citye c";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectStarFromQueryWithVariableName);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectStarFromQueryWithVariableNameAst = parser.parseSQL(selectStarFromQueryWithVariableName);
		logger.debug("selectStarFromQueryWithVariableNameAst: " + selectStarFromQueryWithVariableNameAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectStarFromQueryWithVariableName, selectStarFromQueryWithVariableNameAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(6, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals("c.namee, c.countrye, c.provincee, c.populatione, c.longitudee, c.latitudee", ((ReduceOperator) rootOperator)
				.getReconcilingExpression().getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[6];
		String[] superAbstractNamesArray = new String[6];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[6];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType0 = rootOperator.getResultType();
		assertEquals(6, resultType0.getResultFields().size());
		String[] expectedResultFieldNamesArray0 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee" };
		DataType[] expectedResultFieldTypesArray0 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray0 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray0 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray0 = new String[6];
		DataType[] actualResultFieldTypesArray0 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray0 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray0 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields0 = resultType0.getResultFields();
		Set<String> resultFieldNames0 = resultFields0.keySet();
		for (String resultFieldName : resultFieldNames0) {
			actualResultFieldNamesArray0[i] = resultFieldName;
			actualResultFieldTypesArray0[i] = resultFields0.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultFields0.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields0.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultFields0.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray0, actualResultFieldNamesArray0);
		assertArrayEquals(expectedResultFieldTypesArray0, actualResultFieldTypesArray0);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray0, actualCanonicalModelConstructNamesArray0);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray0, actualParentCanonicalModelConstructNamesArray0);

		MappingOperator input0Operator = rootOperator.getLhsInput();

		isInstanceOf(ScanOperator.class, input0Operator);
		assertEquals("c", input0Operator.getVariableName());
		assertNull(input0Operator.getLhsInput());
		assertNull(input0Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input0Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input0Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input0Operator).getPredicates().size());

		assertNotNull(input0Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input0Operator.getDataSource());

		assertNotNull(input0Operator.getResultType());
		ResultType resultType = input0Operator.getResultType();
		assertEquals(6, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray = new String[6];
		DataType[] actualResultFieldTypesArray = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray = new String[6];

		i = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[i] = resultFieldName;
			actualResultFieldTypesArray[i] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectStarFromWhereQueryWithVariableNameOneSource() {
		String selectStarFromWhereQueryWithVariableName = "Select * from citye c where c.countrye = 'GB'";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectStarFromWhereQueryWithVariableName);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectStarFromWhereQueryWithVariableNameAst = parser.parseSQL(selectStarFromWhereQueryWithVariableName);
		logger.debug("selectStarFromWhereQueryWithVariableNameAst: " + selectStarFromWhereQueryWithVariableNameAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectStarFromWhereQueryWithVariableName, selectStarFromWhereQueryWithVariableNameAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(6, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals("c.namee, c.countrye, c.provincee, c.populatione, c.longitudee, c.latitudee", ((ReduceOperator) rootOperator)
				.getReconcilingExpression().getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[6];
		String[] superAbstractNamesArray = new String[6];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[6];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType0 = rootOperator.getResultType();
		assertEquals(6, resultType0.getResultFields().size());
		String[] expectedResultFieldNamesArray0 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee" };
		DataType[] expectedResultFieldTypesArray0 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray0 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray0 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray0 = new String[6];
		DataType[] actualResultFieldTypesArray0 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray0 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray0 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields0 = resultType0.getResultFields();
		Set<String> resultFieldNames0 = resultFields0.keySet();
		for (String resultFieldName : resultFieldNames0) {
			actualResultFieldNamesArray0[i] = resultFieldName;
			actualResultFieldTypesArray0[i] = resultFields0.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultFields0.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields0.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultFields0.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray0, actualResultFieldNamesArray0);
		assertArrayEquals(expectedResultFieldTypesArray0, actualResultFieldTypesArray0);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray0, actualCanonicalModelConstructNamesArray0);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray0, actualParentCanonicalModelConstructNamesArray0);

		MappingOperator input0Operator = rootOperator.getLhsInput();

		isInstanceOf(ScanOperator.class, input0Operator);
		assertEquals("c", input0Operator.getVariableName());
		assertNull(input0Operator.getLhsInput());
		assertNull(input0Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input0Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input0Operator).getReconcilingExpression());
		assertEquals("c.countrye = 'GB'", ((ScanOperator) input0Operator).getReconcilingExpression().getExpression());

		assertNotNull(input0Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input0Operator.getDataSource());

		assertEquals(1, ((ScanOperator) input0Operator).getPredicates().size());
		Predicate predicate1 = ((ScanOperator) input0Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate1.getSuperLexical1().getName());
		assertEquals("citye", predicate1.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate1.getOperator());
		assertEquals("'GB'", predicate1.getLiteral2());
		assertNull(predicate1.getLiteral1());
		assertNull(predicate1.getSuperLexical2());

		assertNotNull(input0Operator.getResultType());
		ResultType resultType = input0Operator.getResultType();
		assertEquals(6, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray = new String[6];
		DataType[] actualResultFieldTypesArray = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray = new String[6];

		i = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[i] = resultFieldName;
			actualResultFieldTypesArray[i] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectStarFromWhereAndQueryWithVariableNameOneSource() {
		String selectStarFromWhereAndQueryWithVariableName = "Select * from citye c where c.countrye = 'GB' and c.namee = 'Manchester'";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectStarFromWhereAndQueryWithVariableName);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectStarFromWhereAndQueryWithVariableNameAst = parser.parseSQL(selectStarFromWhereAndQueryWithVariableName);
		logger.debug("selectStarFromWhereAndQueryWithVariableNameAst: " + selectStarFromWhereAndQueryWithVariableNameAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectStarFromWhereAndQueryWithVariableName,
				selectStarFromWhereAndQueryWithVariableNameAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(6, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals("c.namee, c.countrye, c.provincee, c.populatione, c.longitudee, c.latitudee", ((ReduceOperator) rootOperator)
				.getReconcilingExpression().getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[6];
		String[] superAbstractNamesArray = new String[6];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[6];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType0 = rootOperator.getResultType();
		assertEquals(6, resultType0.getResultFields().size());
		String[] expectedResultFieldNamesArray0 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee" };
		DataType[] expectedResultFieldTypesArray0 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray0 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray0 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray0 = new String[6];
		DataType[] actualResultFieldTypesArray0 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray0 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray0 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields0 = resultType0.getResultFields();
		Set<String> resultFieldNames0 = resultFields0.keySet();
		for (String resultFieldName : resultFieldNames0) {
			actualResultFieldNamesArray0[i] = resultFieldName;
			actualResultFieldTypesArray0[i] = resultFields0.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultFields0.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields0.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultFields0.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray0, actualResultFieldNamesArray0);
		assertArrayEquals(expectedResultFieldTypesArray0, actualResultFieldTypesArray0);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray0, actualCanonicalModelConstructNamesArray0);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray0, actualParentCanonicalModelConstructNamesArray0);

		MappingOperator input0Operator = rootOperator.getLhsInput();

		isInstanceOf(ScanOperator.class, input0Operator);
		assertEquals("c", input0Operator.getVariableName());
		assertNull(input0Operator.getLhsInput());
		assertNull(input0Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input0Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input0Operator).getReconcilingExpression());
		assertEquals("c.countrye = 'GB' and c.namee = 'Manchester'", ((ScanOperator) input0Operator).getReconcilingExpression().getExpression());

		assertNotNull(input0Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input0Operator.getDataSource());

		assertEquals(2, ((ScanOperator) input0Operator).getPredicates().size());

		Set<Predicate> predicates = ((ScanOperator) input0Operator).getPredicates();

		int k = 0;

		for (Predicate predicate : predicates) {
			if (k == 0) {
				//Predicate predicate1 = ((ScanOperator) input0Operator).getPredicates().get(0);
				assertEquals("countrye", predicate.getSuperLexical1().getName());
				assertEquals("citye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
				assertEquals("=", predicate.getOperator());
				assertEquals("'GB'", predicate.getLiteral2());
				assertNull(predicate.getLiteral1());
				assertNull(predicate.getSuperLexical2());
			} else if (k == 1) {
				//Predicate predicate2 = ((ScanOperator) input0Operator).getPredicates().get(1);
				assertEquals("namee", predicate.getSuperLexical1().getName());
				assertEquals("citye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
				assertEquals("=", predicate.getOperator());
				assertEquals("'Manchester'", predicate.getLiteral2());
				assertEquals("and", predicate.getAndOr());
				assertNull(predicate.getLiteral1());
				assertNull(predicate.getSuperLexical2());
			}
			k++;
		}

		assertNotNull(input0Operator.getResultType());
		ResultType resultType = input0Operator.getResultType();
		assertEquals(6, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray = new String[6];
		DataType[] actualResultFieldTypesArray = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray = new String[6];

		i = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[i] = resultFieldName;
			actualResultFieldTypesArray[i] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectStarFromWhereOrQueryWithVariableNameOneSource() {
		String selectStarFromWhereOrQueryWithVariableName = "Select * from citye c where c.countrye = 'GB' or c.countrye = 'D'";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectStarFromWhereOrQueryWithVariableName);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectStarFromWhereOrQueryWithVariableNameAst = parser.parseSQL(selectStarFromWhereOrQueryWithVariableName);
		logger.debug("selectStarFromWhereOrQueryWithVariableNameAst: " + selectStarFromWhereOrQueryWithVariableNameAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectStarFromWhereOrQueryWithVariableName,
				selectStarFromWhereOrQueryWithVariableNameAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(6, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals("c.namee, c.countrye, c.provincee, c.populatione, c.longitudee, c.latitudee", ((ReduceOperator) rootOperator)
				.getReconcilingExpression().getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[6];
		String[] superAbstractNamesArray = new String[6];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[6];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType0 = rootOperator.getResultType();
		assertEquals(6, resultType0.getResultFields().size());
		String[] expectedResultFieldNamesArray0 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee" };
		DataType[] expectedResultFieldTypesArray0 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray0 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray0 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray0 = new String[6];
		DataType[] actualResultFieldTypesArray0 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray0 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray0 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields0 = resultType0.getResultFields();
		Set<String> resultFieldNames0 = resultFields0.keySet();
		for (String resultFieldName : resultFieldNames0) {
			actualResultFieldNamesArray0[i] = resultFieldName;
			actualResultFieldTypesArray0[i] = resultFields0.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultFields0.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields0.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultFields0.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray0, actualResultFieldNamesArray0);
		assertArrayEquals(expectedResultFieldTypesArray0, actualResultFieldTypesArray0);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray0, actualCanonicalModelConstructNamesArray0);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray0, actualParentCanonicalModelConstructNamesArray0);

		MappingOperator input0Operator = rootOperator.getLhsInput();

		isInstanceOf(ScanOperator.class, input0Operator);
		assertEquals("c", input0Operator.getVariableName());
		assertNull(input0Operator.getLhsInput());
		assertNull(input0Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input0Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input0Operator).getReconcilingExpression());
		assertEquals("c.countrye = 'GB' or c.countrye = 'D'", ((ScanOperator) input0Operator).getReconcilingExpression().getExpression());

		assertNotNull(input0Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input0Operator.getDataSource());

		assertEquals(2, ((ScanOperator) input0Operator).getPredicates().size());

		Set<Predicate> predicates = ((ScanOperator) input0Operator).getPredicates();

		int k = 0;

		for (Predicate predicate : predicates) {
			if (k == 0) {
				//Predicate predicate1 = ((ScanOperator) input0Operator).getPredicates().get(0);
				assertEquals("countrye", predicate.getSuperLexical1().getName());
				assertEquals("citye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
				assertEquals("=", predicate.getOperator());
				assertEquals("'GB'", predicate.getLiteral2());
				assertNull(predicate.getLiteral1());
				assertNull(predicate.getSuperLexical2());
			} else if (k == 1) {
				//Predicate predicate2 = ((ScanOperator) input0Operator).getPredicates().get(1);
				assertEquals("countrye", predicate.getSuperLexical1().getName());
				assertEquals("citye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
				assertEquals("=", predicate.getOperator());
				assertEquals("'D'", predicate.getLiteral2());
				assertEquals("or", predicate.getAndOr());
				assertNull(predicate.getLiteral1());
				assertNull(predicate.getSuperLexical2());
			}
			k++;
		}

		assertNotNull(input0Operator.getResultType());
		ResultType resultType = input0Operator.getResultType();
		assertEquals(6, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray = new String[6];
		DataType[] actualResultFieldTypesArray = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray = new String[6];

		i = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[i] = resultFieldName;
			actualResultFieldTypesArray[i] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);
	}

	//---------------------------------------------------------------------

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectSuperLexicalsFromQueryWithVariableNameOneSource() {
		String selectSuperLexicalsFromQueryWithVariableName = "Select c.namee, c.countrye, c.provincee, c.populatione from citye c";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectSuperLexicalsFromQueryWithVariableName);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectSuperLexicalsFromQueryWithVariableNameAst = parser.parseSQL(selectSuperLexicalsFromQueryWithVariableName);
		logger.debug("selectSuperLexicalsFromQueryWithVariableNameAst: " + selectSuperLexicalsFromQueryWithVariableNameAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectSuperLexicalsFromQueryWithVariableName,
				selectSuperLexicalsFromQueryWithVariableNameAst);

		MappingOperator rootOperator = query.getRootOperator();
		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(4, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals("c.namee, c.countrye, c.provincee, c.populatione", ((ReduceOperator) rootOperator).getReconcilingExpression().getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[4];
		String[] superAbstractNamesArray = new String[4];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "populatione" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "citye" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[4];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "c.namee", "c.countrye", "c.provincee", "c.populatione" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType = rootOperator.getResultType();
		assertEquals(4, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "c.namee", "c.countrye", "c.provincee", "c.populatione" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray = new String[4];
		DataType[] actualResultFieldTypesArray = new DataType[4];
		String[] actualCanonicalModelConstructNamesArray = new String[4];
		String[] actualParentCanonicalModelConstructNamesArray = new String[4];

		i = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[i] = resultFieldName;
			actualResultFieldTypesArray[i] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input1Operator = rootOperator.getLhsInput();
		isInstanceOf(ScanOperator.class, input1Operator);
		assertEquals("c", input1Operator.getVariableName());
		assertNull(input1Operator.getLhsInput());
		assertNull(input1Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input1Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input1Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input1Operator).getPredicates().size());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertNotNull(input1Operator.getResultType());
		ResultType resultType2 = input1Operator.getResultType();
		assertEquals(6, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray2 = new String[6];
		DataType[] actualResultFieldTypesArray2 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray2 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectSuperLexicalsFromWhereQueryWithVariableNameOneSource() {
		String selectSuperLexicalsFromWhereQueryWithVariableName = "Select c.namee, c.countrye, c.provincee, c.populatione from citye c where c.countrye = 'GB'";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectSuperLexicalsFromWhereQueryWithVariableName);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectSuperLexicalsFromWhereQueryWithVariableNameAst = parser.parseSQL(selectSuperLexicalsFromWhereQueryWithVariableName);
		logger.debug("selectSuperLexicalsFromWhereQueryWithVariableNameAst: " + selectSuperLexicalsFromWhereQueryWithVariableNameAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectSuperLexicalsFromWhereQueryWithVariableName,
				selectSuperLexicalsFromWhereQueryWithVariableNameAst);

		MappingOperator rootOperator = query.getRootOperator();
		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(4, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals("c.namee, c.countrye, c.provincee, c.populatione", ((ReduceOperator) rootOperator).getReconcilingExpression().getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[4];
		String[] superAbstractNamesArray = new String[4];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "populatione" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "citye" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[4];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "c.namee", "c.countrye", "c.provincee", "c.populatione" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType = rootOperator.getResultType();
		assertEquals(4, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "c.namee", "c.countrye", "c.provincee", "c.populatione" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray = new String[4];
		DataType[] actualResultFieldTypesArray = new DataType[4];
		String[] actualCanonicalModelConstructNamesArray = new String[4];
		String[] actualParentCanonicalModelConstructNamesArray = new String[4];

		i = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[i] = resultFieldName;
			actualResultFieldTypesArray[i] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input1Operator = rootOperator.getLhsInput();
		isInstanceOf(ScanOperator.class, input1Operator);
		assertEquals("c", input1Operator.getVariableName());
		assertNull(input1Operator.getLhsInput());
		assertNull(input1Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input1Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input1Operator).getReconcilingExpression());
		assertEquals("c.countrye = 'GB'", ((ScanOperator) input1Operator).getReconcilingExpression().getExpression());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertEquals(1, ((ScanOperator) input1Operator).getPredicates().size());
		Predicate predicate1 = ((ScanOperator) input1Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate1.getSuperLexical1().getName());
		assertEquals("citye", predicate1.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate1.getOperator());
		assertEquals("'GB'", predicate1.getLiteral2());
		assertNull(predicate1.getLiteral1());
		assertNull(predicate1.getSuperLexical2());

		assertNotNull(input1Operator.getResultType());
		ResultType resultType2 = input1Operator.getResultType();
		assertEquals(6, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray2 = new String[6];
		DataType[] actualResultFieldTypesArray2 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray2 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectSuperLexicalsFromWhereAndQueryWithVariableNameOneSource() {
		String selectSuperLexicalsFromWhereAndQueryWithVariableName = "Select c.namee, c.countrye, c.provincee, c.populatione from citye c where c.countrye = 'GB' and c.namee = 'Manchester'";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectSuperLexicalsFromWhereAndQueryWithVariableName);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectSuperLexicalsFromWhereAndQueryWithVariableNameAst = parser.parseSQL(selectSuperLexicalsFromWhereAndQueryWithVariableName);
		logger.debug("selectSuperLexicalsFromWhereAndQueryWithVariableNameAst: "
				+ selectSuperLexicalsFromWhereAndQueryWithVariableNameAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectSuperLexicalsFromWhereAndQueryWithVariableName,
				selectSuperLexicalsFromWhereAndQueryWithVariableNameAst);

		MappingOperator rootOperator = query.getRootOperator();
		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(4, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals("c.namee, c.countrye, c.provincee, c.populatione", ((ReduceOperator) rootOperator).getReconcilingExpression().getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[4];
		String[] superAbstractNamesArray = new String[4];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "populatione" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "citye" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[4];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "c.namee", "c.countrye", "c.provincee", "c.populatione" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType = rootOperator.getResultType();
		assertEquals(4, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "c.namee", "c.countrye", "c.provincee", "c.populatione" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray = new String[4];
		DataType[] actualResultFieldTypesArray = new DataType[4];
		String[] actualCanonicalModelConstructNamesArray = new String[4];
		String[] actualParentCanonicalModelConstructNamesArray = new String[4];

		i = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[i] = resultFieldName;
			actualResultFieldTypesArray[i] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input1Operator = rootOperator.getLhsInput();
		isInstanceOf(ScanOperator.class, input1Operator);
		assertEquals("c", input1Operator.getVariableName());
		assertNull(input1Operator.getLhsInput());
		assertNull(input1Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input1Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input1Operator).getReconcilingExpression());
		assertEquals("c.countrye = 'GB' and c.namee = 'Manchester'", ((ScanOperator) input1Operator).getReconcilingExpression().getExpression());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertEquals(2, ((ScanOperator) input1Operator).getPredicates().size());

		Set<Predicate> predicates = ((ScanOperator) input1Operator).getPredicates();

		int k = 0;

		for (Predicate predicate : predicates) {
			if (k == 0) {
				//Predicate predicate1 = ((ScanOperator) input1Operator).getPredicates().get(0);
				assertEquals("countrye", predicate.getSuperLexical1().getName());
				assertEquals("citye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
				assertEquals("=", predicate.getOperator());
				assertEquals("'GB'", predicate.getLiteral2());
				assertNull(predicate.getLiteral1());
				assertNull(predicate.getSuperLexical2());
			} else if (k == 1) {
				//Predicate predicate2 = ((ScanOperator) input1Operator).getPredicates().get(1);
				assertEquals("namee", predicate.getSuperLexical1().getName());
				assertEquals("citye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
				assertEquals("=", predicate.getOperator());
				assertEquals("'Manchester'", predicate.getLiteral2());
				assertEquals("and", predicate.getAndOr());
				assertNull(predicate.getLiteral1());
				assertNull(predicate.getSuperLexical2());
			}
			k++;
		}

		assertNotNull(input1Operator.getResultType());
		ResultType resultType2 = input1Operator.getResultType();
		assertEquals(6, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray2 = new String[6];
		DataType[] actualResultFieldTypesArray2 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray2 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectSuperLexicalsFromWhereOrQueryWithVariableNameOneSource() {
		String selectSuperLexicalsFromWhereOrQueryWithVariableName = "Select c.namee, c.countrye, c.provincee, c.populatione from citye c where c.countrye = 'GB' or c.countrye = 'D'";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectSuperLexicalsFromWhereOrQueryWithVariableName);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectSuperLexicalsFromWhereOrQueryWithVariableNameAst = parser.parseSQL(selectSuperLexicalsFromWhereOrQueryWithVariableName);
		logger.debug("selectSuperLexicalsFromWhereOrQueryWithVariableNameAst: "
				+ selectSuperLexicalsFromWhereOrQueryWithVariableNameAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectSuperLexicalsFromWhereOrQueryWithVariableName,
				selectSuperLexicalsFromWhereOrQueryWithVariableNameAst);

		MappingOperator rootOperator = query.getRootOperator();
		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(4, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals("c.namee, c.countrye, c.provincee, c.populatione", ((ReduceOperator) rootOperator).getReconcilingExpression().getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[4];
		String[] superAbstractNamesArray = new String[4];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "populatione" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "citye" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[4];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "c.namee", "c.countrye", "c.provincee", "c.populatione" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType = rootOperator.getResultType();
		assertEquals(4, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "c.namee", "c.countrye", "c.provincee", "c.populatione" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "populatione" };
		String[] expectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray = new String[4];
		DataType[] actualResultFieldTypesArray = new DataType[4];
		String[] actualCanonicalModelConstructNamesArray = new String[4];
		String[] actualParentCanonicalModelConstructNamesArray = new String[4];

		i = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[i] = resultFieldName;
			actualResultFieldTypesArray[i] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(expectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input1Operator = rootOperator.getLhsInput();
		isInstanceOf(ScanOperator.class, input1Operator);
		assertEquals("c", input1Operator.getVariableName());
		assertNull(input1Operator.getLhsInput());
		assertNull(input1Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input1Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input1Operator).getReconcilingExpression());
		assertEquals("c.countrye = 'GB' or c.countrye = 'D'", ((ScanOperator) input1Operator).getReconcilingExpression().getExpression());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertEquals(2, ((ScanOperator) input1Operator).getPredicates().size());

		Set<Predicate> predicates = ((ScanOperator) input1Operator).getPredicates();

		int k = 0;

		for (Predicate predicate : predicates) {
			if (k == 0) {
				//Predicate predicate1 = ((ScanOperator) input1Operator).getPredicates().get(0);
				assertEquals("countrye", predicate.getSuperLexical1().getName());
				assertEquals("citye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
				assertEquals("=", predicate.getOperator());
				assertEquals("'GB'", predicate.getLiteral2());
				assertNull(predicate.getLiteral1());
				assertNull(predicate.getSuperLexical2());
			} else if (k == 1) {
				//Predicate predicate2 = ((ScanOperator) input1Operator).getPredicates().get(1);
				assertEquals("countrye", predicate.getSuperLexical1().getName());
				assertEquals("citye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
				assertEquals("=", predicate.getOperator());
				assertEquals("'D'", predicate.getLiteral2());
				assertEquals("or", predicate.getAndOr());
				assertNull(predicate.getLiteral1());
				assertNull(predicate.getSuperLexical2());
			}
			k++;
		}

		assertNotNull(input1Operator.getResultType());
		ResultType resultType2 = input1Operator.getResultType();
		assertEquals(6, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray2 = new String[6];
		DataType[] actualResultFieldTypesArray2 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray2 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);
	}

	//---------------------------------------------------------------------

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectStarFromJoinQueryOneSource() {
		String selectStarFromJoinQuery = "Select * from citye, countrye where citye.countrye = countrye.codee";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectStarFromJoinQuery);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectStarFromJoinQueryAst = parser.parseSQL(selectStarFromJoinQuery);
		logger.debug("selectStarFromJoinQueryAst: " + selectStarFromJoinQueryAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectStarFromJoinQuery, selectStarFromJoinQueryAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(12, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals(
				"citye.namee, citye.countrye, citye.provincee, citye.populatione, citye.longitudee, citye.latitudee, countrye.namee, countrye.codee, countrye.capitale, countrye.provincee, countrye.areae, countrye.populatione",
				((ReduceOperator) rootOperator).getReconcilingExpression().getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[12];
		String[] superAbstractNamesArray = new String[12];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee", "codee",
				"capitale", "provincee", "areae", "populatione" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye", "countrye",
				"countrye", "countrye", "countrye" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[12];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione",
				"citye.longitudee", "citye.latitudee", "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee",
				"countrye.areae", "countrye.populatione" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType0 = rootOperator.getResultType();
		assertEquals(12, resultType0.getResultFields().size());
		String[] expectedResultFieldNamesArray0 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee", "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione" };
		DataType[] expectedResultFieldTypesArray0 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray0 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray0 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray0 = new String[12];
		DataType[] actualResultFieldTypesArray0 = new DataType[12];
		String[] actualCanonicalModelConstructNamesArray0 = new String[12];
		String[] actualParentCanonicalModelConstructNamesArray0 = new String[12];

		i = 0;
		Map<String, ResultField> resultFields0 = resultType0.getResultFields();
		Set<String> resultFieldNames0 = resultFields0.keySet();
		for (String resultFieldName : resultFieldNames0) {
			actualResultFieldNamesArray0[i] = resultFieldName;
			actualResultFieldTypesArray0[i] = resultFields0.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultFields0.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields0.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultFields0.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray0, actualResultFieldNamesArray0);
		assertArrayEquals(expectedResultFieldTypesArray0, actualResultFieldTypesArray0);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray0, actualCanonicalModelConstructNamesArray0);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray0, actualParentCanonicalModelConstructNamesArray0);

		MappingOperator input0Operator = rootOperator.getLhsInput();

		isInstanceOf(JoinOperator.class, input0Operator);
		assertNull(input0Operator.getVariableName());
		assertNotNull(((JoinOperator) input0Operator).getReconcilingExpression());
		assertEquals("citye.countrye = countrye.codee", ((JoinOperator) input0Operator).getReconcilingExpression().getExpression());
		assertNotNull(input0Operator.getLhsInput());
		assertNotNull(input0Operator.getRhsInput());
		assertEquals(input0Operator.getInput(), input0Operator.getLhsInput());

		assertNotNull(input0Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input0Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input0Operator).getPredicates().size());
		Predicate predicate = ((JoinOperator) input0Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate.getSuperLexical1().getName());
		assertEquals("citye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate.getOperator());
		assertEquals("codee", predicate.getSuperLexical2().getName());
		assertEquals("countrye", predicate.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate.getLiteral1());
		assertNull(predicate.getLiteral2());

		assertNotNull(input0Operator.getResultType());
		ResultType resultType = input0Operator.getResultType();
		assertEquals(12, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee", "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray = new String[12];
		DataType[] actualResultFieldTypesArray = new DataType[12];
		String[] actualCanonicalModelConstructNamesArray = new String[12];
		String[] actualParentCanonicalModelConstructNamesArray = new String[12];

		i = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[i] = resultFieldName;
			actualResultFieldTypesArray[i] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input1Operator = input0Operator.getLhsInput();
		isInstanceOf(ScanOperator.class, input1Operator);
		assertEquals("citye", input1Operator.getVariableName());
		assertNull(input1Operator.getLhsInput());
		assertNull(input1Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input1Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input1Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input1Operator).getPredicates().size());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertNotNull(input1Operator.getResultType());
		ResultType resultType2 = input1Operator.getResultType();
		assertEquals(6, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray2 = new String[6];
		DataType[] actualResultFieldTypesArray2 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray2 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);

		MappingOperator input2Operator = input0Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input2Operator);
		assertEquals("countrye", input2Operator.getVariableName());
		assertNull(input2Operator.getLhsInput());
		assertNull(input2Operator.getRhsInput());
		assertEquals("countrye", ((ScanOperator) input2Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input2Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input1Operator).getPredicates().size());

		assertNotNull(input2Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input2Operator.getDataSource());

		assertNotNull(input2Operator.getResultType());
		ResultType resultType3 = input2Operator.getResultType();
		assertEquals(6, resultType3.getResultFields().size());
		String[] expectedResultFieldNamesArray3 = { "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione" };
		DataType[] expectedResultFieldTypesArray3 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT,
				DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray3 = { "namee", "codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray3 = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray3 = new String[6];
		DataType[] actualResultFieldTypesArray3 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray3 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray3 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields3 = resultType3.getResultFields();
		Set<String> resultFieldNames3 = resultFields3.keySet();
		for (String resultFieldName : resultFieldNames3) {
			actualResultFieldNamesArray3[i] = resultFieldName;
			actualResultFieldTypesArray3[i] = resultFields3.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray3[i] = resultFields3.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields3.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray3[i] = ((SuperLexical) resultFields3.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray3, actualResultFieldNamesArray3);
		assertArrayEquals(expectedResultFieldTypesArray3, actualResultFieldTypesArray3);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray3, actualCanonicalModelConstructNamesArray3);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray3, actualParentCanonicalModelConstructNamesArray3);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectStarFromJoinWhereQueryOneSource() {
		String selectStarFromJoinWhereQuery = "Select * from citye, countrye where citye.countrye = countrye.codee and countrye.codee = 'GB'";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectStarFromJoinWhereQuery);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectStarFromJoinWhereQueryAst = parser.parseSQL(selectStarFromJoinWhereQuery);
		logger.debug("selectStarFromJoinWhereQueryAst: " + selectStarFromJoinWhereQueryAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectStarFromJoinWhereQuery, selectStarFromJoinWhereQueryAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(12, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals(
				"citye.namee, citye.countrye, citye.provincee, citye.populatione, citye.longitudee, citye.latitudee, countrye.namee, countrye.codee, countrye.capitale, countrye.provincee, countrye.areae, countrye.populatione",
				((ReduceOperator) rootOperator).getReconcilingExpression().getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[12];
		String[] superAbstractNamesArray = new String[12];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee", "codee",
				"capitale", "provincee", "areae", "populatione" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye", "countrye",
				"countrye", "countrye", "countrye" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[12];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione",
				"citye.longitudee", "citye.latitudee", "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee",
				"countrye.areae", "countrye.populatione" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType0 = rootOperator.getResultType();
		assertEquals(12, resultType0.getResultFields().size());
		String[] expectedResultFieldNamesArray0 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee", "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione" };
		DataType[] expectedResultFieldTypesArray0 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray0 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray0 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray0 = new String[12];
		DataType[] actualResultFieldTypesArray0 = new DataType[12];
		String[] actualCanonicalModelConstructNamesArray0 = new String[12];
		String[] actualParentCanonicalModelConstructNamesArray0 = new String[12];

		i = 0;
		Map<String, ResultField> resultFields0 = resultType0.getResultFields();
		Set<String> resultFieldNames0 = resultFields0.keySet();
		for (String resultFieldName : resultFieldNames0) {
			actualResultFieldNamesArray0[i] = resultFieldName;
			actualResultFieldTypesArray0[i] = resultFields0.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultFields0.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields0.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultFields0.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray0, actualResultFieldNamesArray0);
		assertArrayEquals(expectedResultFieldTypesArray0, actualResultFieldTypesArray0);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray0, actualCanonicalModelConstructNamesArray0);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray0, actualParentCanonicalModelConstructNamesArray0);

		MappingOperator input0Operator = rootOperator.getLhsInput();

		isInstanceOf(JoinOperator.class, input0Operator);
		assertNull(input0Operator.getVariableName());
		assertNotNull(((JoinOperator) input0Operator).getReconcilingExpression());
		assertEquals("citye.countrye = countrye.codee", ((JoinOperator) input0Operator).getReconcilingExpression().getExpression());
		assertNotNull(input0Operator.getLhsInput());
		assertNotNull(input0Operator.getRhsInput());
		assertEquals(input0Operator.getInput(), input0Operator.getLhsInput());

		assertNotNull(input0Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input0Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input0Operator).getPredicates().size());
		Predicate predicate = ((JoinOperator) input0Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate.getSuperLexical1().getName());
		assertEquals("citye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate.getOperator());
		assertEquals("codee", predicate.getSuperLexical2().getName());
		assertEquals("countrye", predicate.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate.getLiteral1());
		assertNull(predicate.getLiteral2());

		assertNotNull(input0Operator.getResultType());
		ResultType resultType = input0Operator.getResultType();
		assertEquals(12, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee", "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray = new String[12];
		DataType[] actualResultFieldTypesArray = new DataType[12];
		String[] actualCanonicalModelConstructNamesArray = new String[12];
		String[] actualParentCanonicalModelConstructNamesArray = new String[12];

		i = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[i] = resultFieldName;
			actualResultFieldTypesArray[i] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input1Operator = input0Operator.getLhsInput();
		isInstanceOf(ScanOperator.class, input1Operator);
		assertEquals("citye", input1Operator.getVariableName());
		assertNull(input1Operator.getLhsInput());
		assertNull(input1Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input1Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input1Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input1Operator).getPredicates().size());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertNotNull(input1Operator.getResultType());
		ResultType resultType2 = input1Operator.getResultType();
		assertEquals(6, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray2 = new String[6];
		DataType[] actualResultFieldTypesArray2 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray2 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);

		MappingOperator input2Operator = input0Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input2Operator);
		assertEquals("countrye", input2Operator.getVariableName());
		assertNull(input2Operator.getLhsInput());
		assertNull(input2Operator.getRhsInput());
		assertEquals("countrye", ((ScanOperator) input2Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input2Operator).getReconcilingExpression());
		assertEquals("countrye.codee = 'GB'", ((ScanOperator) input2Operator).getReconcilingExpression().getExpression());
		assertEquals("and", ((ScanOperator) input2Operator).getAndOr());

		assertNotNull(input2Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input2Operator.getDataSource());

		assertEquals(1, ((ScanOperator) input2Operator).getPredicates().size());
		Predicate predicate1 = ((ScanOperator) input2Operator).getPredicates().iterator().next();
		assertEquals("codee", predicate1.getSuperLexical1().getName());
		assertEquals("countrye", predicate1.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate1.getOperator());
		assertEquals("'GB'", predicate1.getLiteral2());
		assertEquals("and", predicate1.getAndOr());
		assertNull(predicate1.getLiteral1());
		assertNull(predicate1.getSuperLexical2());

		assertNotNull(input2Operator.getResultType());
		ResultType resultType3 = input2Operator.getResultType();
		assertEquals(6, resultType3.getResultFields().size());
		String[] expectedResultFieldNamesArray3 = { "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione" };
		DataType[] expectedResultFieldTypesArray3 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT,
				DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray3 = { "namee", "codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray3 = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray3 = new String[6];
		DataType[] actualResultFieldTypesArray3 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray3 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray3 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields3 = resultType3.getResultFields();
		Set<String> resultFieldNames3 = resultFields3.keySet();
		for (String resultFieldName : resultFieldNames3) {
			actualResultFieldNamesArray3[i] = resultFieldName;
			actualResultFieldTypesArray3[i] = resultFields3.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray3[i] = resultFields3.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields3.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray3[i] = ((SuperLexical) resultFields3.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray3, actualResultFieldNamesArray3);
		assertArrayEquals(expectedResultFieldTypesArray3, actualResultFieldTypesArray3);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray3, actualCanonicalModelConstructNamesArray3);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray3, actualParentCanonicalModelConstructNamesArray3);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectStarFromJoinWhereAndQueryOneSource() {
		String selectStarFromJoinWhereAndQuery = "Select * from citye, countrye where citye.countrye = countrye.codee and countrye.codee = 'GB' and citye.namee = 'Manchester'";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectStarFromJoinWhereAndQuery);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectStarFromJoinWhereAndQueryAst = parser.parseSQL(selectStarFromJoinWhereAndQuery);
		logger.debug("selectStarFromJoinWhereAndQueryAst: " + selectStarFromJoinWhereAndQueryAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectStarFromJoinWhereAndQuery, selectStarFromJoinWhereAndQueryAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(12, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals(
				"citye.namee, citye.countrye, citye.provincee, citye.populatione, citye.longitudee, citye.latitudee, countrye.namee, countrye.codee, countrye.capitale, countrye.provincee, countrye.areae, countrye.populatione",
				((ReduceOperator) rootOperator).getReconcilingExpression().getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[12];
		String[] superAbstractNamesArray = new String[12];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee", "codee",
				"capitale", "provincee", "areae", "populatione" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye", "countrye",
				"countrye", "countrye", "countrye" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[12];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione",
				"citye.longitudee", "citye.latitudee", "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee",
				"countrye.areae", "countrye.populatione" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType0 = rootOperator.getResultType();
		assertEquals(12, resultType0.getResultFields().size());
		String[] expectedResultFieldNamesArray0 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee", "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione" };
		DataType[] expectedResultFieldTypesArray0 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray0 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray0 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray0 = new String[12];
		DataType[] actualResultFieldTypesArray0 = new DataType[12];
		String[] actualCanonicalModelConstructNamesArray0 = new String[12];
		String[] actualParentCanonicalModelConstructNamesArray0 = new String[12];

		i = 0;
		Map<String, ResultField> resultFields0 = resultType0.getResultFields();
		Set<String> resultFieldNames0 = resultFields0.keySet();
		for (String resultFieldName : resultFieldNames0) {
			actualResultFieldNamesArray0[i] = resultFieldName;
			actualResultFieldTypesArray0[i] = resultFields0.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultFields0.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields0.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultFields0.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray0, actualResultFieldNamesArray0);
		assertArrayEquals(expectedResultFieldTypesArray0, actualResultFieldTypesArray0);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray0, actualCanonicalModelConstructNamesArray0);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray0, actualParentCanonicalModelConstructNamesArray0);

		MappingOperator input0Operator = rootOperator.getLhsInput();

		isInstanceOf(JoinOperator.class, input0Operator);
		assertNull(input0Operator.getVariableName());
		assertNotNull(((JoinOperator) input0Operator).getReconcilingExpression());
		assertEquals("citye.countrye = countrye.codee", ((JoinOperator) input0Operator).getReconcilingExpression().getExpression());
		assertNotNull(input0Operator.getLhsInput());
		assertNotNull(input0Operator.getRhsInput());
		assertEquals(input0Operator.getInput(), input0Operator.getLhsInput());

		assertNotNull(input0Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input0Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input0Operator).getPredicates().size());
		Predicate predicate = ((JoinOperator) input0Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate.getSuperLexical1().getName());
		assertEquals("citye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate.getOperator());
		assertEquals("codee", predicate.getSuperLexical2().getName());
		assertEquals("countrye", predicate.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate.getLiteral1());
		assertNull(predicate.getLiteral2());

		assertNotNull(input0Operator.getResultType());
		ResultType resultType = input0Operator.getResultType();
		assertEquals(12, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee", "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray = new String[12];
		DataType[] actualResultFieldTypesArray = new DataType[12];
		String[] actualCanonicalModelConstructNamesArray = new String[12];
		String[] actualParentCanonicalModelConstructNamesArray = new String[12];

		i = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[i] = resultFieldName;
			actualResultFieldTypesArray[i] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input1Operator = input0Operator.getLhsInput();
		isInstanceOf(ScanOperator.class, input1Operator);
		assertEquals("citye", input1Operator.getVariableName());
		assertNull(input1Operator.getLhsInput());
		assertNull(input1Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input1Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input1Operator).getReconcilingExpression());
		assertEquals("citye.namee = 'Manchester'", ((ScanOperator) input1Operator).getReconcilingExpression().getExpression());
		assertEquals("and", ((ScanOperator) input1Operator).getAndOr());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertEquals(1, ((ScanOperator) input1Operator).getPredicates().size());
		Predicate predicate1 = ((ScanOperator) input1Operator).getPredicates().iterator().next();
		assertEquals("namee", predicate1.getSuperLexical1().getName());
		assertEquals("citye", predicate1.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate1.getOperator());
		assertEquals("'Manchester'", predicate1.getLiteral2());
		assertEquals("and", predicate1.getAndOr());
		assertNull(predicate1.getLiteral1());
		assertNull(predicate1.getSuperLexical2());

		assertNotNull(input1Operator.getResultType());
		ResultType resultType2 = input1Operator.getResultType();
		assertEquals(6, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray2 = new String[6];
		DataType[] actualResultFieldTypesArray2 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray2 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);

		MappingOperator input2Operator = input0Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input2Operator);
		assertEquals("countrye", input2Operator.getVariableName());
		assertNull(input2Operator.getLhsInput());
		assertNull(input2Operator.getRhsInput());
		assertEquals("countrye", ((ScanOperator) input2Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input2Operator).getReconcilingExpression());
		assertEquals("countrye.codee = 'GB'", ((ScanOperator) input2Operator).getReconcilingExpression().getExpression());
		assertEquals("and", ((ScanOperator) input2Operator).getAndOr());

		assertNotNull(input2Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input2Operator.getDataSource());

		assertEquals(1, ((ScanOperator) input2Operator).getPredicates().size());
		Predicate predicate2 = ((ScanOperator) input2Operator).getPredicates().iterator().next();
		assertEquals("codee", predicate2.getSuperLexical1().getName());
		assertEquals("countrye", predicate2.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate2.getOperator());
		assertEquals("'GB'", predicate2.getLiteral2());
		assertEquals("and", predicate2.getAndOr());
		assertNull(predicate2.getLiteral1());
		assertNull(predicate2.getSuperLexical2());

		assertNotNull(input2Operator.getResultType());
		ResultType resultType3 = input2Operator.getResultType();
		assertEquals(6, resultType3.getResultFields().size());
		String[] expectedResultFieldNamesArray3 = { "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione" };
		DataType[] expectedResultFieldTypesArray3 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT,
				DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray3 = { "namee", "codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray3 = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray3 = new String[6];
		DataType[] actualResultFieldTypesArray3 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray3 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray3 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields3 = resultType3.getResultFields();
		Set<String> resultFieldNames3 = resultFields3.keySet();
		for (String resultFieldName : resultFieldNames3) {
			actualResultFieldNamesArray3[i] = resultFieldName;
			actualResultFieldTypesArray3[i] = resultFields3.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray3[i] = resultFields3.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields3.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray3[i] = ((SuperLexical) resultFields3.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray3, actualResultFieldNamesArray3);
		assertArrayEquals(expectedResultFieldTypesArray3, actualResultFieldTypesArray3);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray3, actualCanonicalModelConstructNamesArray3);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray3, actualParentCanonicalModelConstructNamesArray3);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	//TODO work on allowing brackets and keeping track of which predicates were together in a set of brackets
	//@Test
	public void testTranslateAstIntoQuerySelectStarFromJoinWhereOrQueryOneSource() {
		String selectStarFromJoinWhereOrQuery = "Select * from citye, countrye where citye.countrye = countrye.codee and (countrye.codee = 'GB' or countrye.codee = 'D')";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectStarFromJoinWhereOrQuery);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectStarFromJoinWhereOrQueryAst = parser.parseSQL(selectStarFromJoinWhereOrQuery);
		logger.debug("selectStarFromJoinWhereOrQueryAst: " + selectStarFromJoinWhereOrQueryAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectStarFromJoinWhereOrQuery, selectStarFromJoinWhereOrQueryAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(12, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals(
				"citye.namee, citye.countrye, citye.provincee, citye.populatione, citye.longitudee, citye.latitudee, countrye.namee, countrye.codee, countrye.capitale, countrye.provincee, countrye.areae, countrye.populatione",
				((ReduceOperator) rootOperator).getReconcilingExpression().getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[12];
		String[] superAbstractNamesArray = new String[12];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee", "codee",
				"capitale", "provincee", "areae", "populatione" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye", "countrye",
				"countrye", "countrye", "countrye" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[12];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione",
				"citye.longitudee", "citye.latitudee", "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee",
				"countrye.areae", "countrye.populatione" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType0 = rootOperator.getResultType();
		assertEquals(12, resultType0.getResultFields().size());
		String[] expectedResultFieldNamesArray0 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee", "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione" };
		DataType[] expectedResultFieldTypesArray0 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray0 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray0 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray0 = new String[12];
		DataType[] actualResultFieldTypesArray0 = new DataType[12];
		String[] actualCanonicalModelConstructNamesArray0 = new String[12];
		String[] actualParentCanonicalModelConstructNamesArray0 = new String[12];

		i = 0;
		Map<String, ResultField> resultFields0 = resultType0.getResultFields();
		Set<String> resultFieldNames0 = resultFields0.keySet();
		for (String resultFieldName : resultFieldNames0) {
			actualResultFieldNamesArray0[i] = resultFieldName;
			actualResultFieldTypesArray0[i] = resultFields0.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultFields0.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields0.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultFields0.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray0, actualResultFieldNamesArray0);
		assertArrayEquals(expectedResultFieldTypesArray0, actualResultFieldTypesArray0);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray0, actualCanonicalModelConstructNamesArray0);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray0, actualParentCanonicalModelConstructNamesArray0);

		MappingOperator input0Operator = rootOperator.getLhsInput();

		isInstanceOf(JoinOperator.class, input0Operator);
		assertNull(input0Operator.getVariableName());
		assertNotNull(((JoinOperator) input0Operator).getReconcilingExpression());
		assertEquals("citye.countrye = countrye.codee", ((JoinOperator) input0Operator).getReconcilingExpression().getExpression());
		assertNotNull(input0Operator.getLhsInput());
		assertNotNull(input0Operator.getRhsInput());
		assertEquals(input0Operator.getInput(), input0Operator.getLhsInput());

		assertNotNull(input0Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input0Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input0Operator).getPredicates().size());
		Predicate predicate = ((JoinOperator) input0Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate.getSuperLexical1().getName());
		assertEquals("citye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate.getOperator());
		assertEquals("codee", predicate.getSuperLexical2().getName());
		assertEquals("countrye", predicate.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate.getLiteral1());
		assertNull(predicate.getLiteral2());

		assertNotNull(input0Operator.getResultType());
		ResultType resultType = input0Operator.getResultType();
		assertEquals(12, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee", "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray = new String[12];
		DataType[] actualResultFieldTypesArray = new DataType[12];
		String[] actualCanonicalModelConstructNamesArray = new String[12];
		String[] actualParentCanonicalModelConstructNamesArray = new String[12];

		i = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[i] = resultFieldName;
			actualResultFieldTypesArray[i] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input1Operator = input0Operator.getLhsInput();
		isInstanceOf(ScanOperator.class, input1Operator);
		assertEquals("citye", input1Operator.getVariableName());
		assertNull(input1Operator.getLhsInput());
		assertNull(input1Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input1Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input1Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input1Operator).getPredicates().size());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertNotNull(input1Operator.getResultType());
		ResultType resultType2 = input1Operator.getResultType();
		assertEquals(6, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray2 = new String[6];
		DataType[] actualResultFieldTypesArray2 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray2 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);

		MappingOperator input2Operator = input0Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input2Operator);
		assertEquals("countrye", input2Operator.getVariableName());
		assertNull(input2Operator.getLhsInput());
		assertNull(input2Operator.getRhsInput());
		assertEquals("countrye", ((ScanOperator) input2Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input2Operator).getReconcilingExpression());
		assertEquals("countrye.codee = 'GB' or countrye.codee = 'D'", ((ScanOperator) input2Operator).getReconcilingExpression().getExpression());
		assertEquals("and", ((ScanOperator) input2Operator).getAndOr());

		assertNotNull(input2Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input2Operator.getDataSource());

		assertEquals(2, ((ScanOperator) input2Operator).getPredicates().size());

		Set<Predicate> predicates = ((ScanOperator) input2Operator).getPredicates();

		int k = 0;

		for (Predicate predicate1 : predicates) {
			if (k == 0) {
				//Predicate predicate1 = ((ScanOperator) input2Operator).getPredicates().get(0);
				assertEquals("codee", predicate1.getSuperLexical1().getName());
				assertEquals("countrye", predicate1.getSuperLexical1().getParentSuperAbstract().getName());
				assertEquals("=", predicate1.getOperator());
				assertEquals("'GB'", predicate1.getLiteral2());
				assertEquals("and", predicate1.getAndOr());
				assertNull(predicate1.getLiteral1());
				assertNull(predicate1.getSuperLexical2());
			} else if (k == 1) {
				//Predicate predicate2 = ((ScanOperator) input2Operator).getPredicates().get(1);
				assertEquals("codee", predicate1.getSuperLexical1().getName());
				assertEquals("countrye", predicate1.getSuperLexical1().getParentSuperAbstract().getName());
				assertEquals("=", predicate1.getOperator());
				assertEquals("'D'", predicate1.getLiteral2());
				assertEquals("or", predicate1.getAndOr());
				assertNull(predicate1.getLiteral1());
				assertNull(predicate1.getSuperLexical2());
			}
			k++;
		}
		assertNotNull(input2Operator.getResultType());
		ResultType resultType3 = input2Operator.getResultType();
		assertEquals(6, resultType3.getResultFields().size());
		String[] expectedResultFieldNamesArray3 = { "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione" };
		DataType[] expectedResultFieldTypesArray3 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT,
				DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray3 = { "namee", "codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray3 = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray3 = new String[6];
		DataType[] actualResultFieldTypesArray3 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray3 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray3 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields3 = resultType3.getResultFields();
		Set<String> resultFieldNames3 = resultFields3.keySet();
		for (String resultFieldName : resultFieldNames3) {
			actualResultFieldNamesArray3[i] = resultFieldName;
			actualResultFieldTypesArray3[i] = resultFields3.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray3[i] = resultFields3.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields3.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray3[i] = ((SuperLexical) resultFields3.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray3, actualResultFieldNamesArray3);
		assertArrayEquals(expectedResultFieldTypesArray3, actualResultFieldTypesArray3);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray3, actualCanonicalModelConstructNamesArray3);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray3, actualParentCanonicalModelConstructNamesArray3);
	}

	//---------------------------------------------------------------------

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectSuperLexicalsFromJoinQueryOneSource() {
		String selectSuperLexicalsFromJoinQuery = "Select citye.namee, citye.countrye, citye.provincee, countrye.namee, countrye.capitale from citye, countrye where citye.countrye = countrye.codee";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectSuperLexicalsFromJoinQuery);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectSuperLexicalsFromJoinQueryAst = parser.parseSQL(selectSuperLexicalsFromJoinQuery);
		logger.debug("selectSuperLexicalsFromJoinQueryAst: " + selectSuperLexicalsFromJoinQueryAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectSuperLexicalsFromJoinQuery, selectSuperLexicalsFromJoinQueryAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(5, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals("citye.namee, citye.countrye, citye.provincee, countrye.namee, countrye.capitale", ((ReduceOperator) rootOperator)
				.getReconcilingExpression().getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[5];
		String[] superAbstractNamesArray = new String[5];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "namee", "capitale" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "countrye", "countrye" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[5];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "countrye.namee", "countrye.capitale" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType = rootOperator.getResultType();
		assertEquals(5, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "countrye.namee", "countrye.capitale" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "namee", "capitale" };
		String[] expectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray = new String[5];
		DataType[] actualResultFieldTypesArray = new DataType[5];
		String[] actualCanonicalModelConstructNamesArray = new String[5];
		String[] actualParentCanonicalModelConstructNamesArray = new String[5];

		int j = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[j] = resultFieldName;
			actualResultFieldTypesArray[j] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[j] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[j] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			j++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(expectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input1Operator = rootOperator.getLhsInput();

		isInstanceOf(JoinOperator.class, input1Operator);
		assertNull(input1Operator.getVariableName());
		assertNotNull(((JoinOperator) input1Operator).getReconcilingExpression());
		assertEquals("citye.countrye = countrye.codee", ((JoinOperator) input1Operator).getReconcilingExpression().getExpression());
		assertNotNull(input1Operator.getLhsInput());
		assertNotNull(input1Operator.getRhsInput());
		assertEquals(input1Operator.getInput(), input1Operator.getLhsInput());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input1Operator).getPredicates().size());
		Predicate predicate = ((JoinOperator) input1Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate.getSuperLexical1().getName());
		assertEquals("citye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate.getOperator());
		assertEquals("codee", predicate.getSuperLexical2().getName());
		assertEquals("countrye", predicate.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate.getLiteral1());
		assertNull(predicate.getLiteral2());

		assertNotNull(input1Operator.getResultType());
		ResultType resultType1 = input1Operator.getResultType();
		assertEquals(12, resultType1.getResultFields().size());
		String[] expectedResultFieldNamesArray1 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee", "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione" };
		DataType[] expectedResultFieldTypesArray1 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray1 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray1 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray1 = new String[12];
		DataType[] actualResultFieldTypesArray1 = new DataType[12];
		String[] actualCanonicalModelConstructNamesArray1 = new String[12];
		String[] actualParentCanonicalModelConstructNamesArray1 = new String[12];

		i = 0;
		Map<String, ResultField> resultFields1 = resultType1.getResultFields();
		Set<String> resultFieldNames1 = resultFields1.keySet();
		for (String resultFieldName : resultFieldNames1) {
			actualResultFieldNamesArray1[i] = resultFieldName;
			actualResultFieldTypesArray1[i] = resultFields1.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray1[i] = resultFields1.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields1.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray1[i] = ((SuperLexical) resultFields1.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray1, actualResultFieldNamesArray1);
		assertArrayEquals(expectedResultFieldTypesArray1, actualResultFieldTypesArray1);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray1, actualCanonicalModelConstructNamesArray1);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray1, actualParentCanonicalModelConstructNamesArray1);

		MappingOperator input11Operator = input1Operator.getLhsInput();
		isInstanceOf(ScanOperator.class, input11Operator);
		assertEquals("citye", input11Operator.getVariableName());
		assertNull(input11Operator.getLhsInput());
		assertNull(input11Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input11Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input11Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input11Operator).getPredicates().size());

		assertNotNull(input11Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input11Operator.getDataSource());

		assertNotNull(input11Operator.getResultType());
		ResultType resultType2 = input11Operator.getResultType();
		assertEquals(6, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray2 = new String[6];
		DataType[] actualResultFieldTypesArray2 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray2 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);

		MappingOperator input12Operator = input1Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input12Operator);
		assertEquals("countrye", input12Operator.getVariableName());
		assertNull(input12Operator.getLhsInput());
		assertNull(input12Operator.getRhsInput());
		assertEquals("countrye", ((ScanOperator) input12Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input12Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input12Operator).getPredicates().size());

		assertNotNull(input12Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input12Operator.getDataSource());

		assertNotNull(input12Operator.getResultType());
		ResultType resultType3 = input12Operator.getResultType();
		assertEquals(6, resultType3.getResultFields().size());
		String[] expectedResultFieldNamesArray3 = { "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione" };
		DataType[] expectedResultFieldTypesArray3 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT,
				DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray3 = { "namee", "codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray3 = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray3 = new String[6];
		DataType[] actualResultFieldTypesArray3 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray3 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray3 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields3 = resultType3.getResultFields();
		Set<String> resultFieldNames3 = resultFields3.keySet();
		for (String resultFieldName : resultFieldNames3) {
			actualResultFieldNamesArray3[i] = resultFieldName;
			actualResultFieldTypesArray3[i] = resultFields3.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray3[i] = resultFields3.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields3.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray3[i] = ((SuperLexical) resultFields3.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray3, actualResultFieldNamesArray3);
		assertArrayEquals(expectedResultFieldTypesArray3, actualResultFieldTypesArray3);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray3, actualCanonicalModelConstructNamesArray3);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray3, actualParentCanonicalModelConstructNamesArray3);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectSuperLexicalsFromJoinWhereQueryOneSource() {
		String selectSuperLexicalsFromJoinWhereQuery = "Select citye.namee, citye.countrye, citye.provincee, countrye.namee, countrye.capitale from citye, countrye where citye.countrye = countrye.codee and countrye.codee = 'GB'";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectSuperLexicalsFromJoinWhereQuery);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectSuperLexicalsFromJoinWhereQueryAst = parser.parseSQL(selectSuperLexicalsFromJoinWhereQuery);
		logger.debug("selectSuperLexicalsFromJoinWhereQueryAst: " + selectSuperLexicalsFromJoinWhereQueryAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectSuperLexicalsFromJoinWhereQuery, selectSuperLexicalsFromJoinWhereQueryAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(5, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals("citye.namee, citye.countrye, citye.provincee, countrye.namee, countrye.capitale", ((ReduceOperator) rootOperator)
				.getReconcilingExpression().getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[5];
		String[] superAbstractNamesArray = new String[5];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "namee", "capitale" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "countrye", "countrye" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[5];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "countrye.namee", "countrye.capitale" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType = rootOperator.getResultType();
		assertEquals(5, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "countrye.namee", "countrye.capitale" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "namee", "capitale" };
		String[] expectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray = new String[5];
		DataType[] actualResultFieldTypesArray = new DataType[5];
		String[] actualCanonicalModelConstructNamesArray = new String[5];
		String[] actualParentCanonicalModelConstructNamesArray = new String[5];

		int j = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[j] = resultFieldName;
			actualResultFieldTypesArray[j] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[j] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[j] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			j++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(expectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input1Operator = rootOperator.getLhsInput();

		isInstanceOf(JoinOperator.class, input1Operator);
		assertNull(input1Operator.getVariableName());
		assertNotNull(((JoinOperator) input1Operator).getReconcilingExpression());
		assertEquals("citye.countrye = countrye.codee", ((JoinOperator) input1Operator).getReconcilingExpression().getExpression());
		assertNotNull(input1Operator.getLhsInput());
		assertNotNull(input1Operator.getRhsInput());
		assertEquals(input1Operator.getInput(), input1Operator.getLhsInput());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input1Operator).getPredicates().size());
		Predicate predicate = ((JoinOperator) input1Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate.getSuperLexical1().getName());
		assertEquals("citye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate.getOperator());
		assertEquals("codee", predicate.getSuperLexical2().getName());
		assertEquals("countrye", predicate.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate.getLiteral1());
		assertNull(predicate.getLiteral2());

		assertNotNull(input1Operator.getResultType());
		ResultType resultType1 = input1Operator.getResultType();
		assertEquals(12, resultType1.getResultFields().size());
		String[] expectedResultFieldNamesArray1 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee", "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione" };
		DataType[] expectedResultFieldTypesArray1 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray1 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray1 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray1 = new String[12];
		DataType[] actualResultFieldTypesArray1 = new DataType[12];
		String[] actualCanonicalModelConstructNamesArray1 = new String[12];
		String[] actualParentCanonicalModelConstructNamesArray1 = new String[12];

		i = 0;
		Map<String, ResultField> resultFields1 = resultType1.getResultFields();
		Set<String> resultFieldNames1 = resultFields1.keySet();
		for (String resultFieldName : resultFieldNames1) {
			actualResultFieldNamesArray1[i] = resultFieldName;
			actualResultFieldTypesArray1[i] = resultFields1.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray1[i] = resultFields1.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields1.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray1[i] = ((SuperLexical) resultFields1.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray1, actualResultFieldNamesArray1);
		assertArrayEquals(expectedResultFieldTypesArray1, actualResultFieldTypesArray1);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray1, actualCanonicalModelConstructNamesArray1);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray1, actualParentCanonicalModelConstructNamesArray1);

		MappingOperator input11Operator = input1Operator.getLhsInput();
		isInstanceOf(ScanOperator.class, input11Operator);
		assertEquals("citye", input11Operator.getVariableName());
		assertNull(input11Operator.getLhsInput());
		assertNull(input11Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input11Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input11Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input11Operator).getPredicates().size());

		assertNotNull(input11Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input11Operator.getDataSource());

		assertNotNull(input11Operator.getResultType());
		ResultType resultType2 = input11Operator.getResultType();
		assertEquals(6, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray2 = new String[6];
		DataType[] actualResultFieldTypesArray2 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray2 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);

		MappingOperator input12Operator = input1Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input12Operator);
		assertEquals("countrye", input12Operator.getVariableName());
		assertNull(input12Operator.getLhsInput());
		assertNull(input12Operator.getRhsInput());
		assertEquals("countrye", ((ScanOperator) input12Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input12Operator).getReconcilingExpression());
		assertEquals("countrye.codee = 'GB'", ((ScanOperator) input12Operator).getReconcilingExpression().getExpression());
		assertEquals("and", ((ScanOperator) input12Operator).getAndOr());

		assertNotNull(input12Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input12Operator.getDataSource());

		assertEquals(1, ((ScanOperator) input12Operator).getPredicates().size());
		Predicate predicate1 = ((ScanOperator) input12Operator).getPredicates().iterator().next();
		;
		assertEquals("codee", predicate1.getSuperLexical1().getName());
		assertEquals("countrye", predicate1.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate1.getOperator());
		assertEquals("'GB'", predicate1.getLiteral2());
		assertEquals("and", predicate1.getAndOr());
		assertNull(predicate1.getLiteral1());
		assertNull(predicate1.getSuperLexical2());

		assertNotNull(input12Operator.getResultType());
		ResultType resultType3 = input12Operator.getResultType();
		assertEquals(6, resultType3.getResultFields().size());
		String[] expectedResultFieldNamesArray3 = { "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione" };
		DataType[] expectedResultFieldTypesArray3 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT,
				DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray3 = { "namee", "codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray3 = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray3 = new String[6];
		DataType[] actualResultFieldTypesArray3 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray3 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray3 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields3 = resultType3.getResultFields();
		Set<String> resultFieldNames3 = resultFields3.keySet();
		for (String resultFieldName : resultFieldNames3) {
			actualResultFieldNamesArray3[i] = resultFieldName;
			actualResultFieldTypesArray3[i] = resultFields3.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray3[i] = resultFields3.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields3.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray3[i] = ((SuperLexical) resultFields3.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray3, actualResultFieldNamesArray3);
		assertArrayEquals(expectedResultFieldTypesArray3, actualResultFieldTypesArray3);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray3, actualCanonicalModelConstructNamesArray3);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray3, actualParentCanonicalModelConstructNamesArray3);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectSuperLexicalsFromJoinWhereAndQueryOneSource() {
		String selectSuperLexicalsFromJoinWhereAndQuery = "Select citye.namee, citye.countrye, citye.provincee, countrye.namee, countrye.capitale from citye, countrye where citye.countrye = countrye.codee and countrye.codee = 'GB' and citye.namee = 'Manchester'";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectSuperLexicalsFromJoinWhereAndQuery);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectSuperLexicalsFromJoinWhereAndQueryAst = parser.parseSQL(selectSuperLexicalsFromJoinWhereAndQuery);
		logger.debug("selectSuperLexicalsFromJoinWhereAndQueryAst: " + selectSuperLexicalsFromJoinWhereAndQueryAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectSuperLexicalsFromJoinWhereAndQuery, selectSuperLexicalsFromJoinWhereAndQueryAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(5, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals("citye.namee, citye.countrye, citye.provincee, countrye.namee, countrye.capitale", ((ReduceOperator) rootOperator)
				.getReconcilingExpression().getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[5];
		String[] superAbstractNamesArray = new String[5];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "namee", "capitale" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "countrye", "countrye" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[5];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "countrye.namee", "countrye.capitale" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType = rootOperator.getResultType();
		assertEquals(5, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "countrye.namee", "countrye.capitale" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "namee", "capitale" };
		String[] expectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray = new String[5];
		DataType[] actualResultFieldTypesArray = new DataType[5];
		String[] actualCanonicalModelConstructNamesArray = new String[5];
		String[] actualParentCanonicalModelConstructNamesArray = new String[5];

		int j = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[j] = resultFieldName;
			actualResultFieldTypesArray[j] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[j] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[j] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			j++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(expectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input1Operator = rootOperator.getLhsInput();

		isInstanceOf(JoinOperator.class, input1Operator);
		assertNull(input1Operator.getVariableName());
		assertNotNull(((JoinOperator) input1Operator).getReconcilingExpression());
		assertEquals("citye.countrye = countrye.codee", ((JoinOperator) input1Operator).getReconcilingExpression().getExpression());
		assertNotNull(input1Operator.getLhsInput());
		assertNotNull(input1Operator.getRhsInput());
		assertEquals(input1Operator.getInput(), input1Operator.getLhsInput());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input1Operator).getPredicates().size());
		Predicate predicate = ((JoinOperator) input1Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate.getSuperLexical1().getName());
		assertEquals("citye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate.getOperator());
		assertEquals("codee", predicate.getSuperLexical2().getName());
		assertEquals("countrye", predicate.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate.getLiteral1());
		assertNull(predicate.getLiteral2());

		assertNotNull(input1Operator.getResultType());
		ResultType resultType1 = input1Operator.getResultType();
		assertEquals(12, resultType1.getResultFields().size());
		String[] expectedResultFieldNamesArray1 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee", "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione" };
		DataType[] expectedResultFieldTypesArray1 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray1 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray1 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray1 = new String[12];
		DataType[] actualResultFieldTypesArray1 = new DataType[12];
		String[] actualCanonicalModelConstructNamesArray1 = new String[12];
		String[] actualParentCanonicalModelConstructNamesArray1 = new String[12];

		i = 0;
		Map<String, ResultField> resultFields1 = resultType1.getResultFields();
		Set<String> resultFieldNames1 = resultFields1.keySet();
		for (String resultFieldName : resultFieldNames1) {
			actualResultFieldNamesArray1[i] = resultFieldName;
			actualResultFieldTypesArray1[i] = resultFields1.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray1[i] = resultFields1.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields1.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray1[i] = ((SuperLexical) resultFields1.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray1, actualResultFieldNamesArray1);
		assertArrayEquals(expectedResultFieldTypesArray1, actualResultFieldTypesArray1);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray1, actualCanonicalModelConstructNamesArray1);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray1, actualParentCanonicalModelConstructNamesArray1);

		MappingOperator input11Operator = input1Operator.getLhsInput();
		isInstanceOf(ScanOperator.class, input11Operator);
		assertEquals("citye", input11Operator.getVariableName());
		assertNull(input11Operator.getLhsInput());
		assertNull(input11Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input11Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input11Operator).getReconcilingExpression());
		assertEquals("citye.namee = 'Manchester'", ((ScanOperator) input11Operator).getReconcilingExpression().getExpression());
		assertEquals("and", ((ScanOperator) input11Operator).getAndOr());

		assertNotNull(input11Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input11Operator.getDataSource());

		assertEquals(1, ((ScanOperator) input11Operator).getPredicates().size());
		Predicate predicate1 = ((ScanOperator) input11Operator).getPredicates().iterator().next();
		;
		assertEquals("namee", predicate1.getSuperLexical1().getName());
		assertEquals("citye", predicate1.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate1.getOperator());
		assertEquals("'Manchester'", predicate1.getLiteral2());
		assertEquals("and", predicate1.getAndOr());
		assertNull(predicate1.getLiteral1());
		assertNull(predicate1.getSuperLexical2());

		assertNotNull(input11Operator.getResultType());
		ResultType resultType2 = input11Operator.getResultType();
		assertEquals(6, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray2 = new String[6];
		DataType[] actualResultFieldTypesArray2 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray2 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);

		MappingOperator input12Operator = input1Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input12Operator);
		assertEquals("countrye", input12Operator.getVariableName());
		assertNull(input12Operator.getLhsInput());
		assertNull(input12Operator.getRhsInput());
		assertEquals("countrye", ((ScanOperator) input12Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input12Operator).getReconcilingExpression());
		assertEquals("countrye.codee = 'GB'", ((ScanOperator) input12Operator).getReconcilingExpression().getExpression());
		assertEquals("and", ((ScanOperator) input12Operator).getAndOr());

		assertNotNull(input12Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input12Operator.getDataSource());

		assertEquals(1, ((ScanOperator) input12Operator).getPredicates().size());
		Predicate predicate2 = ((ScanOperator) input12Operator).getPredicates().iterator().next();
		assertEquals("codee", predicate2.getSuperLexical1().getName());
		assertEquals("countrye", predicate2.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate2.getOperator());
		assertEquals("'GB'", predicate2.getLiteral2());
		assertEquals("and", predicate2.getAndOr());
		assertNull(predicate2.getLiteral1());
		assertNull(predicate2.getSuperLexical2());

		assertNotNull(input12Operator.getResultType());
		ResultType resultType3 = input12Operator.getResultType();
		assertEquals(6, resultType3.getResultFields().size());
		String[] expectedResultFieldNamesArray3 = { "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione" };
		DataType[] expectedResultFieldTypesArray3 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT,
				DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray3 = { "namee", "codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray3 = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray3 = new String[6];
		DataType[] actualResultFieldTypesArray3 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray3 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray3 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields3 = resultType3.getResultFields();
		Set<String> resultFieldNames3 = resultFields3.keySet();
		for (String resultFieldName : resultFieldNames3) {
			actualResultFieldNamesArray3[i] = resultFieldName;
			actualResultFieldTypesArray3[i] = resultFields3.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray3[i] = resultFields3.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields3.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray3[i] = ((SuperLexical) resultFields3.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray3, actualResultFieldNamesArray3);
		assertArrayEquals(expectedResultFieldTypesArray3, actualResultFieldTypesArray3);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray3, actualCanonicalModelConstructNamesArray3);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray3, actualParentCanonicalModelConstructNamesArray3);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	//@Test
	public void testTranslateAstIntoQuerySelectSuperLexicalsFromJoinWhereOrQueryOneSource() {
		String selectSuperLexicalsFromJoinWhereOrQuery = "Select citye.namee, citye.countrye, citye.provincee, countrye.namee, countrye.capitale from citye, countrye where citye.countrye = countrye.codee and (countrye.codee = 'GB' or countrye.codee = 'D')";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectSuperLexicalsFromJoinWhereOrQuery);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectSuperLexicalsFromJoinWhereOrQueryAst = parser.parseSQL(selectSuperLexicalsFromJoinWhereOrQuery);
		logger.debug("selectSuperLexicalsFromJoinWhereOrQueryAst: " + selectSuperLexicalsFromJoinWhereOrQueryAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectSuperLexicalsFromJoinWhereOrQuery, selectSuperLexicalsFromJoinWhereOrQueryAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(5, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals("citye.namee, citye.countrye, citye.provincee, countrye.namee, countrye.capitale", ((ReduceOperator) rootOperator)
				.getReconcilingExpression().getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[5];
		String[] superAbstractNamesArray = new String[5];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "namee", "capitale" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "countrye", "countrye" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[5];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "countrye.namee", "countrye.capitale" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType = rootOperator.getResultType();
		assertEquals(5, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "countrye.namee", "countrye.capitale" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "namee", "capitale" };
		String[] expectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray = new String[5];
		DataType[] actualResultFieldTypesArray = new DataType[5];
		String[] actualCanonicalModelConstructNamesArray = new String[5];
		String[] actualParentCanonicalModelConstructNamesArray = new String[5];

		int j = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[j] = resultFieldName;
			actualResultFieldTypesArray[j] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[j] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[j] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			j++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(expectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input1Operator = rootOperator.getLhsInput();

		isInstanceOf(JoinOperator.class, input1Operator);
		assertNull(input1Operator.getVariableName());
		assertNotNull(((JoinOperator) input1Operator).getReconcilingExpression());
		assertEquals("citye.countrye = countrye.codee", ((JoinOperator) input1Operator).getReconcilingExpression().getExpression());
		assertNotNull(input1Operator.getLhsInput());
		assertNotNull(input1Operator.getRhsInput());
		assertEquals(input1Operator.getInput(), input1Operator.getLhsInput());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input1Operator).getPredicates().size());
		Predicate predicate = ((JoinOperator) input1Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate.getSuperLexical1().getName());
		assertEquals("citye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate.getOperator());
		assertEquals("codee", predicate.getSuperLexical2().getName());
		assertEquals("countrye", predicate.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate.getLiteral1());
		assertNull(predicate.getLiteral2());

		assertNotNull(input1Operator.getResultType());
		ResultType resultType1 = input1Operator.getResultType();
		assertEquals(12, resultType1.getResultFields().size());
		String[] expectedResultFieldNamesArray1 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee", "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione" };
		DataType[] expectedResultFieldTypesArray1 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray1 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray1 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray1 = new String[12];
		DataType[] actualResultFieldTypesArray1 = new DataType[12];
		String[] actualCanonicalModelConstructNamesArray1 = new String[12];
		String[] actualParentCanonicalModelConstructNamesArray1 = new String[12];

		i = 0;
		Map<String, ResultField> resultFields1 = resultType1.getResultFields();
		Set<String> resultFieldNames1 = resultFields1.keySet();
		for (String resultFieldName : resultFieldNames1) {
			actualResultFieldNamesArray1[i] = resultFieldName;
			actualResultFieldTypesArray1[i] = resultFields1.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray1[i] = resultFields1.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields1.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray1[i] = ((SuperLexical) resultFields1.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray1, actualResultFieldNamesArray1);
		assertArrayEquals(expectedResultFieldTypesArray1, actualResultFieldTypesArray1);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray1, actualCanonicalModelConstructNamesArray1);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray1, actualParentCanonicalModelConstructNamesArray1);

		MappingOperator input11Operator = input1Operator.getLhsInput();
		isInstanceOf(ScanOperator.class, input11Operator);
		assertEquals("citye", input11Operator.getVariableName());
		assertNull(input11Operator.getLhsInput());
		assertNull(input11Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input11Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input11Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input11Operator).getPredicates().size());

		assertNotNull(input11Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input11Operator.getDataSource());

		assertNotNull(input11Operator.getResultType());
		ResultType resultType2 = input11Operator.getResultType();
		assertEquals(6, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray2 = new String[6];
		DataType[] actualResultFieldTypesArray2 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray2 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);

		MappingOperator input12Operator = input1Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input12Operator);
		assertEquals("countrye", input12Operator.getVariableName());
		assertNull(input12Operator.getLhsInput());
		assertNull(input12Operator.getRhsInput());
		assertEquals("countrye", ((ScanOperator) input12Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input12Operator).getReconcilingExpression());
		assertEquals("countrye.codee = 'GB' or countrye.codee = 'D'", ((ScanOperator) input12Operator).getReconcilingExpression().getExpression());
		assertEquals("and", ((ScanOperator) input12Operator).getAndOr());

		assertNotNull(input12Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input12Operator.getDataSource());

		assertEquals(2, ((ScanOperator) input12Operator).getPredicates().size());

		Set<Predicate> predicates = ((ScanOperator) input12Operator).getPredicates();

		int k = 0;

		for (Predicate predicate1 : predicates) {
			if (k == 0) {
				//Predicate predicate1 = ((ScanOperator) input12Operator).getPredicates().get(0);
				assertEquals("codee", predicate1.getSuperLexical1().getName());
				assertEquals("countrye", predicate1.getSuperLexical1().getParentSuperAbstract().getName());
				assertEquals("=", predicate1.getOperator());
				assertEquals("'GB'", predicate1.getLiteral2());
				assertEquals("and", predicate1.getAndOr());
				assertNull(predicate1.getLiteral1());
				assertNull(predicate1.getSuperLexical2());
			} else if (k == 1) {
				//Predicate predicate2 = ((ScanOperator) input12Operator).getPredicates().get(1);
				assertEquals("codee", predicate1.getSuperLexical1().getName());
				assertEquals("countrye", predicate1.getSuperLexical1().getParentSuperAbstract().getName());
				assertEquals("=", predicate1.getOperator());
				assertEquals("'D'", predicate1.getLiteral2());
				assertEquals("or", predicate1.getAndOr());
				assertNull(predicate1.getLiteral1());
				assertNull(predicate1.getSuperLexical2());
			}
			k++;
		}

		assertNotNull(input12Operator.getResultType());
		ResultType resultType3 = input12Operator.getResultType();
		assertEquals(6, resultType3.getResultFields().size());
		String[] expectedResultFieldNamesArray3 = { "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione" };
		DataType[] expectedResultFieldTypesArray3 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT,
				DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray3 = { "namee", "codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray3 = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray3 = new String[6];
		DataType[] actualResultFieldTypesArray3 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray3 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray3 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields3 = resultType3.getResultFields();
		Set<String> resultFieldNames3 = resultFields3.keySet();
		for (String resultFieldName : resultFieldNames3) {
			actualResultFieldNamesArray3[i] = resultFieldName;
			actualResultFieldTypesArray3[i] = resultFields3.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray3[i] = resultFields3.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields3.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray3[i] = ((SuperLexical) resultFields3.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray3, actualResultFieldNamesArray3);
		assertArrayEquals(expectedResultFieldTypesArray3, actualResultFieldTypesArray3);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray3, actualCanonicalModelConstructNamesArray3);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray3, actualParentCanonicalModelConstructNamesArray3);
	}

	//---------------------------------------------------------------------

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectStarFromJoinQueryWithVariableNameOneSource() {
		String selectStarFromJoinQueryWithVariableName = "Select * from citye c, countrye o where c.countrye = o.codee";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectStarFromJoinQueryWithVariableName);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectStarFromJoinQueryWithVariableNameAst = parser.parseSQL(selectStarFromJoinQueryWithVariableName);
		logger.debug("selectStarFromJoinQueryWithVariableNameAst: " + selectStarFromJoinQueryWithVariableNameAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectStarFromJoinQueryWithVariableName, selectStarFromJoinQueryWithVariableNameAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(12, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals(
				"c.namee, c.countrye, c.provincee, c.populatione, c.longitudee, c.latitudee, o.namee, o.codee, o.capitale, o.provincee, o.areae, o.populatione",
				((ReduceOperator) rootOperator).getReconcilingExpression().getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[12];
		String[] superAbstractNamesArray = new String[12];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee", "codee",
				"capitale", "provincee", "areae", "populatione" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye", "countrye",
				"countrye", "countrye", "countrye" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[12];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee",
				"o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType0 = rootOperator.getResultType();
		assertEquals(12, resultType0.getResultFields().size());
		String[] expectedResultFieldNamesArray0 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee",
				"o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		DataType[] expectedResultFieldTypesArray0 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray0 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray0 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray0 = new String[12];
		DataType[] actualResultFieldTypesArray0 = new DataType[12];
		String[] actualCanonicalModelConstructNamesArray0 = new String[12];
		String[] actualParentCanonicalModelConstructNamesArray0 = new String[12];

		i = 0;
		Map<String, ResultField> resultFields0 = resultType0.getResultFields();
		Set<String> resultFieldNames0 = resultFields0.keySet();
		for (String resultFieldName : resultFieldNames0) {
			actualResultFieldNamesArray0[i] = resultFieldName;
			actualResultFieldTypesArray0[i] = resultFields0.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultFields0.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields0.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultFields0.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray0, actualResultFieldNamesArray0);
		assertArrayEquals(expectedResultFieldTypesArray0, actualResultFieldTypesArray0);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray0, actualCanonicalModelConstructNamesArray0);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray0, actualParentCanonicalModelConstructNamesArray0);

		MappingOperator input0Operator = rootOperator.getLhsInput();

		isInstanceOf(JoinOperator.class, input0Operator);
		assertNull(input0Operator.getVariableName());
		assertNotNull(((JoinOperator) input0Operator).getReconcilingExpression());
		assertEquals("c.countrye = o.codee", ((JoinOperator) input0Operator).getReconcilingExpression().getExpression());
		assertNotNull(input0Operator.getLhsInput());
		assertNotNull(input0Operator.getRhsInput());
		assertEquals(input0Operator.getInput(), input0Operator.getLhsInput());

		assertNotNull(input0Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input0Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input0Operator).getPredicates().size());
		Predicate predicate = ((JoinOperator) input0Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate.getSuperLexical1().getName());
		assertEquals("citye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate.getOperator());
		assertEquals("codee", predicate.getSuperLexical2().getName());
		assertEquals("countrye", predicate.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate.getLiteral1());
		assertNull(predicate.getLiteral2());

		assertNotNull(input0Operator.getResultType());
		ResultType resultType = input0Operator.getResultType();
		assertEquals(12, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee", "o.namee",
				"o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray = new String[12];
		DataType[] actualResultFieldTypesArray = new DataType[12];
		String[] actualCanonicalModelConstructNamesArray = new String[12];
		String[] actualParentCanonicalModelConstructNamesArray = new String[12];

		i = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[i] = resultFieldName;
			actualResultFieldTypesArray[i] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input1Operator = input0Operator.getLhsInput();
		isInstanceOf(ScanOperator.class, input1Operator);
		assertEquals("c", input1Operator.getVariableName());
		assertNull(input1Operator.getLhsInput());
		assertNull(input1Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input1Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input1Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input1Operator).getPredicates().size());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertNotNull(input1Operator.getResultType());
		ResultType resultType2 = input1Operator.getResultType();
		assertEquals(6, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray2 = new String[6];
		DataType[] actualResultFieldTypesArray2 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray2 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);

		MappingOperator input2Operator = input0Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input2Operator);
		assertEquals("o", input2Operator.getVariableName());
		assertNull(input2Operator.getLhsInput());
		assertNull(input2Operator.getRhsInput());
		assertEquals("countrye", ((ScanOperator) input2Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input2Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input2Operator).getPredicates().size());

		assertNotNull(input2Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input2Operator.getDataSource());

		assertNotNull(input2Operator.getResultType());
		ResultType resultType3 = input2Operator.getResultType();
		assertEquals(6, resultType3.getResultFields().size());
		String[] expectedResultFieldNamesArray3 = { "o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		DataType[] expectedResultFieldTypesArray3 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT,
				DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray3 = { "namee", "codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray3 = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray3 = new String[6];
		DataType[] actualResultFieldTypesArray3 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray3 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray3 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields3 = resultType3.getResultFields();
		Set<String> resultFieldNames3 = resultFields3.keySet();
		for (String resultFieldName : resultFieldNames3) {
			actualResultFieldNamesArray3[i] = resultFieldName;
			actualResultFieldTypesArray3[i] = resultFields3.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray3[i] = resultFields3.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields3.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray3[i] = ((SuperLexical) resultFields3.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray3, actualResultFieldNamesArray3);
		assertArrayEquals(expectedResultFieldTypesArray3, actualResultFieldTypesArray3);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray3, actualCanonicalModelConstructNamesArray3);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray3, actualParentCanonicalModelConstructNamesArray3);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectStarFromJoinWhereQueryWithVariableNameOneSource() {
		String selectStarFromJoinWhereQueryWithVariableName = "Select * from citye c, countrye o where c.countrye = o.codee and o.codee = 'GB'";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectStarFromJoinWhereQueryWithVariableName);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectStarFromJoinWhereQueryWithVariableNameAst = parser.parseSQL(selectStarFromJoinWhereQueryWithVariableName);
		logger.debug("selectStarFromJoinWhereQueryWithVariableNameAst: " + selectStarFromJoinWhereQueryWithVariableNameAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectStarFromJoinWhereQueryWithVariableName,
				selectStarFromJoinWhereQueryWithVariableNameAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(12, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals(
				"c.namee, c.countrye, c.provincee, c.populatione, c.longitudee, c.latitudee, o.namee, o.codee, o.capitale, o.provincee, o.areae, o.populatione",
				((ReduceOperator) rootOperator).getReconcilingExpression().getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[12];
		String[] superAbstractNamesArray = new String[12];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee", "codee",
				"capitale", "provincee", "areae", "populatione" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye", "countrye",
				"countrye", "countrye", "countrye" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[12];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee",
				"o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType0 = rootOperator.getResultType();
		assertEquals(12, resultType0.getResultFields().size());
		String[] expectedResultFieldNamesArray0 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee",
				"o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		DataType[] expectedResultFieldTypesArray0 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray0 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray0 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray0 = new String[12];
		DataType[] actualResultFieldTypesArray0 = new DataType[12];
		String[] actualCanonicalModelConstructNamesArray0 = new String[12];
		String[] actualParentCanonicalModelConstructNamesArray0 = new String[12];

		i = 0;
		Map<String, ResultField> resultFields0 = resultType0.getResultFields();
		Set<String> resultFieldNames0 = resultFields0.keySet();
		for (String resultFieldName : resultFieldNames0) {
			actualResultFieldNamesArray0[i] = resultFieldName;
			actualResultFieldTypesArray0[i] = resultFields0.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultFields0.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields0.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultFields0.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray0, actualResultFieldNamesArray0);
		assertArrayEquals(expectedResultFieldTypesArray0, actualResultFieldTypesArray0);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray0, actualCanonicalModelConstructNamesArray0);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray0, actualParentCanonicalModelConstructNamesArray0);

		MappingOperator input0Operator = rootOperator.getLhsInput();

		isInstanceOf(JoinOperator.class, input0Operator);
		assertNull(input0Operator.getVariableName());
		assertNotNull(((JoinOperator) input0Operator).getReconcilingExpression());
		assertEquals("c.countrye = o.codee", ((JoinOperator) input0Operator).getReconcilingExpression().getExpression());
		assertNotNull(input0Operator.getLhsInput());
		assertNotNull(input0Operator.getRhsInput());
		assertEquals(input0Operator.getInput(), input0Operator.getLhsInput());

		assertNotNull(input0Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input0Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input0Operator).getPredicates().size());
		Predicate predicate = ((JoinOperator) input0Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate.getSuperLexical1().getName());
		assertEquals("citye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate.getOperator());
		assertEquals("codee", predicate.getSuperLexical2().getName());
		assertEquals("countrye", predicate.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate.getLiteral1());
		assertNull(predicate.getLiteral2());

		assertNotNull(input0Operator.getResultType());
		ResultType resultType = input0Operator.getResultType();
		assertEquals(12, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee", "o.namee",
				"o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray = new String[12];
		DataType[] actualResultFieldTypesArray = new DataType[12];
		String[] actualCanonicalModelConstructNamesArray = new String[12];
		String[] actualParentCanonicalModelConstructNamesArray = new String[12];

		i = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[i] = resultFieldName;
			actualResultFieldTypesArray[i] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input1Operator = input0Operator.getLhsInput();
		isInstanceOf(ScanOperator.class, input1Operator);
		assertEquals("c", input1Operator.getVariableName());
		assertNull(input1Operator.getLhsInput());
		assertNull(input1Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input1Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input1Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input1Operator).getPredicates().size());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertNotNull(input1Operator.getResultType());
		ResultType resultType2 = input1Operator.getResultType();
		assertEquals(6, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray2 = new String[6];
		DataType[] actualResultFieldTypesArray2 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray2 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);

		MappingOperator input2Operator = input0Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input2Operator);
		assertEquals("o", input2Operator.getVariableName());
		assertNull(input2Operator.getLhsInput());
		assertNull(input2Operator.getRhsInput());
		assertEquals("countrye", ((ScanOperator) input2Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input2Operator).getReconcilingExpression());
		assertEquals("o.codee = 'GB'", ((ScanOperator) input2Operator).getReconcilingExpression().getExpression());
		assertEquals("and", ((ScanOperator) input2Operator).getAndOr());

		assertNotNull(input2Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input2Operator.getDataSource());

		assertEquals(1, ((ScanOperator) input2Operator).getPredicates().size());
		Predicate predicate1 = ((ScanOperator) input2Operator).getPredicates().iterator().next();
		assertEquals("codee", predicate1.getSuperLexical1().getName());
		assertEquals("countrye", predicate1.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate1.getOperator());
		assertEquals("'GB'", predicate1.getLiteral2());
		assertEquals("and", predicate1.getAndOr());
		assertNull(predicate1.getLiteral1());
		assertNull(predicate1.getSuperLexical2());

		assertNotNull(input2Operator.getResultType());
		ResultType resultType3 = input2Operator.getResultType();
		assertEquals(6, resultType3.getResultFields().size());
		String[] expectedResultFieldNamesArray3 = { "o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		DataType[] expectedResultFieldTypesArray3 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT,
				DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray3 = { "namee", "codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray3 = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray3 = new String[6];
		DataType[] actualResultFieldTypesArray3 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray3 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray3 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields3 = resultType3.getResultFields();
		Set<String> resultFieldNames3 = resultFields3.keySet();
		for (String resultFieldName : resultFieldNames3) {
			actualResultFieldNamesArray3[i] = resultFieldName;
			actualResultFieldTypesArray3[i] = resultFields3.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray3[i] = resultFields3.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields3.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray3[i] = ((SuperLexical) resultFields3.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray3, actualResultFieldNamesArray3);
		assertArrayEquals(expectedResultFieldTypesArray3, actualResultFieldTypesArray3);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray3, actualCanonicalModelConstructNamesArray3);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray3, actualParentCanonicalModelConstructNamesArray3);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectStarFromJoinWhereAndQueryWithVariableNameOneSource() {
		String selectStarFromJoinWhereAndQueryWithVariableName = "Select * from citye c, countrye o where c.countrye = o.codee and o.codee = 'GB' and c.namee = 'Manchester'";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectStarFromJoinWhereAndQueryWithVariableName);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectStarFromJoinWhereAndQueryWithVariableNameAst = parser.parseSQL(selectStarFromJoinWhereAndQueryWithVariableName);
		logger.debug("selectStarFromJoinWhereAndQueryWithVariableNameAst: " + selectStarFromJoinWhereAndQueryWithVariableNameAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectStarFromJoinWhereAndQueryWithVariableName,
				selectStarFromJoinWhereAndQueryWithVariableNameAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(12, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals(
				"c.namee, c.countrye, c.provincee, c.populatione, c.longitudee, c.latitudee, o.namee, o.codee, o.capitale, o.provincee, o.areae, o.populatione",
				((ReduceOperator) rootOperator).getReconcilingExpression().getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[12];
		String[] superAbstractNamesArray = new String[12];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee", "codee",
				"capitale", "provincee", "areae", "populatione" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye", "countrye",
				"countrye", "countrye", "countrye" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[12];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee",
				"o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType0 = rootOperator.getResultType();
		assertEquals(12, resultType0.getResultFields().size());
		String[] expectedResultFieldNamesArray0 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee",
				"o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		DataType[] expectedResultFieldTypesArray0 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray0 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray0 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray0 = new String[12];
		DataType[] actualResultFieldTypesArray0 = new DataType[12];
		String[] actualCanonicalModelConstructNamesArray0 = new String[12];
		String[] actualParentCanonicalModelConstructNamesArray0 = new String[12];

		i = 0;
		Map<String, ResultField> resultFields0 = resultType0.getResultFields();
		Set<String> resultFieldNames0 = resultFields0.keySet();
		for (String resultFieldName : resultFieldNames0) {
			actualResultFieldNamesArray0[i] = resultFieldName;
			actualResultFieldTypesArray0[i] = resultFields0.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultFields0.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields0.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultFields0.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray0, actualResultFieldNamesArray0);
		assertArrayEquals(expectedResultFieldTypesArray0, actualResultFieldTypesArray0);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray0, actualCanonicalModelConstructNamesArray0);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray0, actualParentCanonicalModelConstructNamesArray0);

		MappingOperator input0Operator = rootOperator.getLhsInput();

		isInstanceOf(JoinOperator.class, input0Operator);
		assertNull(input0Operator.getVariableName());
		assertNotNull(((JoinOperator) input0Operator).getReconcilingExpression());
		assertEquals("c.countrye = o.codee", ((JoinOperator) input0Operator).getReconcilingExpression().getExpression());
		assertNotNull(input0Operator.getLhsInput());
		assertNotNull(input0Operator.getRhsInput());
		assertEquals(input0Operator.getInput(), input0Operator.getLhsInput());

		assertNotNull(input0Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input0Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input0Operator).getPredicates().size());
		Predicate predicate = ((JoinOperator) input0Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate.getSuperLexical1().getName());
		assertEquals("citye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate.getOperator());
		assertEquals("codee", predicate.getSuperLexical2().getName());
		assertEquals("countrye", predicate.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate.getLiteral1());
		assertNull(predicate.getLiteral2());

		assertNotNull(input0Operator.getResultType());
		ResultType resultType = input0Operator.getResultType();
		assertEquals(12, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee", "o.namee",
				"o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray = new String[12];
		DataType[] actualResultFieldTypesArray = new DataType[12];
		String[] actualCanonicalModelConstructNamesArray = new String[12];
		String[] actualParentCanonicalModelConstructNamesArray = new String[12];

		i = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[i] = resultFieldName;
			actualResultFieldTypesArray[i] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input1Operator = input0Operator.getLhsInput();
		isInstanceOf(ScanOperator.class, input1Operator);
		assertEquals("c", input1Operator.getVariableName());
		assertNull(input1Operator.getLhsInput());
		assertNull(input1Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input1Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input1Operator).getReconcilingExpression());
		assertEquals("c.namee = 'Manchester'", ((ScanOperator) input1Operator).getReconcilingExpression().getExpression());
		assertEquals("and", ((ScanOperator) input1Operator).getAndOr());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertEquals(1, ((ScanOperator) input1Operator).getPredicates().size());
		Predicate predicate1 = ((ScanOperator) input1Operator).getPredicates().iterator().next();
		assertEquals("namee", predicate1.getSuperLexical1().getName());
		assertEquals("citye", predicate1.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate1.getOperator());
		assertEquals("'Manchester'", predicate1.getLiteral2());
		assertEquals("and", predicate1.getAndOr());
		assertNull(predicate1.getLiteral1());
		assertNull(predicate1.getSuperLexical2());

		assertNotNull(input1Operator.getResultType());
		ResultType resultType2 = input1Operator.getResultType();
		assertEquals(6, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray2 = new String[6];
		DataType[] actualResultFieldTypesArray2 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray2 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);

		MappingOperator input2Operator = input0Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input2Operator);
		assertEquals("o", input2Operator.getVariableName());
		assertNull(input2Operator.getLhsInput());
		assertNull(input2Operator.getRhsInput());
		assertEquals("countrye", ((ScanOperator) input2Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input2Operator).getReconcilingExpression());
		assertEquals("o.codee = 'GB'", ((ScanOperator) input2Operator).getReconcilingExpression().getExpression());
		assertEquals("and", ((ScanOperator) input2Operator).getAndOr());

		assertNotNull(input2Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input2Operator.getDataSource());

		assertEquals(1, ((ScanOperator) input2Operator).getPredicates().size());
		Predicate predicate2 = ((ScanOperator) input2Operator).getPredicates().iterator().next();
		assertEquals("codee", predicate2.getSuperLexical1().getName());
		assertEquals("countrye", predicate2.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate2.getOperator());
		assertEquals("'GB'", predicate2.getLiteral2());
		assertEquals("and", predicate2.getAndOr());
		assertNull(predicate2.getLiteral1());
		assertNull(predicate2.getSuperLexical2());

		assertNotNull(input2Operator.getResultType());
		ResultType resultType3 = input2Operator.getResultType();
		assertEquals(6, resultType3.getResultFields().size());
		String[] expectedResultFieldNamesArray3 = { "o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		DataType[] expectedResultFieldTypesArray3 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT,
				DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray3 = { "namee", "codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray3 = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray3 = new String[6];
		DataType[] actualResultFieldTypesArray3 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray3 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray3 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields3 = resultType3.getResultFields();
		Set<String> resultFieldNames3 = resultFields3.keySet();
		for (String resultFieldName : resultFieldNames3) {
			actualResultFieldNamesArray3[i] = resultFieldName;
			actualResultFieldTypesArray3[i] = resultFields3.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray3[i] = resultFields3.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields3.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray3[i] = ((SuperLexical) resultFields3.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray3, actualResultFieldNamesArray3);
		assertArrayEquals(expectedResultFieldTypesArray3, actualResultFieldTypesArray3);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray3, actualCanonicalModelConstructNamesArray3);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray3, actualParentCanonicalModelConstructNamesArray3);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	//@Test
	public void testTranslateAstIntoQuerySelectStarFromJoinWhereOrQueryWithVariableNameOneSource() {
		String selectStarFromJoinWhereOrQueryWithVariableName = "Select * from citye c, countrye o where c.countrye = o.codee and (o.codee = 'GB' or o.codee = 'D')";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectStarFromJoinWhereOrQueryWithVariableName);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectStarFromJoinWhereOrQueryWithVariableNameAst = parser.parseSQL(selectStarFromJoinWhereOrQueryWithVariableName);
		logger.debug("selectStarFromJoinWhereOrQueryWithVariableNameAst: " + selectStarFromJoinWhereOrQueryWithVariableNameAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectStarFromJoinWhereOrQueryWithVariableName,
				selectStarFromJoinWhereOrQueryWithVariableNameAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(12, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals(
				"c.namee, c.countrye, c.provincee, c.populatione, c.longitudee, c.latitudee, o.namee, o.codee, o.capitale, o.provincee, o.areae, o.populatione",
				((ReduceOperator) rootOperator).getReconcilingExpression().getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[12];
		String[] superAbstractNamesArray = new String[12];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee", "codee",
				"capitale", "provincee", "areae", "populatione" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye", "countrye",
				"countrye", "countrye", "countrye" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[12];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee",
				"o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType0 = rootOperator.getResultType();
		assertEquals(12, resultType0.getResultFields().size());
		String[] expectedResultFieldNamesArray0 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee",
				"o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		DataType[] expectedResultFieldTypesArray0 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray0 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray0 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray0 = new String[12];
		DataType[] actualResultFieldTypesArray0 = new DataType[12];
		String[] actualCanonicalModelConstructNamesArray0 = new String[12];
		String[] actualParentCanonicalModelConstructNamesArray0 = new String[12];

		i = 0;
		Map<String, ResultField> resultFields0 = resultType0.getResultFields();
		Set<String> resultFieldNames0 = resultFields0.keySet();
		for (String resultFieldName : resultFieldNames0) {
			actualResultFieldNamesArray0[i] = resultFieldName;
			actualResultFieldTypesArray0[i] = resultFields0.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultFields0.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields0.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultFields0.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray0, actualResultFieldNamesArray0);
		assertArrayEquals(expectedResultFieldTypesArray0, actualResultFieldTypesArray0);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray0, actualCanonicalModelConstructNamesArray0);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray0, actualParentCanonicalModelConstructNamesArray0);

		MappingOperator input0Operator = rootOperator.getLhsInput();

		isInstanceOf(JoinOperator.class, input0Operator);
		assertNull(input0Operator.getVariableName());
		assertNotNull(((JoinOperator) input0Operator).getReconcilingExpression());
		assertEquals("c.countrye = o.codee", ((JoinOperator) input0Operator).getReconcilingExpression().getExpression());
		assertNotNull(input0Operator.getLhsInput());
		assertNotNull(input0Operator.getRhsInput());
		assertEquals(input0Operator.getInput(), input0Operator.getLhsInput());

		assertNotNull(input0Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input0Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input0Operator).getPredicates().size());
		Predicate predicate = ((JoinOperator) input0Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate.getSuperLexical1().getName());
		assertEquals("citye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate.getOperator());
		assertEquals("codee", predicate.getSuperLexical2().getName());
		assertEquals("countrye", predicate.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate.getLiteral1());
		assertNull(predicate.getLiteral2());

		assertNotNull(input0Operator.getResultType());
		ResultType resultType = input0Operator.getResultType();
		assertEquals(12, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee", "o.namee",
				"o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray = new String[12];
		DataType[] actualResultFieldTypesArray = new DataType[12];
		String[] actualCanonicalModelConstructNamesArray = new String[12];
		String[] actualParentCanonicalModelConstructNamesArray = new String[12];

		i = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[i] = resultFieldName;
			actualResultFieldTypesArray[i] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input1Operator = input0Operator.getLhsInput();
		isInstanceOf(ScanOperator.class, input1Operator);
		assertEquals("c", input1Operator.getVariableName());
		assertNull(input1Operator.getLhsInput());
		assertNull(input1Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input1Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input1Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input1Operator).getPredicates().size());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertNotNull(input1Operator.getResultType());
		ResultType resultType2 = input1Operator.getResultType();
		assertEquals(6, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray2 = new String[6];
		DataType[] actualResultFieldTypesArray2 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray2 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);

		MappingOperator input2Operator = input0Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input2Operator);
		assertEquals("o", input2Operator.getVariableName());
		assertNull(input2Operator.getLhsInput());
		assertNull(input2Operator.getRhsInput());
		assertEquals("countrye", ((ScanOperator) input2Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input2Operator).getReconcilingExpression());
		assertEquals("o.codee = 'GB' or o.codee = 'D'", ((ScanOperator) input2Operator).getReconcilingExpression().getExpression());
		assertEquals("and", ((ScanOperator) input2Operator).getAndOr());

		assertNotNull(input2Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input2Operator.getDataSource());

		assertEquals(2, ((ScanOperator) input2Operator).getPredicates().size());

		Set<Predicate> predicates = ((ScanOperator) input2Operator).getPredicates();

		int k = 0;

		for (Predicate predicate1 : predicates) {
			if (k == 0) {
				//Predicate predicate1 = ((ScanOperator) input2Operator).getPredicates().get(0);
				assertEquals("codee", predicate.getSuperLexical1().getName());
				assertEquals("countrye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
				assertEquals("=", predicate.getOperator());
				assertEquals("'GB'", predicate.getLiteral2());
				assertEquals("and", predicate.getAndOr());
				assertNull(predicate.getLiteral1());
				assertNull(predicate.getSuperLexical2());
			} else if (k == 1) {
				//Predicate predicate2 = ((ScanOperator) input2Operator).getPredicates().get(1);
				assertEquals("codee", predicate.getSuperLexical1().getName());
				assertEquals("countrye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
				assertEquals("=", predicate.getOperator());
				assertEquals("'D'", predicate.getLiteral2());
				assertEquals("or", predicate.getAndOr());
				assertNull(predicate.getLiteral1());
				assertNull(predicate.getSuperLexical2());
			}
			k++;
		}

		assertNotNull(input2Operator.getResultType());
		ResultType resultType3 = input2Operator.getResultType();
		assertEquals(6, resultType3.getResultFields().size());
		String[] expectedResultFieldNamesArray3 = { "o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		DataType[] expectedResultFieldTypesArray3 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT,
				DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray3 = { "namee", "codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray3 = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray3 = new String[6];
		DataType[] actualResultFieldTypesArray3 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray3 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray3 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields3 = resultType3.getResultFields();
		Set<String> resultFieldNames3 = resultFields3.keySet();
		for (String resultFieldName : resultFieldNames3) {
			actualResultFieldNamesArray3[i] = resultFieldName;
			actualResultFieldTypesArray3[i] = resultFields3.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray3[i] = resultFields3.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields3.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray3[i] = ((SuperLexical) resultFields3.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray3, actualResultFieldNamesArray3);
		assertArrayEquals(expectedResultFieldTypesArray3, actualResultFieldTypesArray3);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray3, actualCanonicalModelConstructNamesArray3);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray3, actualParentCanonicalModelConstructNamesArray3);
	}

	//---------------------------------------------------------------------

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectSuperLexicalsFromJoinQueryWithVariableNameOneSource() {
		String selectSuperLexicalsFromJoinQueryWithVariableName = "Select c.namee, c.countrye, c.provincee, o.namee, o.capitale from citye c, countrye o where c.countrye = o.codee";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectSuperLexicalsFromJoinQueryWithVariableName);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectSuperLexicalsFromJoinQueryWithVariableNameAst = parser.parseSQL(selectSuperLexicalsFromJoinQueryWithVariableName);
		logger.debug("selectSuperLexicalsFromJoinQueryWithVariableNameAst: " + selectSuperLexicalsFromJoinQueryWithVariableNameAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectSuperLexicalsFromJoinQueryWithVariableName,
				selectSuperLexicalsFromJoinQueryWithVariableNameAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(5, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals("c.namee, c.countrye, c.provincee, o.namee, o.capitale", ((ReduceOperator) rootOperator).getReconcilingExpression()
				.getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[5];
		String[] superAbstractNamesArray = new String[5];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "namee", "capitale" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "countrye", "countrye" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[5];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "c.namee", "c.countrye", "c.provincee", "o.namee", "o.capitale" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType = rootOperator.getResultType();
		assertEquals(5, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "c.namee", "c.countrye", "c.provincee", "o.namee", "o.capitale" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "namee", "capitale" };
		String[] expectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray = new String[5];
		DataType[] actualResultFieldTypesArray = new DataType[5];
		String[] actualCanonicalModelConstructNamesArray = new String[5];
		String[] actualParentCanonicalModelConstructNamesArray = new String[5];

		int j = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[j] = resultFieldName;
			actualResultFieldTypesArray[j] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[j] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[j] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			j++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(expectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input1Operator = rootOperator.getLhsInput();

		isInstanceOf(JoinOperator.class, input1Operator);
		assertNull(input1Operator.getVariableName());
		assertNotNull(((JoinOperator) input1Operator).getReconcilingExpression());
		assertEquals("c.countrye = o.codee", ((JoinOperator) input1Operator).getReconcilingExpression().getExpression());
		assertNotNull(input1Operator.getLhsInput());
		assertNotNull(input1Operator.getRhsInput());
		assertEquals(input1Operator.getInput(), input1Operator.getLhsInput());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input1Operator).getPredicates().size());
		Predicate predicate = ((JoinOperator) input1Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate.getSuperLexical1().getName());
		assertEquals("citye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate.getOperator());
		assertEquals("codee", predicate.getSuperLexical2().getName());
		assertEquals("countrye", predicate.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate.getLiteral1());
		assertNull(predicate.getLiteral2());

		assertNotNull(input1Operator.getResultType());
		ResultType resultType1 = input1Operator.getResultType();
		assertEquals(12, resultType1.getResultFields().size());
		String[] expectedResultFieldNamesArray1 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee",
				"o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		DataType[] expectedResultFieldTypesArray1 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray1 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray1 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray1 = new String[12];
		DataType[] actualResultFieldTypesArray1 = new DataType[12];
		String[] actualCanonicalModelConstructNamesArray1 = new String[12];
		String[] actualParentCanonicalModelConstructNamesArray1 = new String[12];

		i = 0;
		Map<String, ResultField> resultFields1 = resultType1.getResultFields();
		Set<String> resultFieldNames1 = resultFields1.keySet();
		for (String resultFieldName : resultFieldNames1) {
			actualResultFieldNamesArray1[i] = resultFieldName;
			actualResultFieldTypesArray1[i] = resultFields1.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray1[i] = resultFields1.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields1.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray1[i] = ((SuperLexical) resultFields1.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray1, actualResultFieldNamesArray1);
		assertArrayEquals(expectedResultFieldTypesArray1, actualResultFieldTypesArray1);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray1, actualCanonicalModelConstructNamesArray1);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray1, actualParentCanonicalModelConstructNamesArray1);

		MappingOperator input11Operator = input1Operator.getLhsInput();
		isInstanceOf(ScanOperator.class, input11Operator);
		assertEquals("c", input11Operator.getVariableName());
		assertNull(input11Operator.getLhsInput());
		assertNull(input11Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input11Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input11Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input11Operator).getPredicates().size());

		assertNotNull(input11Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input11Operator.getDataSource());

		assertNotNull(input11Operator.getResultType());
		ResultType resultType2 = input11Operator.getResultType();
		assertEquals(6, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray2 = new String[6];
		DataType[] actualResultFieldTypesArray2 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray2 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);

		MappingOperator input12Operator = input1Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input12Operator);
		assertEquals("o", input12Operator.getVariableName());
		assertNull(input12Operator.getLhsInput());
		assertNull(input12Operator.getRhsInput());
		assertEquals("countrye", ((ScanOperator) input12Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input12Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input12Operator).getPredicates().size());

		assertNotNull(input12Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input12Operator.getDataSource());

		assertNotNull(input12Operator.getResultType());
		ResultType resultType3 = input12Operator.getResultType();
		assertEquals(6, resultType3.getResultFields().size());
		String[] expectedResultFieldNamesArray3 = { "o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		DataType[] expectedResultFieldTypesArray3 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT,
				DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray3 = { "namee", "codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray3 = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray3 = new String[6];
		DataType[] actualResultFieldTypesArray3 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray3 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray3 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields3 = resultType3.getResultFields();
		Set<String> resultFieldNames3 = resultFields3.keySet();
		for (String resultFieldName : resultFieldNames3) {
			actualResultFieldNamesArray3[i] = resultFieldName;
			actualResultFieldTypesArray3[i] = resultFields3.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray3[i] = resultFields3.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields3.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray3[i] = ((SuperLexical) resultFields3.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray3, actualResultFieldNamesArray3);
		assertArrayEquals(expectedResultFieldTypesArray3, actualResultFieldTypesArray3);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray3, actualCanonicalModelConstructNamesArray3);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray3, actualParentCanonicalModelConstructNamesArray3);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectSuperLexicalsFromJoinWhereQueryWithVariableNameOneSource() {
		String selectSuperLexicalsFromJoinWhereQueryWithVariableName = "Select c.namee, c.countrye, c.provincee, o.namee, o.capitale from citye c, countrye o where c.countrye = o.codee and o.codee = 'GB'";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectSuperLexicalsFromJoinWhereQueryWithVariableName);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectSuperLexicalsFromJoinWhereQueryWithVariableNameAst = parser.parseSQL(selectSuperLexicalsFromJoinWhereQueryWithVariableName);
		logger.debug("selectSuperLexicalsFromJoinWhereQueryWithVariableNameAst: "
				+ selectSuperLexicalsFromJoinWhereQueryWithVariableNameAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectSuperLexicalsFromJoinWhereQueryWithVariableName,
				selectSuperLexicalsFromJoinWhereQueryWithVariableNameAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(5, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals("c.namee, c.countrye, c.provincee, o.namee, o.capitale", ((ReduceOperator) rootOperator).getReconcilingExpression()
				.getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[5];
		String[] superAbstractNamesArray = new String[5];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "namee", "capitale" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "countrye", "countrye" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[5];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "c.namee", "c.countrye", "c.provincee", "o.namee", "o.capitale" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType = rootOperator.getResultType();
		assertEquals(5, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "c.namee", "c.countrye", "c.provincee", "o.namee", "o.capitale" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "namee", "capitale" };
		String[] expectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray = new String[5];
		DataType[] actualResultFieldTypesArray = new DataType[5];
		String[] actualCanonicalModelConstructNamesArray = new String[5];
		String[] actualParentCanonicalModelConstructNamesArray = new String[5];

		int j = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[j] = resultFieldName;
			actualResultFieldTypesArray[j] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[j] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[j] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			j++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(expectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input1Operator = rootOperator.getLhsInput();

		isInstanceOf(JoinOperator.class, input1Operator);
		assertNull(input1Operator.getVariableName());
		assertNotNull(((JoinOperator) input1Operator).getReconcilingExpression());
		assertEquals("c.countrye = o.codee", ((JoinOperator) input1Operator).getReconcilingExpression().getExpression());
		assertNotNull(input1Operator.getLhsInput());
		assertNotNull(input1Operator.getRhsInput());
		assertEquals(input1Operator.getInput(), input1Operator.getLhsInput());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input1Operator).getPredicates().size());
		Predicate predicate = ((JoinOperator) input1Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate.getSuperLexical1().getName());
		assertEquals("citye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate.getOperator());
		assertEquals("codee", predicate.getSuperLexical2().getName());
		assertEquals("countrye", predicate.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate.getLiteral1());
		assertNull(predicate.getLiteral2());

		assertNotNull(input1Operator.getResultType());
		ResultType resultType1 = input1Operator.getResultType();
		assertEquals(12, resultType1.getResultFields().size());
		String[] expectedResultFieldNamesArray1 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee",
				"o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		DataType[] expectedResultFieldTypesArray1 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray1 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray1 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray1 = new String[12];
		DataType[] actualResultFieldTypesArray1 = new DataType[12];
		String[] actualCanonicalModelConstructNamesArray1 = new String[12];
		String[] actualParentCanonicalModelConstructNamesArray1 = new String[12];

		i = 0;
		Map<String, ResultField> resultFields1 = resultType1.getResultFields();
		Set<String> resultFieldNames1 = resultFields1.keySet();
		for (String resultFieldName : resultFieldNames1) {
			actualResultFieldNamesArray1[i] = resultFieldName;
			actualResultFieldTypesArray1[i] = resultFields1.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray1[i] = resultFields1.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields1.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray1[i] = ((SuperLexical) resultFields1.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray1, actualResultFieldNamesArray1);
		assertArrayEquals(expectedResultFieldTypesArray1, actualResultFieldTypesArray1);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray1, actualCanonicalModelConstructNamesArray1);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray1, actualParentCanonicalModelConstructNamesArray1);

		MappingOperator input11Operator = input1Operator.getLhsInput();
		isInstanceOf(ScanOperator.class, input11Operator);
		assertEquals("c", input11Operator.getVariableName());
		assertNull(input11Operator.getLhsInput());
		assertNull(input11Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input11Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input11Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input11Operator).getPredicates().size());

		assertNotNull(input11Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input11Operator.getDataSource());

		assertNotNull(input11Operator.getResultType());
		ResultType resultType2 = input11Operator.getResultType();
		assertEquals(6, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray2 = new String[6];
		DataType[] actualResultFieldTypesArray2 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray2 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);

		MappingOperator input12Operator = input1Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input12Operator);
		assertEquals("o", input12Operator.getVariableName());
		assertNull(input12Operator.getLhsInput());
		assertNull(input12Operator.getRhsInput());
		assertEquals("countrye", ((ScanOperator) input12Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input12Operator).getReconcilingExpression());
		assertEquals("o.codee = 'GB'", ((ScanOperator) input12Operator).getReconcilingExpression().getExpression());
		assertEquals("and", ((ScanOperator) input12Operator).getAndOr());

		assertNotNull(input12Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input12Operator.getDataSource());

		assertEquals(1, ((ScanOperator) input12Operator).getPredicates().size());
		Predicate predicate1 = ((ScanOperator) input12Operator).getPredicates().iterator().next();
		assertEquals("codee", predicate1.getSuperLexical1().getName());
		assertEquals("countrye", predicate1.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate1.getOperator());
		assertEquals("'GB'", predicate1.getLiteral2());
		assertEquals("and", predicate1.getAndOr());
		assertNull(predicate1.getLiteral1());
		assertNull(predicate1.getSuperLexical2());

		assertNotNull(input12Operator.getResultType());
		ResultType resultType3 = input12Operator.getResultType();
		assertEquals(6, resultType3.getResultFields().size());
		String[] expectedResultFieldNamesArray3 = { "o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		DataType[] expectedResultFieldTypesArray3 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT,
				DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray3 = { "namee", "codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray3 = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray3 = new String[6];
		DataType[] actualResultFieldTypesArray3 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray3 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray3 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields3 = resultType3.getResultFields();
		Set<String> resultFieldNames3 = resultFields3.keySet();
		for (String resultFieldName : resultFieldNames3) {
			actualResultFieldNamesArray3[i] = resultFieldName;
			actualResultFieldTypesArray3[i] = resultFields3.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray3[i] = resultFields3.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields3.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray3[i] = ((SuperLexical) resultFields3.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray3, actualResultFieldNamesArray3);
		assertArrayEquals(expectedResultFieldTypesArray3, actualResultFieldTypesArray3);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray3, actualCanonicalModelConstructNamesArray3);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray3, actualParentCanonicalModelConstructNamesArray3);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectSuperLexicalsFromJoinWhereAndQueryWithVariableNameOneSource() {
		String selectSuperLexicalsFromJoinWhereAndQueryWithVariableName = "Select c.namee, c.countrye, c.provincee, o.namee, o.capitale from citye c, countrye o where c.countrye = o.codee and o.codee = 'GB' and c.namee = 'Manchester'";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectSuperLexicalsFromJoinWhereAndQueryWithVariableName);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectSuperLexicalsFromJoinWhereAndQueryWithVariableNameAst = parser
				.parseSQL(selectSuperLexicalsFromJoinWhereAndQueryWithVariableName);
		logger.debug("selectSuperLexicalsFromJoinWhereAndQueryWithVariableNameAst: "
				+ selectSuperLexicalsFromJoinWhereAndQueryWithVariableNameAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectSuperLexicalsFromJoinWhereAndQueryWithVariableName,
				selectSuperLexicalsFromJoinWhereAndQueryWithVariableNameAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(5, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals("c.namee, c.countrye, c.provincee, o.namee, o.capitale", ((ReduceOperator) rootOperator).getReconcilingExpression()
				.getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[5];
		String[] superAbstractNamesArray = new String[5];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "namee", "capitale" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "countrye", "countrye" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[5];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "c.namee", "c.countrye", "c.provincee", "o.namee", "o.capitale" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType = rootOperator.getResultType();
		assertEquals(5, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "c.namee", "c.countrye", "c.provincee", "o.namee", "o.capitale" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "namee", "capitale" };
		String[] expectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray = new String[5];
		DataType[] actualResultFieldTypesArray = new DataType[5];
		String[] actualCanonicalModelConstructNamesArray = new String[5];
		String[] actualParentCanonicalModelConstructNamesArray = new String[5];

		int j = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[j] = resultFieldName;
			actualResultFieldTypesArray[j] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[j] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[j] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			j++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(expectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input1Operator = rootOperator.getLhsInput();

		isInstanceOf(JoinOperator.class, input1Operator);
		assertNull(input1Operator.getVariableName());
		assertNotNull(((JoinOperator) input1Operator).getReconcilingExpression());
		assertEquals("c.countrye = o.codee", ((JoinOperator) input1Operator).getReconcilingExpression().getExpression());
		assertNotNull(input1Operator.getLhsInput());
		assertNotNull(input1Operator.getRhsInput());
		assertEquals(input1Operator.getInput(), input1Operator.getLhsInput());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input1Operator).getPredicates().size());
		Predicate predicate = ((JoinOperator) input1Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate.getSuperLexical1().getName());
		assertEquals("citye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate.getOperator());
		assertEquals("codee", predicate.getSuperLexical2().getName());
		assertEquals("countrye", predicate.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate.getLiteral1());
		assertNull(predicate.getLiteral2());

		assertNotNull(input1Operator.getResultType());
		ResultType resultType1 = input1Operator.getResultType();
		assertEquals(12, resultType1.getResultFields().size());
		String[] expectedResultFieldNamesArray1 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee",
				"o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		DataType[] expectedResultFieldTypesArray1 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray1 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray1 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray1 = new String[12];
		DataType[] actualResultFieldTypesArray1 = new DataType[12];
		String[] actualCanonicalModelConstructNamesArray1 = new String[12];
		String[] actualParentCanonicalModelConstructNamesArray1 = new String[12];

		i = 0;
		Map<String, ResultField> resultFields1 = resultType1.getResultFields();
		Set<String> resultFieldNames1 = resultFields1.keySet();
		for (String resultFieldName : resultFieldNames1) {
			actualResultFieldNamesArray1[i] = resultFieldName;
			actualResultFieldTypesArray1[i] = resultFields1.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray1[i] = resultFields1.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields1.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray1[i] = ((SuperLexical) resultFields1.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray1, actualResultFieldNamesArray1);
		assertArrayEquals(expectedResultFieldTypesArray1, actualResultFieldTypesArray1);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray1, actualCanonicalModelConstructNamesArray1);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray1, actualParentCanonicalModelConstructNamesArray1);

		MappingOperator input11Operator = input1Operator.getLhsInput();
		isInstanceOf(ScanOperator.class, input11Operator);
		assertEquals("c", input11Operator.getVariableName());
		assertNull(input11Operator.getLhsInput());
		assertNull(input11Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input11Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input11Operator).getReconcilingExpression());
		assertEquals("c.namee = 'Manchester'", ((ScanOperator) input11Operator).getReconcilingExpression().getExpression());
		assertEquals("and", ((ScanOperator) input11Operator).getAndOr());

		assertNotNull(input11Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input11Operator.getDataSource());

		assertEquals(1, ((ScanOperator) input11Operator).getPredicates().size());
		Predicate predicate1 = ((ScanOperator) input11Operator).getPredicates().iterator().next();
		assertEquals("namee", predicate1.getSuperLexical1().getName());
		assertEquals("citye", predicate1.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate1.getOperator());
		assertEquals("'Manchester'", predicate1.getLiteral2());
		assertEquals("and", predicate1.getAndOr());
		assertNull(predicate1.getLiteral1());
		assertNull(predicate1.getSuperLexical2());

		assertNotNull(input11Operator.getResultType());
		ResultType resultType2 = input11Operator.getResultType();
		assertEquals(6, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray2 = new String[6];
		DataType[] actualResultFieldTypesArray2 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray2 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);

		MappingOperator input12Operator = input1Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input12Operator);
		assertEquals("o", input12Operator.getVariableName());
		assertNull(input12Operator.getLhsInput());
		assertNull(input12Operator.getRhsInput());
		assertEquals("countrye", ((ScanOperator) input12Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input12Operator).getReconcilingExpression());
		assertEquals("o.codee = 'GB'", ((ScanOperator) input12Operator).getReconcilingExpression().getExpression());
		assertEquals("and", ((ScanOperator) input12Operator).getAndOr());

		assertNotNull(input12Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input12Operator.getDataSource());

		assertEquals(1, ((ScanOperator) input12Operator).getPredicates().size());
		Predicate predicate2 = ((ScanOperator) input12Operator).getPredicates().iterator().next();
		assertEquals("codee", predicate2.getSuperLexical1().getName());
		assertEquals("countrye", predicate2.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate2.getOperator());
		assertEquals("'GB'", predicate2.getLiteral2());
		assertEquals("and", predicate2.getAndOr());
		assertNull(predicate2.getLiteral1());
		assertNull(predicate2.getSuperLexical2());

		assertNotNull(input12Operator.getResultType());
		ResultType resultType3 = input12Operator.getResultType();
		assertEquals(6, resultType3.getResultFields().size());
		String[] expectedResultFieldNamesArray3 = { "o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		DataType[] expectedResultFieldTypesArray3 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT,
				DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray3 = { "namee", "codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray3 = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray3 = new String[6];
		DataType[] actualResultFieldTypesArray3 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray3 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray3 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields3 = resultType3.getResultFields();
		Set<String> resultFieldNames3 = resultFields3.keySet();
		for (String resultFieldName : resultFieldNames3) {
			actualResultFieldNamesArray3[i] = resultFieldName;
			actualResultFieldTypesArray3[i] = resultFields3.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray3[i] = resultFields3.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields3.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray3[i] = ((SuperLexical) resultFields3.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray3, actualResultFieldNamesArray3);
		assertArrayEquals(expectedResultFieldTypesArray3, actualResultFieldTypesArray3);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray3, actualCanonicalModelConstructNamesArray3);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray3, actualParentCanonicalModelConstructNamesArray3);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	//@Test
	public void testTranslateAstIntoQuerySelectSuperLexicalsFromJoinWhereOrQueryWithVariableNameOneSource() {
		String selectSuperLexicalsFromJoinWhereOrQueryWithVariableName = "Select c.namee, c.countrye, c.provincee, o.namee, o.capitale from citye c, countrye o where c.countrye = o.codee and (o.codee = 'GB' or o.codee = 'D')";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectSuperLexicalsFromJoinWhereOrQueryWithVariableName);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectSuperLexicalsFromJoinWhereOrQueryWithVariableNameAst = parser
				.parseSQL(selectSuperLexicalsFromJoinWhereOrQueryWithVariableName);
		logger.debug("selectSuperLexicalsFromJoinWhereOrQueryWithVariableNameAst: "
				+ selectSuperLexicalsFromJoinWhereOrQueryWithVariableNameAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectSuperLexicalsFromJoinWhereOrQueryWithVariableName,
				selectSuperLexicalsFromJoinWhereOrQueryWithVariableNameAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(5, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals("c.namee, c.countrye, c.provincee, o.namee, o.capitale", ((ReduceOperator) rootOperator).getReconcilingExpression()
				.getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[5];
		String[] superAbstractNamesArray = new String[5];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "namee", "capitale" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "countrye", "countrye" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[5];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "c.namee", "c.countrye", "c.provincee", "o.namee", "o.capitale" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType = rootOperator.getResultType();
		assertEquals(5, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "c.namee", "c.countrye", "c.provincee", "o.namee", "o.capitale" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "namee", "capitale" };
		String[] expectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray = new String[5];
		DataType[] actualResultFieldTypesArray = new DataType[5];
		String[] actualCanonicalModelConstructNamesArray = new String[5];
		String[] actualParentCanonicalModelConstructNamesArray = new String[5];

		int j = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[j] = resultFieldName;
			actualResultFieldTypesArray[j] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[j] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[j] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			j++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(expectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input1Operator = rootOperator.getLhsInput();

		isInstanceOf(JoinOperator.class, input1Operator);
		assertNull(input1Operator.getVariableName());
		assertNotNull(((JoinOperator) input1Operator).getReconcilingExpression());
		assertEquals("c.countrye = o.codee", ((JoinOperator) input1Operator).getReconcilingExpression().getExpression());
		assertNotNull(input1Operator.getLhsInput());
		assertNotNull(input1Operator.getRhsInput());
		assertEquals(input1Operator.getInput(), input1Operator.getLhsInput());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input1Operator).getPredicates().size());
		Predicate predicate = ((JoinOperator) input1Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate.getSuperLexical1().getName());
		assertEquals("citye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate.getOperator());
		assertEquals("codee", predicate.getSuperLexical2().getName());
		assertEquals("countrye", predicate.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate.getLiteral1());
		assertNull(predicate.getLiteral2());

		assertNotNull(input1Operator.getResultType());
		ResultType resultType1 = input1Operator.getResultType();
		assertEquals(12, resultType1.getResultFields().size());
		String[] expectedResultFieldNamesArray1 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee",
				"o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		DataType[] expectedResultFieldTypesArray1 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray1 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray1 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray1 = new String[12];
		DataType[] actualResultFieldTypesArray1 = new DataType[12];
		String[] actualCanonicalModelConstructNamesArray1 = new String[12];
		String[] actualParentCanonicalModelConstructNamesArray1 = new String[12];

		i = 0;
		Map<String, ResultField> resultFields1 = resultType1.getResultFields();
		Set<String> resultFieldNames1 = resultFields1.keySet();
		for (String resultFieldName : resultFieldNames1) {
			actualResultFieldNamesArray1[i] = resultFieldName;
			actualResultFieldTypesArray1[i] = resultFields1.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray1[i] = resultFields1.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields1.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray1[i] = ((SuperLexical) resultFields1.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray1, actualResultFieldNamesArray1);
		assertArrayEquals(expectedResultFieldTypesArray1, actualResultFieldTypesArray1);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray1, actualCanonicalModelConstructNamesArray1);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray1, actualParentCanonicalModelConstructNamesArray1);

		MappingOperator input11Operator = input1Operator.getLhsInput();
		isInstanceOf(ScanOperator.class, input11Operator);
		assertEquals("c", input11Operator.getVariableName());
		assertNull(input11Operator.getLhsInput());
		assertNull(input11Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input11Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input11Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input11Operator).getPredicates().size());

		assertNotNull(input11Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input11Operator.getDataSource());

		assertNotNull(input11Operator.getResultType());
		ResultType resultType2 = input11Operator.getResultType();
		assertEquals(6, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray2 = new String[6];
		DataType[] actualResultFieldTypesArray2 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray2 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);

		MappingOperator input12Operator = input1Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input12Operator);
		assertEquals("o", input12Operator.getVariableName());
		assertNull(input12Operator.getLhsInput());
		assertNull(input12Operator.getRhsInput());
		assertEquals("countrye", ((ScanOperator) input12Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input12Operator).getReconcilingExpression());
		assertEquals("o.codee = 'GB' or o.codee = 'D'", ((ScanOperator) input12Operator).getReconcilingExpression().getExpression());
		assertEquals("and", ((ScanOperator) input12Operator).getAndOr());

		assertNotNull(input12Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input12Operator.getDataSource());

		assertEquals(2, ((ScanOperator) input12Operator).getPredicates().size());

		Set<Predicate> predicates = ((ScanOperator) input12Operator).getPredicates();

		int k = 0;

		for (Predicate predicate1 : predicates) {
			if (k == 0) {
				//Predicate predicate1 = ((ScanOperator) input12Operator).getPredicates().get(0);
				assertEquals("codee", predicate1.getSuperLexical1().getName());
				assertEquals("countrye", predicate1.getSuperLexical1().getParentSuperAbstract().getName());
				assertEquals("=", predicate1.getOperator());
				assertEquals("'GB'", predicate1.getLiteral2());
				assertEquals("and", predicate1.getAndOr());
				assertNull(predicate1.getLiteral1());
				assertNull(predicate1.getSuperLexical2());
			} else if (k == 1) {
				//Predicate predicate2 = ((ScanOperator) input12Operator).getPredicates().get(1);
				assertEquals("codee", predicate1.getSuperLexical1().getName());
				assertEquals("countrye", predicate1.getSuperLexical1().getParentSuperAbstract().getName());
				assertEquals("=", predicate1.getOperator());
				assertEquals("'D'", predicate1.getLiteral2());
				assertEquals("or", predicate1.getAndOr());
				assertNull(predicate1.getLiteral1());
				assertNull(predicate1.getSuperLexical2());
			}
			k++;
		}

		assertNotNull(input12Operator.getResultType());
		ResultType resultType3 = input12Operator.getResultType();
		assertEquals(6, resultType3.getResultFields().size());
		String[] expectedResultFieldNamesArray3 = { "o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		DataType[] expectedResultFieldTypesArray3 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT,
				DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray3 = { "namee", "codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray3 = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray3 = new String[6];
		DataType[] actualResultFieldTypesArray3 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray3 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray3 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields3 = resultType3.getResultFields();
		Set<String> resultFieldNames3 = resultFields3.keySet();
		for (String resultFieldName : resultFieldNames3) {
			actualResultFieldNamesArray3[i] = resultFieldName;
			actualResultFieldTypesArray3[i] = resultFields3.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray3[i] = resultFields3.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields3.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray3[i] = ((SuperLexical) resultFields3.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray3, actualResultFieldNamesArray3);
		assertArrayEquals(expectedResultFieldTypesArray3, actualResultFieldTypesArray3);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray3, actualCanonicalModelConstructNamesArray3);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray3, actualParentCanonicalModelConstructNamesArray3);
	}

	//---------------------------------------------------------------------

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectStarFromJoinJoinQueryOneSource() {
		String selectStarFromJoinJoinQuery = "Select * from citye, countrye, borderse where citye.countrye = countrye.codee and countrye.codee = borderse.country1e";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectStarFromJoinJoinQuery);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectStarFromJoinJoinQueryAst = parser.parseSQL(selectStarFromJoinJoinQuery);
		logger.debug("selectStarFromJoinJoinQueryAst: " + selectStarFromJoinJoinQueryAst);
		query = globalTranslator.translateAstIntoQuery(query, selectStarFromJoinJoinQuery, selectStarFromJoinJoinQueryAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(15, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals(
				"citye.namee, citye.countrye, citye.provincee, citye.populatione, citye.longitudee, citye.latitudee, countrye.namee, countrye.codee, countrye.capitale, countrye.provincee, countrye.areae, countrye.populatione, borderse.country1e, borderse.country2e, borderse.lengthe",
				((ReduceOperator) rootOperator).getReconcilingExpression().getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[15];
		String[] superAbstractNamesArray = new String[15];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee", "codee",
				"capitale", "provincee", "areae", "populatione", "country1e", "country2e", "lengthe" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "borderse", "borderse", "borderse" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[15];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione",
				"citye.longitudee", "citye.latitudee", "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee",
				"countrye.areae", "countrye.populatione", "borderse.country1e", "borderse.country2e", "borderse.lengthe" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType0 = rootOperator.getResultType();
		assertEquals(15, resultType0.getResultFields().size());
		String[] expectedResultFieldNamesArray0 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee", "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione", "borderse.country1e", "borderse.country2e", "borderse.lengthe" };
		DataType[] expectedResultFieldTypesArray0 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER,
				DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray0 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione", "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray0 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye", "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray0 = new String[15];
		DataType[] actualResultFieldTypesArray0 = new DataType[15];
		String[] actualCanonicalModelConstructNamesArray0 = new String[15];
		String[] actualParentCanonicalModelConstructNamesArray0 = new String[15];

		i = 0;
		Map<String, ResultField> resultFields0 = resultType0.getResultFields();
		Set<String> resultFieldNames0 = resultFields0.keySet();
		for (String resultFieldName : resultFieldNames0) {
			actualResultFieldNamesArray0[i] = resultFieldName;
			actualResultFieldTypesArray0[i] = resultFields0.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultFields0.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields0.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultFields0.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray0, actualResultFieldNamesArray0);
		assertArrayEquals(expectedResultFieldTypesArray0, actualResultFieldTypesArray0);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray0, actualCanonicalModelConstructNamesArray0);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray0, actualParentCanonicalModelConstructNamesArray0);

		MappingOperator input0Operator = rootOperator.getLhsInput();

		isInstanceOf(JoinOperator.class, input0Operator);
		assertNull(input0Operator.getVariableName());
		assertNotNull(((JoinOperator) input0Operator).getReconcilingExpression());
		assertEquals("countrye.codee = borderse.country1e", ((JoinOperator) input0Operator).getReconcilingExpression().getExpression());
		assertNotNull(input0Operator.getLhsInput());
		assertNotNull(input0Operator.getRhsInput());
		assertEquals(input0Operator.getInput(), input0Operator.getLhsInput());

		assertNotNull(input0Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input0Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input0Operator).getPredicates().size());
		Predicate predicate = ((JoinOperator) input0Operator).getPredicates().iterator().next();
		assertEquals("codee", predicate.getSuperLexical1().getName());
		assertEquals("countrye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate.getOperator());
		assertEquals("country1e", predicate.getSuperLexical2().getName());
		assertEquals("borderse", predicate.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate.getLiteral1());
		assertNull(predicate.getLiteral2());

		assertNotNull(input0Operator.getResultType());
		ResultType resultType = input0Operator.getResultType();
		assertEquals(15, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee", "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione", "borderse.country1e", "borderse.country2e", "borderse.lengthe" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER,
				DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione", "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye", "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray = new String[15];
		DataType[] actualResultFieldTypesArray = new DataType[15];
		String[] actualCanonicalModelConstructNamesArray = new String[15];
		String[] actualParentCanonicalModelConstructNamesArray = new String[15];

		i = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[i] = resultFieldName;
			actualResultFieldTypesArray[i] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input1Operator = input0Operator.getLhsInput();
		isInstanceOf(JoinOperator.class, input1Operator);
		assertNotNull(input1Operator.getVariableName());
		assertEquals("countrye", input1Operator.getVariableName());
		assertNotNull(((JoinOperator) input1Operator).getReconcilingExpression());
		assertEquals("citye.countrye = countrye.codee", ((JoinOperator) input1Operator).getReconcilingExpression().getExpression());
		assertNotNull(input1Operator.getLhsInput());
		assertNotNull(input1Operator.getRhsInput());
		assertEquals(input1Operator.getInput(), input1Operator.getLhsInput());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input1Operator).getPredicates().size());
		Predicate predicate1 = ((JoinOperator) input1Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate1.getSuperLexical1().getName());
		assertEquals("citye", predicate1.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate1.getOperator());
		assertEquals("codee", predicate1.getSuperLexical2().getName());
		assertEquals("countrye", predicate1.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate1.getLiteral1());
		assertNull(predicate1.getLiteral2());

		assertNotNull(input1Operator.getResultType());
		ResultType resultType1 = input1Operator.getResultType();
		assertEquals(12, resultType1.getResultFields().size());
		String[] expectedResultFieldNamesArray1 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee", "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione" };
		DataType[] expectedResultFieldTypesArray1 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray1 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray1 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray1 = new String[12];
		DataType[] actualResultFieldTypesArray1 = new DataType[12];
		String[] actualCanonicalModelConstructNamesArray1 = new String[12];
		String[] actualParentCanonicalModelConstructNamesArray1 = new String[12];

		i = 0;
		Map<String, ResultField> resultFields1 = resultType1.getResultFields();
		Set<String> resultFieldNames1 = resultFields1.keySet();
		for (String resultFieldName : resultFieldNames1) {
			actualResultFieldNamesArray1[i] = resultFieldName;
			actualResultFieldTypesArray1[i] = resultFields1.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray1[i] = resultFields1.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields1.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray1[i] = ((SuperLexical) resultFields1.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray1, actualResultFieldNamesArray1);
		assertArrayEquals(expectedResultFieldTypesArray1, actualResultFieldTypesArray1);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray1, actualCanonicalModelConstructNamesArray1);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray1, actualParentCanonicalModelConstructNamesArray1);

		MappingOperator input2Operator = input0Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input2Operator);
		assertEquals("borderse", input2Operator.getVariableName());
		assertNull(input2Operator.getLhsInput());
		assertNull(input2Operator.getRhsInput());
		assertEquals("borderse", ((ScanOperator) input2Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input2Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input2Operator).getPredicates().size());

		assertNotNull(input2Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input2Operator.getDataSource());

		assertNotNull(input2Operator.getResultType());
		ResultType resultType2 = input2Operator.getResultType();
		assertEquals(3, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "borderse.country1e", "borderse.country2e", "borderse.lengthe" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray2 = new String[3];
		DataType[] actualResultFieldTypesArray2 = new DataType[3];
		String[] actualCanonicalModelConstructNamesArray2 = new String[3];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[3];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);

		MappingOperator input11Operator = input1Operator.getLhsInput();
		isInstanceOf(ScanOperator.class, input11Operator);
		assertEquals("citye", input11Operator.getVariableName());
		assertNull(input11Operator.getLhsInput());
		assertNull(input11Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input11Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input11Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input11Operator).getPredicates().size());

		assertNotNull(input11Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input11Operator.getDataSource());

		assertNotNull(input11Operator.getResultType());
		ResultType resultType3 = input11Operator.getResultType();
		assertEquals(6, resultType3.getResultFields().size());
		String[] expectedResultFieldNamesArray3 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee" };
		DataType[] expectedResultFieldTypesArray3 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray3 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray3 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray3 = new String[6];
		DataType[] actualResultFieldTypesArray3 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray3 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray3 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields3 = resultType3.getResultFields();
		Set<String> resultFieldNames3 = resultFields3.keySet();
		for (String resultFieldName : resultFieldNames3) {
			actualResultFieldNamesArray3[i] = resultFieldName;
			actualResultFieldTypesArray3[i] = resultFields3.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray3[i] = resultFields3.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields3.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray3[i] = ((SuperLexical) resultFields3.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray3, actualResultFieldNamesArray3);
		assertArrayEquals(expectedResultFieldTypesArray3, actualResultFieldTypesArray3);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray3, actualCanonicalModelConstructNamesArray3);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray3, actualParentCanonicalModelConstructNamesArray3);

		MappingOperator input12Operator = input1Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input12Operator);
		assertEquals("countrye", input12Operator.getVariableName());
		assertNull(input12Operator.getLhsInput());
		assertNull(input12Operator.getRhsInput());
		assertEquals("countrye", ((ScanOperator) input12Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input12Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input12Operator).getPredicates().size());

		assertNotNull(input12Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input12Operator.getDataSource());

		assertNotNull(input12Operator.getResultType());
		ResultType resultType4 = input12Operator.getResultType();
		assertEquals(6, resultType4.getResultFields().size());
		String[] expectedResultFieldNamesArray4 = { "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione" };
		DataType[] expectedResultFieldTypesArray4 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT,
				DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray4 = { "namee", "codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray4 = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray4 = new String[6];
		DataType[] actualResultFieldTypesArray4 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray4 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray4 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields4 = resultType4.getResultFields();
		Set<String> resultFieldNames4 = resultFields4.keySet();
		for (String resultFieldName : resultFieldNames4) {
			actualResultFieldNamesArray4[i] = resultFieldName;
			actualResultFieldTypesArray4[i] = resultFields4.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray4[i] = resultFields4.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields4.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray4[i] = ((SuperLexical) resultFields4.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray4, actualResultFieldNamesArray4);
		assertArrayEquals(expectedResultFieldTypesArray4, actualResultFieldTypesArray4);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray4, actualCanonicalModelConstructNamesArray4);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray4, actualParentCanonicalModelConstructNamesArray4);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectStarFromJoinJoinWhereQueryOneSource() {
		String selectStarFromJoinJoinWhereQuery = "Select * from citye, countrye, borderse where citye.countrye = countrye.codee and countrye.codee = borderse.country1e and countrye.codee = 'GB'";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectStarFromJoinJoinWhereQuery);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectStarFromJoinJoinWhereQueryAst;
		selectStarFromJoinJoinWhereQueryAst = parser.parseSQL(selectStarFromJoinJoinWhereQuery);
		logger.debug("selectStarFromJoinJoinWhereQueryAst: " + selectStarFromJoinJoinWhereQueryAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectStarFromJoinJoinWhereQuery, selectStarFromJoinJoinWhereQueryAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(15, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals(
				"citye.namee, citye.countrye, citye.provincee, citye.populatione, citye.longitudee, citye.latitudee, countrye.namee, countrye.codee, countrye.capitale, countrye.provincee, countrye.areae, countrye.populatione, borderse.country1e, borderse.country2e, borderse.lengthe",
				((ReduceOperator) rootOperator).getReconcilingExpression().getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[15];
		String[] superAbstractNamesArray = new String[15];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee", "codee",
				"capitale", "provincee", "areae", "populatione", "country1e", "country2e", "lengthe" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "borderse", "borderse", "borderse" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[15];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione",
				"citye.longitudee", "citye.latitudee", "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee",
				"countrye.areae", "countrye.populatione", "borderse.country1e", "borderse.country2e", "borderse.lengthe" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType0 = rootOperator.getResultType();
		assertEquals(15, resultType0.getResultFields().size());
		String[] expectedResultFieldNamesArray0 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee", "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione", "borderse.country1e", "borderse.country2e", "borderse.lengthe" };
		DataType[] expectedResultFieldTypesArray0 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER,
				DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray0 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione", "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray0 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye", "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray0 = new String[15];
		DataType[] actualResultFieldTypesArray0 = new DataType[15];
		String[] actualCanonicalModelConstructNamesArray0 = new String[15];
		String[] actualParentCanonicalModelConstructNamesArray0 = new String[15];

		i = 0;
		Map<String, ResultField> resultFields0 = resultType0.getResultFields();
		Set<String> resultFieldNames0 = resultFields0.keySet();
		for (String resultFieldName : resultFieldNames0) {
			actualResultFieldNamesArray0[i] = resultFieldName;
			actualResultFieldTypesArray0[i] = resultFields0.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultFields0.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields0.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultFields0.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray0, actualResultFieldNamesArray0);
		assertArrayEquals(expectedResultFieldTypesArray0, actualResultFieldTypesArray0);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray0, actualCanonicalModelConstructNamesArray0);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray0, actualParentCanonicalModelConstructNamesArray0);

		MappingOperator input0Operator = rootOperator.getLhsInput();

		isInstanceOf(JoinOperator.class, input0Operator);
		assertNull(input0Operator.getVariableName());
		assertNotNull(((JoinOperator) input0Operator).getReconcilingExpression());
		assertEquals("countrye.codee = borderse.country1e", ((JoinOperator) input0Operator).getReconcilingExpression().getExpression());
		assertNotNull(input0Operator.getLhsInput());
		assertNotNull(input0Operator.getRhsInput());
		assertEquals(input0Operator.getInput(), input0Operator.getLhsInput());

		assertNotNull(input0Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input0Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input0Operator).getPredicates().size());
		Predicate predicate = ((JoinOperator) input0Operator).getPredicates().iterator().next();
		assertEquals("codee", predicate.getSuperLexical1().getName());
		assertEquals("countrye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate.getOperator());
		assertEquals("country1e", predicate.getSuperLexical2().getName());
		assertEquals("borderse", predicate.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate.getLiteral1());
		assertNull(predicate.getLiteral2());

		assertNotNull(rootOperator.getResultType());
		ResultType resultType = rootOperator.getResultType();
		assertEquals(15, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee", "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione", "borderse.country1e", "borderse.country2e", "borderse.lengthe" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER,
				DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione", "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye", "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray = new String[15];
		DataType[] actualResultFieldTypesArray = new DataType[15];
		String[] actualCanonicalModelConstructNamesArray = new String[15];
		String[] actualParentCanonicalModelConstructNamesArray = new String[15];

		i = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[i] = resultFieldName;
			actualResultFieldTypesArray[i] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input1Operator = input0Operator.getLhsInput();
		isInstanceOf(JoinOperator.class, input1Operator);
		assertNotNull(input1Operator.getVariableName());
		assertEquals("countrye", input1Operator.getVariableName());
		assertNotNull(((JoinOperator) input1Operator).getReconcilingExpression());
		assertEquals("citye.countrye = countrye.codee", ((JoinOperator) input1Operator).getReconcilingExpression().getExpression());
		assertNotNull(input1Operator.getLhsInput());
		assertNotNull(input1Operator.getRhsInput());
		assertEquals(input1Operator.getInput(), input1Operator.getLhsInput());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input1Operator).getPredicates().size());
		Predicate predicate1 = ((JoinOperator) input1Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate1.getSuperLexical1().getName());
		assertEquals("citye", predicate1.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate1.getOperator());
		assertEquals("codee", predicate1.getSuperLexical2().getName());
		assertEquals("countrye", predicate1.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate1.getLiteral1());
		assertNull(predicate1.getLiteral2());

		assertNotNull(input1Operator.getResultType());
		ResultType resultType1 = input1Operator.getResultType();
		assertEquals(12, resultType1.getResultFields().size());
		String[] expectedResultFieldNamesArray1 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee", "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione" };
		DataType[] expectedResultFieldTypesArray1 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray1 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray1 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray1 = new String[12];
		DataType[] actualResultFieldTypesArray1 = new DataType[12];
		String[] actualCanonicalModelConstructNamesArray1 = new String[12];
		String[] actualParentCanonicalModelConstructNamesArray1 = new String[12];

		i = 0;
		Map<String, ResultField> resultFields1 = resultType1.getResultFields();
		Set<String> resultFieldNames1 = resultFields1.keySet();
		for (String resultFieldName : resultFieldNames1) {
			actualResultFieldNamesArray1[i] = resultFieldName;
			actualResultFieldTypesArray1[i] = resultFields1.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray1[i] = resultFields1.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields1.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray1[i] = ((SuperLexical) resultFields1.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray1, actualResultFieldNamesArray1);
		assertArrayEquals(expectedResultFieldTypesArray1, actualResultFieldTypesArray1);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray1, actualCanonicalModelConstructNamesArray1);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray1, actualParentCanonicalModelConstructNamesArray1);

		MappingOperator input2Operator = input0Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input2Operator);
		assertEquals("borderse", input2Operator.getVariableName());
		assertNull(input2Operator.getLhsInput());
		assertNull(input2Operator.getRhsInput());
		assertEquals("borderse", ((ScanOperator) input2Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input2Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input2Operator).getPredicates().size());

		assertNotNull(input2Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input2Operator.getDataSource());

		assertNotNull(input2Operator.getResultType());
		ResultType resultType2 = input2Operator.getResultType();
		assertEquals(3, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "borderse.country1e", "borderse.country2e", "borderse.lengthe" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray2 = new String[3];
		DataType[] actualResultFieldTypesArray2 = new DataType[3];
		String[] actualCanonicalModelConstructNamesArray2 = new String[3];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[3];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);

		MappingOperator input11Operator = input1Operator.getLhsInput();
		isInstanceOf(ScanOperator.class, input11Operator);
		assertEquals("citye", input11Operator.getVariableName());
		assertNull(input11Operator.getLhsInput());
		assertNull(input11Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input11Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input11Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input11Operator).getPredicates().size());

		assertNotNull(input11Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input11Operator.getDataSource());

		assertNotNull(input11Operator.getResultType());
		ResultType resultType3 = input11Operator.getResultType();
		assertEquals(6, resultType3.getResultFields().size());
		String[] expectedResultFieldNamesArray3 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee" };
		DataType[] expectedResultFieldTypesArray3 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray3 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray3 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray3 = new String[6];
		DataType[] actualResultFieldTypesArray3 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray3 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray3 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields3 = resultType3.getResultFields();
		Set<String> resultFieldNames3 = resultFields3.keySet();
		for (String resultFieldName : resultFieldNames3) {
			actualResultFieldNamesArray3[i] = resultFieldName;
			actualResultFieldTypesArray3[i] = resultFields3.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray3[i] = resultFields3.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields3.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray3[i] = ((SuperLexical) resultFields3.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray3, actualResultFieldNamesArray3);
		assertArrayEquals(expectedResultFieldTypesArray3, actualResultFieldTypesArray3);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray3, actualCanonicalModelConstructNamesArray3);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray3, actualParentCanonicalModelConstructNamesArray3);

		MappingOperator input12Operator = input1Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input12Operator);
		assertEquals("countrye", input12Operator.getVariableName());
		assertNull(input12Operator.getLhsInput());
		assertNull(input12Operator.getRhsInput());
		assertEquals("countrye", ((ScanOperator) input12Operator).getSuperAbstract().getName());
		assertEquals("countrye.codee = 'GB'", ((ScanOperator) input12Operator).getReconcilingExpression().getExpression());
		assertEquals("and", ((ScanOperator) input12Operator).getAndOr());

		assertNotNull(input12Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input12Operator.getDataSource());

		assertEquals(1, ((ScanOperator) input12Operator).getPredicates().size());
		Predicate predicate2 = ((ScanOperator) input12Operator).getPredicates().iterator().next();
		assertEquals("codee", predicate2.getSuperLexical1().getName());
		assertEquals("countrye", predicate2.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate2.getOperator());
		assertEquals("'GB'", predicate2.getLiteral2());
		assertEquals("and", predicate2.getAndOr());
		assertNull(predicate2.getLiteral1());
		assertNull(predicate2.getSuperLexical2());

		assertNotNull(input12Operator.getResultType());
		ResultType resultType4 = input12Operator.getResultType();
		assertEquals(6, resultType4.getResultFields().size());
		String[] expectedResultFieldNamesArray4 = { "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione" };
		DataType[] expectedResultFieldTypesArray4 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT,
				DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray4 = { "namee", "codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray4 = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray4 = new String[6];
		DataType[] actualResultFieldTypesArray4 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray4 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray4 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields4 = resultType4.getResultFields();
		Set<String> resultFieldNames4 = resultFields4.keySet();
		for (String resultFieldName : resultFieldNames4) {
			actualResultFieldNamesArray4[i] = resultFieldName;
			actualResultFieldTypesArray4[i] = resultFields4.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray4[i] = resultFields4.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields4.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray4[i] = ((SuperLexical) resultFields4.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray4, actualResultFieldNamesArray4);
		assertArrayEquals(expectedResultFieldTypesArray4, actualResultFieldTypesArray4);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray4, actualCanonicalModelConstructNamesArray4);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray4, actualParentCanonicalModelConstructNamesArray4);

	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectStarFromJoinJoinWhereAndQueryOneSource() {
		String selectStarFromJoinJoinWhereAndQuery = "Select * from citye, countrye, borderse where citye.countrye = countrye.codee and countrye.codee = borderse.country1e and countrye.codee = 'GB' and citye.namee = 'Manchester'";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectStarFromJoinJoinWhereAndQuery);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectStarFromJoinJoinWhereAndQueryAst = parser.parseSQL(selectStarFromJoinJoinWhereAndQuery);
		logger.debug("selectStarFromJoinJoinWhereAndQueryAst: " + selectStarFromJoinJoinWhereAndQueryAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectStarFromJoinJoinWhereAndQuery, selectStarFromJoinJoinWhereAndQueryAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(15, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals(
				"citye.namee, citye.countrye, citye.provincee, citye.populatione, citye.longitudee, citye.latitudee, countrye.namee, countrye.codee, countrye.capitale, countrye.provincee, countrye.areae, countrye.populatione, borderse.country1e, borderse.country2e, borderse.lengthe",
				((ReduceOperator) rootOperator).getReconcilingExpression().getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[15];
		String[] superAbstractNamesArray = new String[15];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee", "codee",
				"capitale", "provincee", "areae", "populatione", "country1e", "country2e", "lengthe" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "borderse", "borderse", "borderse" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[15];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione",
				"citye.longitudee", "citye.latitudee", "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee",
				"countrye.areae", "countrye.populatione", "borderse.country1e", "borderse.country2e", "borderse.lengthe" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType0 = rootOperator.getResultType();
		assertEquals(15, resultType0.getResultFields().size());
		String[] expectedResultFieldNamesArray0 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee", "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione", "borderse.country1e", "borderse.country2e", "borderse.lengthe" };
		DataType[] expectedResultFieldTypesArray0 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER,
				DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray0 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione", "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray0 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye", "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray0 = new String[15];
		DataType[] actualResultFieldTypesArray0 = new DataType[15];
		String[] actualCanonicalModelConstructNamesArray0 = new String[15];
		String[] actualParentCanonicalModelConstructNamesArray0 = new String[15];

		i = 0;
		Map<String, ResultField> resultFields0 = resultType0.getResultFields();
		Set<String> resultFieldNames0 = resultFields0.keySet();
		for (String resultFieldName : resultFieldNames0) {
			actualResultFieldNamesArray0[i] = resultFieldName;
			actualResultFieldTypesArray0[i] = resultFields0.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultFields0.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields0.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultFields0.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray0, actualResultFieldNamesArray0);
		assertArrayEquals(expectedResultFieldTypesArray0, actualResultFieldTypesArray0);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray0, actualCanonicalModelConstructNamesArray0);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray0, actualParentCanonicalModelConstructNamesArray0);

		MappingOperator input0Operator = rootOperator.getLhsInput();

		isInstanceOf(JoinOperator.class, input0Operator);
		assertNull(input0Operator.getVariableName());
		assertNotNull(((JoinOperator) input0Operator).getReconcilingExpression());
		assertEquals("countrye.codee = borderse.country1e", ((JoinOperator) input0Operator).getReconcilingExpression().getExpression());
		assertNotNull(input0Operator.getLhsInput());
		assertNotNull(input0Operator.getRhsInput());
		assertEquals(input0Operator.getInput(), input0Operator.getLhsInput());

		assertNotNull(input0Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input0Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input0Operator).getPredicates().size());
		Predicate predicate = ((JoinOperator) input0Operator).getPredicates().iterator().next();
		assertEquals("codee", predicate.getSuperLexical1().getName());
		assertEquals("countrye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate.getOperator());
		assertEquals("country1e", predicate.getSuperLexical2().getName());
		assertEquals("borderse", predicate.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate.getLiteral1());
		assertNull(predicate.getLiteral2());

		assertNotNull(rootOperator.getResultType());
		ResultType resultType = rootOperator.getResultType();
		assertEquals(15, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee", "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione", "borderse.country1e", "borderse.country2e", "borderse.lengthe" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER,
				DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione", "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye", "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray = new String[15];
		DataType[] actualResultFieldTypesArray = new DataType[15];
		String[] actualCanonicalModelConstructNamesArray = new String[15];
		String[] actualParentCanonicalModelConstructNamesArray = new String[15];

		i = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[i] = resultFieldName;
			actualResultFieldTypesArray[i] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input1Operator = input0Operator.getLhsInput();
		isInstanceOf(JoinOperator.class, input1Operator);
		assertNotNull(input1Operator.getVariableName());
		assertEquals("countrye", input1Operator.getVariableName());
		assertNotNull(((JoinOperator) input1Operator).getReconcilingExpression());
		assertEquals("citye.countrye = countrye.codee", ((JoinOperator) input1Operator).getReconcilingExpression().getExpression());
		assertNotNull(input1Operator.getLhsInput());
		assertNotNull(input1Operator.getRhsInput());
		assertEquals(input1Operator.getInput(), input1Operator.getLhsInput());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input1Operator).getPredicates().size());
		Predicate predicate1 = ((JoinOperator) input1Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate1.getSuperLexical1().getName());
		assertEquals("citye", predicate1.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate1.getOperator());
		assertEquals("codee", predicate1.getSuperLexical2().getName());
		assertEquals("countrye", predicate1.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate1.getLiteral1());
		assertNull(predicate1.getLiteral2());

		assertNotNull(input1Operator.getResultType());
		ResultType resultType1 = input1Operator.getResultType();
		assertEquals(12, resultType1.getResultFields().size());
		String[] expectedResultFieldNamesArray1 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee", "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione" };
		DataType[] expectedResultFieldTypesArray1 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray1 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray1 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray1 = new String[12];
		DataType[] actualResultFieldTypesArray1 = new DataType[12];
		String[] actualCanonicalModelConstructNamesArray1 = new String[12];
		String[] actualParentCanonicalModelConstructNamesArray1 = new String[12];

		i = 0;
		Map<String, ResultField> resultFields1 = resultType1.getResultFields();
		Set<String> resultFieldNames1 = resultFields1.keySet();
		for (String resultFieldName : resultFieldNames1) {
			actualResultFieldNamesArray1[i] = resultFieldName;
			actualResultFieldTypesArray1[i] = resultFields1.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray1[i] = resultFields1.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields1.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray1[i] = ((SuperLexical) resultFields1.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray1, actualResultFieldNamesArray1);
		assertArrayEquals(expectedResultFieldTypesArray1, actualResultFieldTypesArray1);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray1, actualCanonicalModelConstructNamesArray1);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray1, actualParentCanonicalModelConstructNamesArray1);

		MappingOperator input2Operator = input0Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input2Operator);
		assertEquals("borderse", input2Operator.getVariableName());
		assertNull(input2Operator.getLhsInput());
		assertNull(input2Operator.getRhsInput());
		assertEquals("borderse", ((ScanOperator) input2Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input2Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input2Operator).getPredicates().size());

		assertNotNull(input2Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input2Operator.getDataSource());

		assertNotNull(input2Operator.getResultType());
		ResultType resultType2 = input2Operator.getResultType();
		assertEquals(3, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "borderse.country1e", "borderse.country2e", "borderse.lengthe" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray2 = new String[3];
		DataType[] actualResultFieldTypesArray2 = new DataType[3];
		String[] actualCanonicalModelConstructNamesArray2 = new String[3];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[3];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);

		MappingOperator input11Operator = input1Operator.getLhsInput();
		isInstanceOf(ScanOperator.class, input11Operator);
		assertEquals("citye", input11Operator.getVariableName());
		assertNull(input11Operator.getLhsInput());
		assertNull(input11Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input11Operator).getSuperAbstract().getName());
		assertEquals("citye.namee = 'Manchester'", ((ScanOperator) input11Operator).getReconcilingExpression().getExpression());
		assertEquals("and", ((ScanOperator) input11Operator).getAndOr());

		assertNotNull(input11Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input11Operator.getDataSource());

		assertEquals(1, ((ScanOperator) input11Operator).getPredicates().size());
		Predicate predicate2 = ((ScanOperator) input11Operator).getPredicates().iterator().next();
		assertEquals("namee", predicate2.getSuperLexical1().getName());
		assertEquals("citye", predicate2.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate2.getOperator());
		assertEquals("'Manchester'", predicate2.getLiteral2());
		assertEquals("and", predicate2.getAndOr());
		assertNull(predicate2.getLiteral1());
		assertNull(predicate2.getSuperLexical2());

		assertNotNull(input11Operator.getResultType());
		ResultType resultType3 = input11Operator.getResultType();
		assertEquals(6, resultType3.getResultFields().size());
		String[] expectedResultFieldNamesArray3 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee" };
		DataType[] expectedResultFieldTypesArray3 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray3 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray3 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray3 = new String[6];
		DataType[] actualResultFieldTypesArray3 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray3 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray3 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields3 = resultType3.getResultFields();
		Set<String> resultFieldNames3 = resultFields3.keySet();
		for (String resultFieldName : resultFieldNames3) {
			actualResultFieldNamesArray3[i] = resultFieldName;
			actualResultFieldTypesArray3[i] = resultFields3.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray3[i] = resultFields3.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields3.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray3[i] = ((SuperLexical) resultFields3.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray3, actualResultFieldNamesArray3);
		assertArrayEquals(expectedResultFieldTypesArray3, actualResultFieldTypesArray3);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray3, actualCanonicalModelConstructNamesArray3);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray3, actualParentCanonicalModelConstructNamesArray3);

		MappingOperator input12Operator = input1Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input12Operator);
		assertEquals("countrye", input12Operator.getVariableName());
		assertNull(input12Operator.getLhsInput());
		assertNull(input12Operator.getRhsInput());
		assertEquals("countrye", ((ScanOperator) input12Operator).getSuperAbstract().getName());
		assertEquals("countrye.codee = 'GB'", ((ScanOperator) input12Operator).getReconcilingExpression().getExpression());
		assertEquals("and", ((ScanOperator) input12Operator).getAndOr());

		assertNotNull(input12Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input12Operator.getDataSource());

		assertEquals(1, ((ScanOperator) input12Operator).getPredicates().size());
		Predicate predicate3 = ((ScanOperator) input12Operator).getPredicates().iterator().next();
		assertEquals("codee", predicate3.getSuperLexical1().getName());
		assertEquals("countrye", predicate3.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate3.getOperator());
		assertEquals("'GB'", predicate3.getLiteral2());
		assertEquals("and", predicate3.getAndOr());
		assertNull(predicate3.getLiteral1());
		assertNull(predicate3.getSuperLexical2());

		assertNotNull(input12Operator.getResultType());
		ResultType resultType4 = input12Operator.getResultType();
		assertEquals(6, resultType4.getResultFields().size());
		String[] expectedResultFieldNamesArray4 = { "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione" };
		DataType[] expectedResultFieldTypesArray4 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT,
				DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray4 = { "namee", "codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray4 = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray4 = new String[6];
		DataType[] actualResultFieldTypesArray4 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray4 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray4 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields4 = resultType4.getResultFields();
		Set<String> resultFieldNames4 = resultFields4.keySet();
		for (String resultFieldName : resultFieldNames4) {
			actualResultFieldNamesArray4[i] = resultFieldName;
			actualResultFieldTypesArray4[i] = resultFields4.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray4[i] = resultFields4.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields4.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray4[i] = ((SuperLexical) resultFields4.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray4, actualResultFieldNamesArray4);
		assertArrayEquals(expectedResultFieldTypesArray4, actualResultFieldTypesArray4);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray4, actualCanonicalModelConstructNamesArray4);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray4, actualParentCanonicalModelConstructNamesArray4);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	//@Test
	public void testTranslateAstIntoQuerySelectStarFromJoinJoinWhereOrQueryOneSource() {
		String selectStarFromJoinJoinWhereOrQuery = "Select * from citye, countrye, borderse where citye.countrye = countrye.codee and countrye.codee = borderse.country1e and (countrye.codee = 'GB' or countrye.codee = 'D')";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectStarFromJoinJoinWhereOrQuery);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectStarFromJoinJoinWhereOrQueryAst = parser.parseSQL(selectStarFromJoinJoinWhereOrQuery);
		logger.debug("selectStarFromJoinJoinWhereOrQueryAst: " + selectStarFromJoinJoinWhereOrQueryAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectStarFromJoinJoinWhereOrQuery, selectStarFromJoinJoinWhereOrQueryAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(15, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals(
				"citye.namee, citye.countrye, citye.provincee, citye.populatione, citye.longitudee, citye.latitudee, countrye.namee, countrye.codee, countrye.capitale, countrye.provincee, countrye.areae, countrye.populatione, borderse.country1e, borderse.country2e, borderse.lengthe",
				((ReduceOperator) rootOperator).getReconcilingExpression().getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[15];
		String[] superAbstractNamesArray = new String[15];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee", "codee",
				"capitale", "provincee", "areae", "populatione", "country1e", "country2e", "lengthe" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "borderse", "borderse", "borderse" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[15];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione",
				"citye.longitudee", "citye.latitudee", "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee",
				"countrye.areae", "countrye.populatione", "borderse.country1e", "borderse.country2e", "borderse.lengthe" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType0 = rootOperator.getResultType();
		assertEquals(15, resultType0.getResultFields().size());
		String[] expectedResultFieldNamesArray0 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee", "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione", "borderse.country1e", "borderse.country2e", "borderse.lengthe" };
		DataType[] expectedResultFieldTypesArray0 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER,
				DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray0 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione", "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray0 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye", "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray0 = new String[15];
		DataType[] actualResultFieldTypesArray0 = new DataType[15];
		String[] actualCanonicalModelConstructNamesArray0 = new String[15];
		String[] actualParentCanonicalModelConstructNamesArray0 = new String[15];

		i = 0;
		Map<String, ResultField> resultFields0 = resultType0.getResultFields();
		Set<String> resultFieldNames0 = resultFields0.keySet();
		for (String resultFieldName : resultFieldNames0) {
			actualResultFieldNamesArray0[i] = resultFieldName;
			actualResultFieldTypesArray0[i] = resultFields0.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultFields0.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields0.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultFields0.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray0, actualResultFieldNamesArray0);
		assertArrayEquals(expectedResultFieldTypesArray0, actualResultFieldTypesArray0);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray0, actualCanonicalModelConstructNamesArray0);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray0, actualParentCanonicalModelConstructNamesArray0);

		MappingOperator input0Operator = rootOperator.getLhsInput();

		isInstanceOf(JoinOperator.class, input0Operator);
		assertNull(input0Operator.getVariableName());
		assertNotNull(((JoinOperator) input0Operator).getReconcilingExpression());
		assertEquals("countrye.codee = borderse.country1e", ((JoinOperator) input0Operator).getReconcilingExpression().getExpression());
		assertNotNull(input0Operator.getLhsInput());
		assertNotNull(input0Operator.getRhsInput());
		assertEquals(input0Operator.getInput(), input0Operator.getLhsInput());

		assertNotNull(input0Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input0Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input0Operator).getPredicates().size());
		Predicate predicate = ((JoinOperator) input0Operator).getPredicates().iterator().next();
		assertEquals("codee", predicate.getSuperLexical1().getName());
		assertEquals("countrye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate.getOperator());
		assertEquals("country1e", predicate.getSuperLexical2().getName());
		assertEquals("borderse", predicate.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate.getLiteral1());
		assertNull(predicate.getLiteral2());

		assertNotNull(rootOperator.getResultType());
		ResultType resultType = rootOperator.getResultType();
		assertEquals(15, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee", "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione", "borderse.country1e", "borderse.country2e", "borderse.lengthe" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER,
				DataType.STRING, DataType.STRING, DataType.FLOAT, };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione", "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye", "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray = new String[15];
		DataType[] actualResultFieldTypesArray = new DataType[15];
		String[] actualCanonicalModelConstructNamesArray = new String[15];
		String[] actualParentCanonicalModelConstructNamesArray = new String[15];

		i = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[i] = resultFieldName;
			actualResultFieldTypesArray[i] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input1Operator = input0Operator.getLhsInput();
		isInstanceOf(JoinOperator.class, input1Operator);
		assertNotNull(input1Operator.getVariableName());
		assertEquals("countrye", input1Operator.getVariableName());
		assertNotNull(((JoinOperator) input1Operator).getReconcilingExpression());
		assertEquals("citye.countrye = countrye.codee", ((JoinOperator) input1Operator).getReconcilingExpression().getExpression());
		assertNotNull(input1Operator.getLhsInput());
		assertNotNull(input1Operator.getRhsInput());
		assertEquals(input1Operator.getInput(), input1Operator.getLhsInput());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input1Operator).getPredicates().size());
		Predicate predicate1 = ((JoinOperator) input1Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate1.getSuperLexical1().getName());
		assertEquals("citye", predicate1.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate1.getOperator());
		assertEquals("codee", predicate1.getSuperLexical2().getName());
		assertEquals("countrye", predicate1.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate1.getLiteral1());
		assertNull(predicate1.getLiteral2());

		assertNotNull(input1Operator.getResultType());
		ResultType resultType1 = input1Operator.getResultType();
		assertEquals(12, resultType1.getResultFields().size());
		String[] expectedResultFieldNamesArray1 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee", "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione" };
		DataType[] expectedResultFieldTypesArray1 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray1 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray1 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray1 = new String[12];
		DataType[] actualResultFieldTypesArray1 = new DataType[12];
		String[] actualCanonicalModelConstructNamesArray1 = new String[12];
		String[] actualParentCanonicalModelConstructNamesArray1 = new String[12];

		i = 0;
		Map<String, ResultField> resultFields1 = resultType1.getResultFields();
		Set<String> resultFieldNames1 = resultFields1.keySet();
		for (String resultFieldName : resultFieldNames1) {
			actualResultFieldNamesArray1[i] = resultFieldName;
			actualResultFieldTypesArray1[i] = resultFields1.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray1[i] = resultFields1.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields1.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray1[i] = ((SuperLexical) resultFields1.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray1, actualResultFieldNamesArray1);
		assertArrayEquals(expectedResultFieldTypesArray1, actualResultFieldTypesArray1);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray1, actualCanonicalModelConstructNamesArray1);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray1, actualParentCanonicalModelConstructNamesArray1);

		MappingOperator input2Operator = input0Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input2Operator);
		assertEquals("borderse", input2Operator.getVariableName());
		assertNull(input2Operator.getLhsInput());
		assertNull(input2Operator.getRhsInput());
		assertEquals("borderse", ((ScanOperator) input2Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input2Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input2Operator).getPredicates().size());

		assertNotNull(input2Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input2Operator.getDataSource());

		assertNotNull(input2Operator.getResultType());
		ResultType resultType2 = input2Operator.getResultType();
		assertEquals(3, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "borderse.country1e", "borderse.country2e", "borderse.lengthe" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray2 = new String[3];
		DataType[] actualResultFieldTypesArray2 = new DataType[3];
		String[] actualCanonicalModelConstructNamesArray2 = new String[3];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[3];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);

		MappingOperator input11Operator = input1Operator.getLhsInput();
		isInstanceOf(ScanOperator.class, input11Operator);
		assertEquals("citye", input11Operator.getVariableName());
		assertNull(input11Operator.getLhsInput());
		assertNull(input11Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input11Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input11Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input11Operator).getPredicates().size());

		assertNotNull(input11Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input11Operator.getDataSource());

		assertNotNull(input11Operator.getResultType());
		ResultType resultType3 = input11Operator.getResultType();
		assertEquals(6, resultType3.getResultFields().size());
		String[] expectedResultFieldNamesArray3 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee" };
		DataType[] expectedResultFieldTypesArray3 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray3 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray3 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray3 = new String[6];
		DataType[] actualResultFieldTypesArray3 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray3 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray3 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields3 = resultType3.getResultFields();
		Set<String> resultFieldNames3 = resultFields3.keySet();
		for (String resultFieldName : resultFieldNames3) {
			actualResultFieldNamesArray3[i] = resultFieldName;
			actualResultFieldTypesArray3[i] = resultFields3.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray3[i] = resultFields3.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields3.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray3[i] = ((SuperLexical) resultFields3.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray3, actualResultFieldNamesArray3);
		assertArrayEquals(expectedResultFieldTypesArray3, actualResultFieldTypesArray3);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray3, actualCanonicalModelConstructNamesArray3);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray3, actualParentCanonicalModelConstructNamesArray3);

		MappingOperator input12Operator = input1Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input12Operator);
		assertEquals("countrye", input12Operator.getVariableName());
		assertNull(input12Operator.getLhsInput());
		assertNull(input12Operator.getRhsInput());
		assertEquals("countrye", ((ScanOperator) input12Operator).getSuperAbstract().getName());
		assertEquals("countrye.codee = 'GB' or countrye.codee = 'D'", ((ScanOperator) input12Operator).getReconcilingExpression().getExpression());
		assertEquals("and", ((ScanOperator) input12Operator).getAndOr());

		assertNotNull(input12Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input12Operator.getDataSource());

		assertEquals(2, ((ScanOperator) input12Operator).getPredicates().size());

		Set<Predicate> predicates = ((ScanOperator) input12Operator).getPredicates();

		int k = 0;

		for (Predicate predicate2 : predicates) {
			if (k == 0) {
				//Predicate predicate2 = ((ScanOperator) input12Operator).getPredicates().get(0);
				assertEquals("codee", predicate2.getSuperLexical1().getName());
				assertEquals("countrye", predicate2.getSuperLexical1().getParentSuperAbstract().getName());
				assertEquals("=", predicate2.getOperator());
				assertEquals("'GB'", predicate2.getLiteral2());
				assertEquals("and", predicate2.getAndOr());
				assertNull(predicate2.getLiteral1());
				assertNull(predicate2.getSuperLexical2());
			} else if (k == 1) {
				//Predicate predicate3 = ((ScanOperator) input12Operator).getPredicates().get(1);
				assertEquals("codee", predicate2.getSuperLexical1().getName());
				assertEquals("countrye", predicate2.getSuperLexical1().getParentSuperAbstract().getName());
				assertEquals("=", predicate2.getOperator());
				assertEquals("'D'", predicate2.getLiteral2());
				assertEquals("or", predicate2.getAndOr());
				assertNull(predicate2.getLiteral1());
				assertNull(predicate2.getSuperLexical2());
			}
			k++;
		}

		assertNotNull(input12Operator.getResultType());
		ResultType resultType4 = input12Operator.getResultType();
		assertEquals(6, resultType4.getResultFields().size());
		String[] expectedResultFieldNamesArray4 = { "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione" };
		DataType[] expectedResultFieldTypesArray4 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT,
				DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray4 = { "namee", "codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray4 = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray4 = new String[6];
		DataType[] actualResultFieldTypesArray4 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray4 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray4 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields4 = resultType4.getResultFields();
		Set<String> resultFieldNames4 = resultFields4.keySet();
		for (String resultFieldName : resultFieldNames4) {
			actualResultFieldNamesArray4[i] = resultFieldName;
			actualResultFieldTypesArray4[i] = resultFields4.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray4[i] = resultFields4.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields4.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray4[i] = ((SuperLexical) resultFields4.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray4, actualResultFieldNamesArray4);
		assertArrayEquals(expectedResultFieldTypesArray4, actualResultFieldTypesArray4);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray4, actualCanonicalModelConstructNamesArray4);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray4, actualParentCanonicalModelConstructNamesArray4);
	}

	//---------------------------------------------------------------------

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectSuperLexicalsFromJoinJoinQueryOneSource() {
		String selectSuperLexicalsFromJoinJoinQuery = "Select citye.namee, citye.countrye, citye.provincee, countrye.namee, countrye.capitale, borderse.country2e from citye, countrye, borderse where citye.countrye = countrye.codee and countrye.codee = borderse.country1e";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectSuperLexicalsFromJoinJoinQuery);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectSuperLexicalsFromJoinJoinQueryAst = parser.parseSQL(selectSuperLexicalsFromJoinJoinQuery);
		logger.debug("selectSuperLexicalsFromJoinJoinQueryAst: " + selectSuperLexicalsFromJoinJoinQueryAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectSuperLexicalsFromJoinJoinQuery, selectSuperLexicalsFromJoinJoinQueryAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(6, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals("citye.namee, citye.countrye, citye.provincee, countrye.namee, countrye.capitale, borderse.country2e",
				((ReduceOperator) rootOperator).getReconcilingExpression().getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[6];
		String[] superAbstractNamesArray = new String[6];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "namee", "capitale", "country2e" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "countrye", "countrye", "borderse" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[6];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "countrye.namee",
				"countrye.capitale", "borderse.country2e" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType = rootOperator.getResultType();
		assertEquals(6, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "countrye.namee", "countrye.capitale",
				"borderse.country2e" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING,
				DataType.STRING };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "namee", "capitale", "country2e" };
		String[] expectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "countrye", "countrye", "borderse" };

		String[] actualResultFieldNamesArray = new String[6];
		DataType[] actualResultFieldTypesArray = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray = new String[6];

		int j = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[j] = resultFieldName;
			actualResultFieldTypesArray[j] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[j] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[j] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			j++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(expectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input0Operator = rootOperator.getLhsInput();
		isInstanceOf(JoinOperator.class, input0Operator);
		assertNull(input0Operator.getVariableName());
		assertNotNull(((JoinOperator) input0Operator).getReconcilingExpression());
		assertEquals("countrye.codee = borderse.country1e", ((JoinOperator) input0Operator).getReconcilingExpression().getExpression());
		assertNotNull(input0Operator.getLhsInput());
		assertNotNull(input0Operator.getRhsInput());
		assertEquals(input0Operator.getInput(), input0Operator.getLhsInput());

		assertNotNull(input0Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input0Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input0Operator).getPredicates().size());
		Predicate predicate = ((JoinOperator) input0Operator).getPredicates().iterator().next();
		assertEquals("codee", predicate.getSuperLexical1().getName());
		assertEquals("countrye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate.getOperator());
		assertEquals("country1e", predicate.getSuperLexical2().getName());
		assertEquals("borderse", predicate.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate.getLiteral1());
		assertNull(predicate.getLiteral2());

		assertNotNull(input0Operator.getResultType());
		ResultType resultType0 = input0Operator.getResultType();
		assertEquals(15, resultType0.getResultFields().size());
		String[] expectedResultFieldNamesArray0 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee", "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione", "borderse.country1e", "borderse.country2e", "borderse.lengthe" };
		DataType[] expectedResultFieldTypesArray0 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER,
				DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray0 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione", "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray0 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye", "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray0 = new String[15];
		DataType[] actualResultFieldTypesArray0 = new DataType[15];
		String[] actualCanonicalModelConstructNamesArray0 = new String[15];
		String[] actualParentCanonicalModelConstructNamesArray0 = new String[15];

		i = 0;
		Map<String, ResultField> resultFields0 = resultType0.getResultFields();
		Set<String> resultFieldNames0 = resultFields0.keySet();
		for (String resultFieldName : resultFieldNames0) {
			actualResultFieldNamesArray0[i] = resultFieldName;
			actualResultFieldTypesArray0[i] = resultFields0.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultFields0.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields0.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultFields0.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray0, actualResultFieldNamesArray0);
		assertArrayEquals(expectedResultFieldTypesArray0, actualResultFieldTypesArray0);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray0, actualCanonicalModelConstructNamesArray0);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray0, actualParentCanonicalModelConstructNamesArray0);

		MappingOperator input1Operator = input0Operator.getLhsInput();
		isInstanceOf(JoinOperator.class, input1Operator);
		assertNotNull(input1Operator.getVariableName());
		assertEquals("countrye", input1Operator.getVariableName());
		assertNotNull(((JoinOperator) input1Operator).getReconcilingExpression());
		assertEquals("citye.countrye = countrye.codee", ((JoinOperator) input1Operator).getReconcilingExpression().getExpression());
		assertNotNull(input1Operator.getLhsInput());
		assertNotNull(input1Operator.getRhsInput());
		assertEquals(input1Operator.getInput(), input1Operator.getLhsInput());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input1Operator).getPredicates().size());
		Predicate predicate1 = ((JoinOperator) input1Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate1.getSuperLexical1().getName());
		assertEquals("citye", predicate1.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate1.getOperator());
		assertEquals("codee", predicate1.getSuperLexical2().getName());
		assertEquals("countrye", predicate1.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate1.getLiteral1());
		assertNull(predicate1.getLiteral2());

		assertNotNull(input1Operator.getResultType());
		ResultType resultType1 = input1Operator.getResultType();
		assertEquals(12, resultType1.getResultFields().size());
		String[] expectedResultFieldNamesArray1 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee", "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione" };
		DataType[] expectedResultFieldTypesArray1 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray1 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray1 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray1 = new String[12];
		DataType[] actualResultFieldTypesArray1 = new DataType[12];
		String[] actualCanonicalModelConstructNamesArray1 = new String[12];
		String[] actualParentCanonicalModelConstructNamesArray1 = new String[12];

		i = 0;
		Map<String, ResultField> resultFields1 = resultType1.getResultFields();
		Set<String> resultFieldNames1 = resultFields1.keySet();
		for (String resultFieldName : resultFieldNames1) {
			actualResultFieldNamesArray1[i] = resultFieldName;
			actualResultFieldTypesArray1[i] = resultFields1.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray1[i] = resultFields1.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields1.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray1[i] = ((SuperLexical) resultFields1.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray1, actualResultFieldNamesArray1);
		assertArrayEquals(expectedResultFieldTypesArray1, actualResultFieldTypesArray1);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray1, actualCanonicalModelConstructNamesArray1);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray1, actualParentCanonicalModelConstructNamesArray1);

		MappingOperator input2Operator = input0Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input2Operator);
		assertEquals("borderse", input2Operator.getVariableName());
		assertNull(input2Operator.getLhsInput());
		assertNull(input2Operator.getRhsInput());
		assertEquals("borderse", ((ScanOperator) input2Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input2Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input2Operator).getPredicates().size());

		assertNotNull(input2Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input2Operator.getDataSource());

		assertNotNull(input2Operator.getResultType());
		ResultType resultType2 = input2Operator.getResultType();
		assertEquals(3, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "borderse.country1e", "borderse.country2e", "borderse.lengthe" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray2 = new String[3];
		DataType[] actualResultFieldTypesArray2 = new DataType[3];
		String[] actualCanonicalModelConstructNamesArray2 = new String[3];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[3];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);

		MappingOperator input11Operator = input1Operator.getLhsInput();
		isInstanceOf(ScanOperator.class, input11Operator);
		assertEquals("citye", input11Operator.getVariableName());
		assertNull(input11Operator.getLhsInput());
		assertNull(input11Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input11Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input11Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input11Operator).getPredicates().size());

		assertNotNull(input11Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input11Operator.getDataSource());

		assertNotNull(input11Operator.getResultType());
		ResultType resultType3 = input11Operator.getResultType();
		assertEquals(6, resultType3.getResultFields().size());
		String[] expectedResultFieldNamesArray3 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee" };
		DataType[] expectedResultFieldTypesArray3 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray3 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray3 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray3 = new String[6];
		DataType[] actualResultFieldTypesArray3 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray3 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray3 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields3 = resultType3.getResultFields();
		Set<String> resultFieldNames3 = resultFields3.keySet();
		for (String resultFieldName : resultFieldNames3) {
			actualResultFieldNamesArray3[i] = resultFieldName;
			actualResultFieldTypesArray3[i] = resultFields3.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray3[i] = resultFields3.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields3.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray3[i] = ((SuperLexical) resultFields3.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray3, actualResultFieldNamesArray3);
		assertArrayEquals(expectedResultFieldTypesArray3, actualResultFieldTypesArray3);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray3, actualCanonicalModelConstructNamesArray3);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray3, actualParentCanonicalModelConstructNamesArray3);

		MappingOperator input12Operator = input1Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input12Operator);
		assertEquals("countrye", input12Operator.getVariableName());
		assertNull(input12Operator.getLhsInput());
		assertNull(input12Operator.getRhsInput());
		assertEquals("countrye", ((ScanOperator) input12Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input12Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input12Operator).getPredicates().size());

		assertNotNull(input12Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input12Operator.getDataSource());

		assertNotNull(input12Operator.getResultType());
		ResultType resultType4 = input12Operator.getResultType();
		assertEquals(6, resultType4.getResultFields().size());
		String[] expectedResultFieldNamesArray4 = { "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione" };
		DataType[] expectedResultFieldTypesArray4 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT,
				DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray4 = { "namee", "codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray4 = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray4 = new String[6];
		DataType[] actualResultFieldTypesArray4 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray4 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray4 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields4 = resultType4.getResultFields();
		Set<String> resultFieldNames4 = resultFields4.keySet();
		for (String resultFieldName : resultFieldNames4) {
			actualResultFieldNamesArray4[i] = resultFieldName;
			actualResultFieldTypesArray4[i] = resultFields4.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray4[i] = resultFields4.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields4.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray4[i] = ((SuperLexical) resultFields4.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray4, actualResultFieldNamesArray4);
		assertArrayEquals(expectedResultFieldTypesArray4, actualResultFieldTypesArray4);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray4, actualCanonicalModelConstructNamesArray4);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray4, actualParentCanonicalModelConstructNamesArray4);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectSuperLexicalsFromJoinJoinWhereQueryOneSource() {
		String selectSuperLexicalsFromJoinJoinWhereQuery = "Select citye.namee, citye.countrye, citye.provincee, countrye.namee, countrye.capitale, borderse.country2e from citye, countrye, borderse where citye.countrye = countrye.codee and countrye.codee = borderse.country1e and countrye.codee = 'GB'";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectSuperLexicalsFromJoinJoinWhereQuery);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectSuperLexicalsFromJoinJoinWhereQueryAst = parser.parseSQL(selectSuperLexicalsFromJoinJoinWhereQuery);
		logger.debug("selectSuperLexicalsFromJoinJoinWhereQueryAst: " + selectSuperLexicalsFromJoinJoinWhereQueryAst.toStringTree());
		query = globalTranslator
				.translateAstIntoQuery(query, selectSuperLexicalsFromJoinJoinWhereQuery, selectSuperLexicalsFromJoinJoinWhereQueryAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(6, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals("citye.namee, citye.countrye, citye.provincee, countrye.namee, countrye.capitale, borderse.country2e",
				((ReduceOperator) rootOperator).getReconcilingExpression().getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[6];
		String[] superAbstractNamesArray = new String[6];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "namee", "capitale", "country2e" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "countrye", "countrye", "borderse" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[6];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "countrye.namee",
				"countrye.capitale", "borderse.country2e" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType = rootOperator.getResultType();
		assertEquals(6, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "countrye.namee", "countrye.capitale",
				"borderse.country2e" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING,
				DataType.STRING };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "namee", "capitale", "country2e" };
		String[] expectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "countrye", "countrye", "borderse" };

		String[] actualResultFieldNamesArray = new String[6];
		DataType[] actualResultFieldTypesArray = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray = new String[6];

		int j = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[j] = resultFieldName;
			actualResultFieldTypesArray[j] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[j] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[j] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			j++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(expectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input0Operator = rootOperator.getLhsInput();
		isInstanceOf(JoinOperator.class, input0Operator);
		assertNull(input0Operator.getVariableName());
		assertNotNull(((JoinOperator) input0Operator).getReconcilingExpression());
		assertEquals("countrye.codee = borderse.country1e", ((JoinOperator) input0Operator).getReconcilingExpression().getExpression());
		assertNotNull(input0Operator.getLhsInput());
		assertNotNull(input0Operator.getRhsInput());
		assertEquals(input0Operator.getInput(), input0Operator.getLhsInput());

		assertNotNull(input0Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input0Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input0Operator).getPredicates().size());
		Predicate predicate0 = ((JoinOperator) input0Operator).getPredicates().iterator().next();
		assertEquals("codee", predicate0.getSuperLexical1().getName());
		assertEquals("countrye", predicate0.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate0.getOperator());
		assertEquals("country1e", predicate0.getSuperLexical2().getName());
		assertEquals("borderse", predicate0.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate0.getLiteral1());
		assertNull(predicate0.getLiteral2());

		assertNotNull(input0Operator.getResultType());
		ResultType resultType0 = input0Operator.getResultType();
		assertEquals(15, resultType0.getResultFields().size());
		String[] expectedResultFieldNamesArray0 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee", "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione", "borderse.country1e", "borderse.country2e", "borderse.lengthe" };
		DataType[] expectedResultFieldTypesArray0 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER,
				DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray0 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione", "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray0 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye", "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray0 = new String[15];
		DataType[] actualResultFieldTypesArray0 = new DataType[15];
		String[] actualCanonicalModelConstructNamesArray0 = new String[15];
		String[] actualParentCanonicalModelConstructNamesArray0 = new String[15];

		i = 0;
		Map<String, ResultField> resultFields0 = resultType0.getResultFields();
		Set<String> resultFieldNames0 = resultFields0.keySet();
		for (String resultFieldName : resultFieldNames0) {
			actualResultFieldNamesArray0[i] = resultFieldName;
			actualResultFieldTypesArray0[i] = resultFields0.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultFields0.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields0.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultFields0.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray0, actualResultFieldNamesArray0);
		assertArrayEquals(expectedResultFieldTypesArray0, actualResultFieldTypesArray0);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray0, actualCanonicalModelConstructNamesArray0);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray0, actualParentCanonicalModelConstructNamesArray0);

		MappingOperator input1Operator = input0Operator.getLhsInput();
		isInstanceOf(JoinOperator.class, input1Operator);
		assertNotNull(input1Operator.getVariableName());
		assertEquals("countrye", input1Operator.getVariableName());
		assertNotNull(((JoinOperator) input1Operator).getReconcilingExpression());
		assertEquals("citye.countrye = countrye.codee", ((JoinOperator) input1Operator).getReconcilingExpression().getExpression());
		assertNotNull(input1Operator.getLhsInput());
		assertNotNull(input1Operator.getRhsInput());
		assertEquals(input1Operator.getInput(), input1Operator.getLhsInput());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input1Operator).getPredicates().size());
		Predicate predicate1 = ((JoinOperator) input1Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate1.getSuperLexical1().getName());
		assertEquals("citye", predicate1.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate1.getOperator());
		assertEquals("codee", predicate1.getSuperLexical2().getName());
		assertEquals("countrye", predicate1.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate1.getLiteral1());
		assertNull(predicate1.getLiteral2());

		assertNotNull(input1Operator.getResultType());
		ResultType resultType1 = input1Operator.getResultType();
		assertEquals(12, resultType1.getResultFields().size());
		String[] expectedResultFieldNamesArray1 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee", "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione" };
		DataType[] expectedResultFieldTypesArray1 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray1 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray1 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray1 = new String[12];
		DataType[] actualResultFieldTypesArray1 = new DataType[12];
		String[] actualCanonicalModelConstructNamesArray1 = new String[12];
		String[] actualParentCanonicalModelConstructNamesArray1 = new String[12];

		i = 0;
		Map<String, ResultField> resultFields1 = resultType1.getResultFields();
		Set<String> resultFieldNames1 = resultFields1.keySet();
		for (String resultFieldName : resultFieldNames1) {
			actualResultFieldNamesArray1[i] = resultFieldName;
			actualResultFieldTypesArray1[i] = resultFields1.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray1[i] = resultFields1.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields1.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray1[i] = ((SuperLexical) resultFields1.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray1, actualResultFieldNamesArray1);
		assertArrayEquals(expectedResultFieldTypesArray1, actualResultFieldTypesArray1);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray1, actualCanonicalModelConstructNamesArray1);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray1, actualParentCanonicalModelConstructNamesArray1);

		MappingOperator input2Operator = input0Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input2Operator);
		assertEquals("borderse", input2Operator.getVariableName());
		assertNull(input2Operator.getLhsInput());
		assertNull(input2Operator.getRhsInput());
		assertEquals("borderse", ((ScanOperator) input2Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input2Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input2Operator).getPredicates().size());

		assertNotNull(input2Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input2Operator.getDataSource());

		assertNotNull(input2Operator.getResultType());
		ResultType resultType2 = input2Operator.getResultType();
		assertEquals(3, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "borderse.country1e", "borderse.country2e", "borderse.lengthe" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray2 = new String[3];
		DataType[] actualResultFieldTypesArray2 = new DataType[3];
		String[] actualCanonicalModelConstructNamesArray2 = new String[3];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[3];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);

		MappingOperator input11Operator = input1Operator.getLhsInput();
		isInstanceOf(ScanOperator.class, input11Operator);
		assertEquals("citye", input11Operator.getVariableName());
		assertNull(input11Operator.getLhsInput());
		assertNull(input11Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input11Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input11Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input11Operator).getPredicates().size());

		assertNotNull(input11Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input11Operator.getDataSource());

		assertNotNull(input11Operator.getResultType());
		ResultType resultType3 = input11Operator.getResultType();
		assertEquals(6, resultType3.getResultFields().size());
		String[] expectedResultFieldNamesArray3 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee", };
		DataType[] expectedResultFieldTypesArray3 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray3 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray3 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray3 = new String[6];
		DataType[] actualResultFieldTypesArray3 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray3 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray3 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields3 = resultType3.getResultFields();
		Set<String> resultFieldNames3 = resultFields3.keySet();
		for (String resultFieldName : resultFieldNames3) {
			actualResultFieldNamesArray3[i] = resultFieldName;
			actualResultFieldTypesArray3[i] = resultFields3.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray3[i] = resultFields3.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields3.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray3[i] = ((SuperLexical) resultFields3.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray3, actualResultFieldNamesArray3);
		assertArrayEquals(expectedResultFieldTypesArray3, actualResultFieldTypesArray3);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray3, actualCanonicalModelConstructNamesArray3);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray3, actualParentCanonicalModelConstructNamesArray3);

		MappingOperator input12Operator = input1Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input12Operator);
		assertEquals("countrye", input12Operator.getVariableName());
		assertNull(input12Operator.getLhsInput());
		assertNull(input12Operator.getRhsInput());
		assertEquals("countrye", ((ScanOperator) input12Operator).getSuperAbstract().getName());
		assertEquals("countrye.codee = 'GB'", ((ScanOperator) input12Operator).getReconcilingExpression().getExpression());
		assertEquals("and", ((ScanOperator) input12Operator).getAndOr());

		assertNotNull(input12Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input12Operator.getDataSource());

		assertEquals(1, ((ScanOperator) input12Operator).getPredicates().size());
		Predicate predicate2 = ((ScanOperator) input12Operator).getPredicates().iterator().next();
		assertEquals("codee", predicate2.getSuperLexical1().getName());
		assertEquals("countrye", predicate2.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate2.getOperator());
		assertEquals("'GB'", predicate2.getLiteral2());
		assertEquals("and", predicate2.getAndOr());
		assertNull(predicate2.getLiteral1());
		assertNull(predicate2.getSuperLexical2());

		assertNotNull(input12Operator.getResultType());
		ResultType resultType4 = input12Operator.getResultType();
		assertEquals(6, resultType4.getResultFields().size());
		String[] expectedResultFieldNamesArray4 = { "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione" };
		DataType[] expectedResultFieldTypesArray4 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT,
				DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray4 = { "namee", "codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray4 = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray4 = new String[6];
		DataType[] actualResultFieldTypesArray4 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray4 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray4 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields4 = resultType4.getResultFields();
		Set<String> resultFieldNames4 = resultFields4.keySet();
		for (String resultFieldName : resultFieldNames4) {
			actualResultFieldNamesArray4[i] = resultFieldName;
			actualResultFieldTypesArray4[i] = resultFields4.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray4[i] = resultFields4.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields4.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray4[i] = ((SuperLexical) resultFields4.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray4, actualResultFieldNamesArray4);
		assertArrayEquals(expectedResultFieldTypesArray4, actualResultFieldTypesArray4);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray4, actualCanonicalModelConstructNamesArray4);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray4, actualParentCanonicalModelConstructNamesArray4);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectSuperLexicalsFromJoinJoinWhereAndQueryOneSource() {
		String selectSuperLexicalsFromJoinJoinWhereAndQuery = "Select citye.namee, citye.countrye, citye.provincee, countrye.namee, countrye.capitale, borderse.country2e from citye, countrye, borderse where citye.countrye = countrye.codee and countrye.codee = borderse.country1e and countrye.codee = 'GB' and citye.namee = 'Manchester'";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectSuperLexicalsFromJoinJoinWhereAndQuery);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectSuperLexicalsFromJoinJoinWhereAndQueryAst = parser.parseSQL(selectSuperLexicalsFromJoinJoinWhereAndQuery);
		logger.debug("selectSuperLexicalsFromJoinJoinWhereAndQueryAst: " + selectSuperLexicalsFromJoinJoinWhereAndQueryAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectSuperLexicalsFromJoinJoinWhereAndQuery,
				selectSuperLexicalsFromJoinJoinWhereAndQueryAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(6, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals("citye.namee, citye.countrye, citye.provincee, countrye.namee, countrye.capitale, borderse.country2e",
				((ReduceOperator) rootOperator).getReconcilingExpression().getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[6];
		String[] superAbstractNamesArray = new String[6];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "namee", "capitale", "country2e" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "countrye", "countrye", "borderse" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[6];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "countrye.namee",
				"countrye.capitale", "borderse.country2e" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType = rootOperator.getResultType();
		assertEquals(6, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "countrye.namee", "countrye.capitale",
				"borderse.country2e" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING,
				DataType.STRING };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "namee", "capitale", "country2e" };
		String[] expectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "countrye", "countrye", "borderse" };

		String[] actualResultFieldNamesArray = new String[6];
		DataType[] actualResultFieldTypesArray = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray = new String[6];

		int j = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[j] = resultFieldName;
			actualResultFieldTypesArray[j] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[j] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[j] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			j++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(expectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input0Operator = rootOperator.getLhsInput();
		isInstanceOf(JoinOperator.class, input0Operator);
		assertNull(input0Operator.getVariableName());
		assertNotNull(((JoinOperator) input0Operator).getReconcilingExpression());
		assertEquals("countrye.codee = borderse.country1e", ((JoinOperator) input0Operator).getReconcilingExpression().getExpression());
		assertNotNull(input0Operator.getLhsInput());
		assertNotNull(input0Operator.getRhsInput());
		assertEquals(input0Operator.getInput(), input0Operator.getLhsInput());

		assertNotNull(input0Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input0Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input0Operator).getPredicates().size());
		Predicate predicate0 = ((JoinOperator) input0Operator).getPredicates().iterator().next();
		assertEquals("codee", predicate0.getSuperLexical1().getName());
		assertEquals("countrye", predicate0.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate0.getOperator());
		assertEquals("country1e", predicate0.getSuperLexical2().getName());
		assertEquals("borderse", predicate0.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate0.getLiteral1());
		assertNull(predicate0.getLiteral2());

		assertNotNull(input0Operator.getResultType());
		ResultType resultType0 = input0Operator.getResultType();
		assertEquals(15, resultType0.getResultFields().size());
		String[] expectedResultFieldNamesArray0 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee", "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione", "borderse.country1e", "borderse.country2e", "borderse.lengthe" };
		DataType[] expectedResultFieldTypesArray0 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER,
				DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray0 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione", "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray0 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye", "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray0 = new String[15];
		DataType[] actualResultFieldTypesArray0 = new DataType[15];
		String[] actualCanonicalModelConstructNamesArray0 = new String[15];
		String[] actualParentCanonicalModelConstructNamesArray0 = new String[15];

		i = 0;
		Map<String, ResultField> resultFields0 = resultType0.getResultFields();
		Set<String> resultFieldNames0 = resultFields0.keySet();
		for (String resultFieldName : resultFieldNames0) {
			actualResultFieldNamesArray0[i] = resultFieldName;
			actualResultFieldTypesArray0[i] = resultFields0.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultFields0.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields0.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultFields0.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray0, actualResultFieldNamesArray0);
		assertArrayEquals(expectedResultFieldTypesArray0, actualResultFieldTypesArray0);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray0, actualCanonicalModelConstructNamesArray0);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray0, actualParentCanonicalModelConstructNamesArray0);

		MappingOperator input1Operator = input0Operator.getLhsInput();
		isInstanceOf(JoinOperator.class, input1Operator);
		assertNotNull(input1Operator.getVariableName());
		assertEquals("countrye", input1Operator.getVariableName());
		assertNotNull(((JoinOperator) input1Operator).getReconcilingExpression());
		assertEquals("citye.countrye = countrye.codee", ((JoinOperator) input1Operator).getReconcilingExpression().getExpression());
		assertNotNull(input1Operator.getLhsInput());
		assertNotNull(input1Operator.getRhsInput());
		assertEquals(input1Operator.getInput(), input1Operator.getLhsInput());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input1Operator).getPredicates().size());
		Predicate predicate1 = ((JoinOperator) input1Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate1.getSuperLexical1().getName());
		assertEquals("citye", predicate1.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate1.getOperator());
		assertEquals("codee", predicate1.getSuperLexical2().getName());
		assertEquals("countrye", predicate1.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate1.getLiteral1());
		assertNull(predicate1.getLiteral2());

		assertNotNull(input1Operator.getResultType());
		ResultType resultType1 = input1Operator.getResultType();
		assertEquals(12, resultType1.getResultFields().size());
		String[] expectedResultFieldNamesArray1 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee", "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione" };
		DataType[] expectedResultFieldTypesArray1 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray1 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray1 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray1 = new String[12];
		DataType[] actualResultFieldTypesArray1 = new DataType[12];
		String[] actualCanonicalModelConstructNamesArray1 = new String[12];
		String[] actualParentCanonicalModelConstructNamesArray1 = new String[12];

		i = 0;
		Map<String, ResultField> resultFields1 = resultType1.getResultFields();
		Set<String> resultFieldNames1 = resultFields1.keySet();
		for (String resultFieldName : resultFieldNames1) {
			actualResultFieldNamesArray1[i] = resultFieldName;
			actualResultFieldTypesArray1[i] = resultFields1.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray1[i] = resultFields1.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields1.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray1[i] = ((SuperLexical) resultFields1.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray1, actualResultFieldNamesArray1);
		assertArrayEquals(expectedResultFieldTypesArray1, actualResultFieldTypesArray1);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray1, actualCanonicalModelConstructNamesArray1);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray1, actualParentCanonicalModelConstructNamesArray1);

		MappingOperator input2Operator = input0Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input2Operator);
		assertEquals("borderse", input2Operator.getVariableName());
		assertNull(input2Operator.getLhsInput());
		assertNull(input2Operator.getRhsInput());
		assertEquals("borderse", ((ScanOperator) input2Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input2Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input2Operator).getPredicates().size());

		assertNotNull(input2Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input2Operator.getDataSource());

		assertNotNull(input2Operator.getResultType());
		ResultType resultType2 = input2Operator.getResultType();
		assertEquals(3, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "borderse.country1e", "borderse.country2e", "borderse.lengthe" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray2 = new String[3];
		DataType[] actualResultFieldTypesArray2 = new DataType[3];
		String[] actualCanonicalModelConstructNamesArray2 = new String[3];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[3];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);

		MappingOperator input11Operator = input1Operator.getLhsInput();
		isInstanceOf(ScanOperator.class, input11Operator);
		assertEquals("citye", input11Operator.getVariableName());
		assertNull(input11Operator.getLhsInput());
		assertNull(input11Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input11Operator).getSuperAbstract().getName());
		assertEquals("citye.namee = 'Manchester'", ((ScanOperator) input11Operator).getReconcilingExpression().getExpression());
		assertEquals("and", ((ScanOperator) input11Operator).getAndOr());

		assertNotNull(input11Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input11Operator.getDataSource());

		assertEquals(1, ((ScanOperator) input11Operator).getPredicates().size());
		Predicate predicate2 = ((ScanOperator) input11Operator).getPredicates().iterator().next();
		assertEquals("namee", predicate2.getSuperLexical1().getName());
		assertEquals("citye", predicate2.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate2.getOperator());
		assertEquals("'Manchester'", predicate2.getLiteral2());
		assertEquals("and", predicate2.getAndOr());
		assertNull(predicate2.getLiteral1());
		assertNull(predicate2.getSuperLexical2());

		assertNotNull(input11Operator.getResultType());
		ResultType resultType3 = input11Operator.getResultType();
		assertEquals(6, resultType3.getResultFields().size());
		String[] expectedResultFieldNamesArray3 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee", };
		DataType[] expectedResultFieldTypesArray3 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray3 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray3 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray3 = new String[6];
		DataType[] actualResultFieldTypesArray3 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray3 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray3 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields3 = resultType3.getResultFields();
		Set<String> resultFieldNames3 = resultFields3.keySet();
		for (String resultFieldName : resultFieldNames3) {
			actualResultFieldNamesArray3[i] = resultFieldName;
			actualResultFieldTypesArray3[i] = resultFields3.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray3[i] = resultFields3.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields3.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray3[i] = ((SuperLexical) resultFields3.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray3, actualResultFieldNamesArray3);
		assertArrayEquals(expectedResultFieldTypesArray3, actualResultFieldTypesArray3);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray3, actualCanonicalModelConstructNamesArray3);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray3, actualParentCanonicalModelConstructNamesArray3);

		MappingOperator input12Operator = input1Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input12Operator);
		assertEquals("countrye", input12Operator.getVariableName());
		assertNull(input12Operator.getLhsInput());
		assertNull(input12Operator.getRhsInput());
		assertEquals("countrye", ((ScanOperator) input12Operator).getSuperAbstract().getName());
		assertEquals("countrye.codee = 'GB'", ((ScanOperator) input12Operator).getReconcilingExpression().getExpression());
		assertEquals("and", ((ScanOperator) input12Operator).getAndOr());

		assertNotNull(input12Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input12Operator.getDataSource());

		assertEquals(1, ((ScanOperator) input12Operator).getPredicates().size());
		Predicate predicate3 = ((ScanOperator) input12Operator).getPredicates().iterator().next();
		assertEquals("codee", predicate3.getSuperLexical1().getName());
		assertEquals("countrye", predicate3.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate3.getOperator());
		assertEquals("'GB'", predicate3.getLiteral2());
		assertEquals("and", predicate3.getAndOr());
		assertNull(predicate3.getLiteral1());
		assertNull(predicate3.getSuperLexical2());

		assertNotNull(input12Operator.getResultType());
		ResultType resultType4 = input12Operator.getResultType();
		assertEquals(6, resultType4.getResultFields().size());
		String[] expectedResultFieldNamesArray4 = { "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione" };
		DataType[] expectedResultFieldTypesArray4 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT,
				DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray4 = { "namee", "codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray4 = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray4 = new String[6];
		DataType[] actualResultFieldTypesArray4 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray4 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray4 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields4 = resultType4.getResultFields();
		Set<String> resultFieldNames4 = resultFields4.keySet();
		for (String resultFieldName : resultFieldNames4) {
			actualResultFieldNamesArray4[i] = resultFieldName;
			actualResultFieldTypesArray4[i] = resultFields4.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray4[i] = resultFields4.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields4.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray4[i] = ((SuperLexical) resultFields4.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray4, actualResultFieldNamesArray4);
		assertArrayEquals(expectedResultFieldTypesArray4, actualResultFieldTypesArray4);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray4, actualCanonicalModelConstructNamesArray4);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray4, actualParentCanonicalModelConstructNamesArray4);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	//@Test
	public void testTranslateAstIntoQuerySelectSuperLexicalsFromJoinJoinWhereOrQueryOneSource() {
		String selectSuperLexicalsFromJoinJoinWhereOrQuery = "Select citye.namee, citye.countrye, citye.provincee, countrye.namee, countrye.capitale, borderse.country2e from citye, countrye, borderse where citye.countrye = countrye.codee and countrye.codee = borderse.country1e and (countrye.codee = 'GB' or countrye.codee = 'D')";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectSuperLexicalsFromJoinJoinWhereOrQuery);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectSuperLexicalsFromJoinJoinWhereOrQueryAst = parser.parseSQL(selectSuperLexicalsFromJoinJoinWhereOrQuery);
		logger.debug("selectSuperLexicalsFromJoinJoinWhereOrQueryAst: " + selectSuperLexicalsFromJoinJoinWhereOrQueryAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectSuperLexicalsFromJoinJoinWhereOrQuery,
				selectSuperLexicalsFromJoinJoinWhereOrQueryAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(6, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals("citye.namee, citye.countrye, citye.provincee, countrye.namee, countrye.capitale, borderse.country2e",
				((ReduceOperator) rootOperator).getReconcilingExpression().getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[6];
		String[] superAbstractNamesArray = new String[6];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "namee", "capitale", "country2e" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "countrye", "countrye", "borderse" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[6];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "countrye.namee",
				"countrye.capitale", "borderse.country2e" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType = rootOperator.getResultType();
		assertEquals(6, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "countrye.namee", "countrye.capitale",
				"borderse.country2e" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING,
				DataType.STRING };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "namee", "capitale", "country2e" };
		String[] expectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "countrye", "countrye", "borderse" };

		String[] actualResultFieldNamesArray = new String[6];
		DataType[] actualResultFieldTypesArray = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray = new String[6];

		int j = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[j] = resultFieldName;
			actualResultFieldTypesArray[j] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[j] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[j] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			j++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(expectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input0Operator = rootOperator.getLhsInput();
		isInstanceOf(JoinOperator.class, input0Operator);
		assertNull(input0Operator.getVariableName());
		assertNotNull(((JoinOperator) input0Operator).getReconcilingExpression());
		assertEquals("countrye.codee = borderse.country1e", ((JoinOperator) input0Operator).getReconcilingExpression().getExpression());
		assertNotNull(input0Operator.getLhsInput());
		assertNotNull(input0Operator.getRhsInput());
		assertEquals(input0Operator.getInput(), input0Operator.getLhsInput());

		assertNotNull(input0Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input0Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input0Operator).getPredicates().size());
		Predicate predicate0 = ((JoinOperator) input0Operator).getPredicates().iterator().next();
		assertEquals("codee", predicate0.getSuperLexical1().getName());
		assertEquals("countrye", predicate0.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate0.getOperator());
		assertEquals("country1e", predicate0.getSuperLexical2().getName());
		assertEquals("borderse", predicate0.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate0.getLiteral1());
		assertNull(predicate0.getLiteral2());

		assertNotNull(input0Operator.getResultType());
		ResultType resultType0 = input0Operator.getResultType();
		assertEquals(15, resultType0.getResultFields().size());
		String[] expectedResultFieldNamesArray0 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee", "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione", "borderse.country1e", "borderse.country2e", "borderse.lengthe" };
		DataType[] expectedResultFieldTypesArray0 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER,
				DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray0 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione", "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray0 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye", "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray0 = new String[15];
		DataType[] actualResultFieldTypesArray0 = new DataType[15];
		String[] actualCanonicalModelConstructNamesArray0 = new String[15];
		String[] actualParentCanonicalModelConstructNamesArray0 = new String[15];

		i = 0;
		Map<String, ResultField> resultFields0 = resultType0.getResultFields();
		Set<String> resultFieldNames0 = resultFields0.keySet();
		for (String resultFieldName : resultFieldNames0) {
			actualResultFieldNamesArray0[i] = resultFieldName;
			actualResultFieldTypesArray0[i] = resultFields0.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultFields0.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields0.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultFields0.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray0, actualResultFieldNamesArray0);
		assertArrayEquals(expectedResultFieldTypesArray0, actualResultFieldTypesArray0);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray0, actualCanonicalModelConstructNamesArray0);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray0, actualParentCanonicalModelConstructNamesArray0);

		MappingOperator input1Operator = input0Operator.getLhsInput();
		isInstanceOf(JoinOperator.class, input1Operator);
		assertNotNull(input1Operator.getVariableName());
		assertEquals("countrye", input1Operator.getVariableName());
		assertNotNull(((JoinOperator) input1Operator).getReconcilingExpression());
		assertEquals("citye.countrye = countrye.codee", ((JoinOperator) input1Operator).getReconcilingExpression().getExpression());
		assertNotNull(input1Operator.getLhsInput());
		assertNotNull(input1Operator.getRhsInput());
		assertEquals(input1Operator.getInput(), input1Operator.getLhsInput());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input1Operator).getPredicates().size());
		Predicate predicate1 = ((JoinOperator) input1Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate1.getSuperLexical1().getName());
		assertEquals("citye", predicate1.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate1.getOperator());
		assertEquals("codee", predicate1.getSuperLexical2().getName());
		assertEquals("countrye", predicate1.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate1.getLiteral1());
		assertNull(predicate1.getLiteral2());

		assertNotNull(input1Operator.getResultType());
		ResultType resultType1 = input1Operator.getResultType();
		assertEquals(12, resultType1.getResultFields().size());
		String[] expectedResultFieldNamesArray1 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee", "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione" };
		DataType[] expectedResultFieldTypesArray1 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray1 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray1 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray1 = new String[12];
		DataType[] actualResultFieldTypesArray1 = new DataType[12];
		String[] actualCanonicalModelConstructNamesArray1 = new String[12];
		String[] actualParentCanonicalModelConstructNamesArray1 = new String[12];

		i = 0;
		Map<String, ResultField> resultFields1 = resultType1.getResultFields();
		Set<String> resultFieldNames1 = resultFields1.keySet();
		for (String resultFieldName : resultFieldNames1) {
			actualResultFieldNamesArray1[i] = resultFieldName;
			actualResultFieldTypesArray1[i] = resultFields1.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray1[i] = resultFields1.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields1.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray1[i] = ((SuperLexical) resultFields1.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray1, actualResultFieldNamesArray1);
		assertArrayEquals(expectedResultFieldTypesArray1, actualResultFieldTypesArray1);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray1, actualCanonicalModelConstructNamesArray1);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray1, actualParentCanonicalModelConstructNamesArray1);

		MappingOperator input2Operator = input0Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input2Operator);
		assertEquals("borderse", input2Operator.getVariableName());
		assertNull(input2Operator.getLhsInput());
		assertNull(input2Operator.getRhsInput());
		assertEquals("borderse", ((ScanOperator) input2Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input2Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input2Operator).getPredicates().size());

		assertNotNull(input2Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input2Operator.getDataSource());

		assertNotNull(input2Operator.getResultType());
		ResultType resultType2 = input2Operator.getResultType();
		assertEquals(3, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "borderse.country1e", "borderse.country2e", "borderse.lengthe" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray2 = new String[3];
		DataType[] actualResultFieldTypesArray2 = new DataType[3];
		String[] actualCanonicalModelConstructNamesArray2 = new String[3];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[3];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);

		MappingOperator input11Operator = input1Operator.getLhsInput();
		isInstanceOf(ScanOperator.class, input11Operator);
		assertEquals("citye", input11Operator.getVariableName());
		assertNull(input11Operator.getLhsInput());
		assertNull(input11Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input11Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input11Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input11Operator).getPredicates().size());

		assertNotNull(input11Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input11Operator.getDataSource());

		assertNotNull(input11Operator.getResultType());
		ResultType resultType3 = input11Operator.getResultType();
		assertEquals(6, resultType3.getResultFields().size());
		String[] expectedResultFieldNamesArray3 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee", };
		DataType[] expectedResultFieldTypesArray3 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray3 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray3 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray3 = new String[6];
		DataType[] actualResultFieldTypesArray3 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray3 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray3 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields3 = resultType3.getResultFields();
		Set<String> resultFieldNames3 = resultFields3.keySet();
		for (String resultFieldName : resultFieldNames3) {
			actualResultFieldNamesArray3[i] = resultFieldName;
			actualResultFieldTypesArray3[i] = resultFields3.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray3[i] = resultFields3.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields3.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray3[i] = ((SuperLexical) resultFields3.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray3, actualResultFieldNamesArray3);
		assertArrayEquals(expectedResultFieldTypesArray3, actualResultFieldTypesArray3);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray3, actualCanonicalModelConstructNamesArray3);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray3, actualParentCanonicalModelConstructNamesArray3);

		MappingOperator input12Operator = input1Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input12Operator);
		assertEquals("countrye", input12Operator.getVariableName());
		assertNull(input12Operator.getLhsInput());
		assertNull(input12Operator.getRhsInput());
		assertEquals("countrye", ((ScanOperator) input12Operator).getSuperAbstract().getName());
		assertEquals("countrye.codee = 'GB' or countrye.codee = 'D'", ((ScanOperator) input12Operator).getReconcilingExpression().getExpression());
		assertEquals("and", ((ScanOperator) input12Operator).getAndOr());

		assertNotNull(input12Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input12Operator.getDataSource());

		assertEquals(2, ((ScanOperator) input12Operator).getPredicates().size());

		Set<Predicate> predicates = ((ScanOperator) input12Operator).getPredicates();

		int k = 0;

		for (Predicate predicate2 : predicates) {
			if (k == 0) {
				//Predicate predicate2 = ((ScanOperator) input12Operator).getPredicates().get(0);
				assertEquals("codee", predicate2.getSuperLexical1().getName());
				assertEquals("countrye", predicate2.getSuperLexical1().getParentSuperAbstract().getName());
				assertEquals("=", predicate2.getOperator());
				assertEquals("'GB'", predicate2.getLiteral2());
				assertEquals("and", predicate2.getAndOr());
				assertNull(predicate2.getLiteral1());
				assertNull(predicate2.getSuperLexical2());
			} else if (k == 1) {
				//Predicate predicate3 = ((ScanOperator) input12Operator).getPredicates().get(1);
				assertEquals("codee", predicate2.getSuperLexical1().getName());
				assertEquals("countrye", predicate2.getSuperLexical1().getParentSuperAbstract().getName());
				assertEquals("=", predicate2.getOperator());
				assertEquals("'D'", predicate2.getLiteral2());
				assertEquals("or", predicate2.getAndOr());
				assertNull(predicate2.getLiteral1());
				assertNull(predicate2.getSuperLexical2());
			}
			k++;
		}
		assertNotNull(input12Operator.getResultType());
		ResultType resultType4 = input12Operator.getResultType();
		assertEquals(6, resultType4.getResultFields().size());
		String[] expectedResultFieldNamesArray4 = { "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione" };
		DataType[] expectedResultFieldTypesArray4 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT,
				DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray4 = { "namee", "codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray4 = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray4 = new String[6];
		DataType[] actualResultFieldTypesArray4 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray4 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray4 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields4 = resultType4.getResultFields();
		Set<String> resultFieldNames4 = resultFields4.keySet();
		for (String resultFieldName : resultFieldNames4) {
			actualResultFieldNamesArray4[i] = resultFieldName;
			actualResultFieldTypesArray4[i] = resultFields4.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray4[i] = resultFields4.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields4.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray4[i] = ((SuperLexical) resultFields4.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray4, actualResultFieldNamesArray4);
		assertArrayEquals(expectedResultFieldTypesArray4, actualResultFieldTypesArray4);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray4, actualCanonicalModelConstructNamesArray4);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray4, actualParentCanonicalModelConstructNamesArray4);
	}

	//---------------------------------------------------------------------

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectStarFromJoinJoinQueryWithVariableNameOneSource() {
		String selectStarFromJoinJoinQueryWithVariableName = "Select * from citye c, countrye o, borderse b where c.countrye = o.codee and o.codee = b.country1e";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectStarFromJoinJoinQueryWithVariableName);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectStarFromJoinJoinQueryWithVariableNameAst = parser.parseSQL(selectStarFromJoinJoinQueryWithVariableName);
		logger.debug("selectStarFromJoinJoinQueryWithVariableNameAst: " + selectStarFromJoinJoinQueryWithVariableNameAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectStarFromJoinJoinQueryWithVariableName,
				selectStarFromJoinJoinQueryWithVariableNameAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(15, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals(
				"c.namee, c.countrye, c.provincee, c.populatione, c.longitudee, c.latitudee, o.namee, o.codee, o.capitale, o.provincee, o.areae, o.populatione, b.country1e, b.country2e, b.lengthe",
				((ReduceOperator) rootOperator).getReconcilingExpression().getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[15];
		String[] superAbstractNamesArray = new String[15];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee", "codee",
				"capitale", "provincee", "areae", "populatione", "country1e", "country2e", "lengthe" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "borderse", "borderse", "borderse" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[15];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee",
				"o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione", "b.country1e", "b.country2e", "b.lengthe" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType0 = rootOperator.getResultType();
		assertEquals(15, resultType0.getResultFields().size());
		String[] expectedResultFieldNamesArray0 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee",
				"o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione", "b.country1e", "b.country2e", "b.lengthe" };
		DataType[] expectedResultFieldTypesArray0 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER,
				DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray0 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione", "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray0 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye", "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray0 = new String[15];
		DataType[] actualResultFieldTypesArray0 = new DataType[15];
		String[] actualCanonicalModelConstructNamesArray0 = new String[15];
		String[] actualParentCanonicalModelConstructNamesArray0 = new String[15];

		i = 0;
		Map<String, ResultField> resultFields0 = resultType0.getResultFields();
		Set<String> resultFieldNames0 = resultFields0.keySet();
		for (String resultFieldName : resultFieldNames0) {
			actualResultFieldNamesArray0[i] = resultFieldName;
			actualResultFieldTypesArray0[i] = resultFields0.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultFields0.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields0.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultFields0.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray0, actualResultFieldNamesArray0);
		assertArrayEquals(expectedResultFieldTypesArray0, actualResultFieldTypesArray0);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray0, actualCanonicalModelConstructNamesArray0);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray0, actualParentCanonicalModelConstructNamesArray0);

		MappingOperator input0Operator = rootOperator.getLhsInput();

		isInstanceOf(JoinOperator.class, input0Operator);
		assertNull(input0Operator.getVariableName());
		assertNotNull(((JoinOperator) input0Operator).getReconcilingExpression());
		assertEquals("o.codee = b.country1e", ((JoinOperator) input0Operator).getReconcilingExpression().getExpression());
		assertNotNull(input0Operator.getLhsInput());
		assertNotNull(input0Operator.getRhsInput());
		assertEquals(input0Operator.getInput(), input0Operator.getLhsInput());

		assertNotNull(input0Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input0Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input0Operator).getPredicates().size());
		Predicate predicate = ((JoinOperator) input0Operator).getPredicates().iterator().next();
		assertEquals("codee", predicate.getSuperLexical1().getName());
		assertEquals("countrye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate.getOperator());
		assertEquals("country1e", predicate.getSuperLexical2().getName());
		assertEquals("borderse", predicate.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate.getLiteral1());
		assertNull(predicate.getLiteral2());

		assertNotNull(input0Operator.getResultType());
		ResultType resultType = input0Operator.getResultType();
		assertEquals(15, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee", "o.namee",
				"o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione", "b.country1e", "b.country2e", "b.lengthe" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER,
				DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione", "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye", "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray = new String[15];
		DataType[] actualResultFieldTypesArray = new DataType[15];
		String[] actualCanonicalModelConstructNamesArray = new String[15];
		String[] actualParentCanonicalModelConstructNamesArray = new String[15];

		i = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[i] = resultFieldName;
			actualResultFieldTypesArray[i] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input1Operator = input0Operator.getLhsInput();
		isInstanceOf(JoinOperator.class, input1Operator);
		assertNotNull(input1Operator.getVariableName());
		assertEquals("o", input1Operator.getVariableName());
		assertNotNull(((JoinOperator) input1Operator).getReconcilingExpression());
		assertEquals("c.countrye = o.codee", ((JoinOperator) input1Operator).getReconcilingExpression().getExpression());
		assertNotNull(input1Operator.getLhsInput());
		assertNotNull(input1Operator.getRhsInput());
		assertEquals(input1Operator.getInput(), input1Operator.getLhsInput());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input1Operator).getPredicates().size());
		Predicate predicate1 = ((JoinOperator) input1Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate1.getSuperLexical1().getName());
		assertEquals("citye", predicate1.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate1.getOperator());
		assertEquals("codee", predicate1.getSuperLexical2().getName());
		assertEquals("countrye", predicate1.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate1.getLiteral1());
		assertNull(predicate1.getLiteral2());

		assertNotNull(input1Operator.getResultType());
		ResultType resultType1 = input1Operator.getResultType();
		assertEquals(12, resultType1.getResultFields().size());
		String[] expectedResultFieldNamesArray1 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee",
				"o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		DataType[] expectedResultFieldTypesArray1 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray1 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray1 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray1 = new String[12];
		DataType[] actualResultFieldTypesArray1 = new DataType[12];
		String[] actualCanonicalModelConstructNamesArray1 = new String[12];
		String[] actualParentCanonicalModelConstructNamesArray1 = new String[12];

		i = 0;
		Map<String, ResultField> resultFields1 = resultType1.getResultFields();
		Set<String> resultFieldNames1 = resultFields1.keySet();
		for (String resultFieldName : resultFieldNames1) {
			actualResultFieldNamesArray1[i] = resultFieldName;
			actualResultFieldTypesArray1[i] = resultFields1.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray1[i] = resultFields1.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields1.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray1[i] = ((SuperLexical) resultFields1.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray1, actualResultFieldNamesArray1);
		assertArrayEquals(expectedResultFieldTypesArray1, actualResultFieldTypesArray1);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray1, actualCanonicalModelConstructNamesArray1);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray1, actualParentCanonicalModelConstructNamesArray1);

		MappingOperator input2Operator = input0Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input2Operator);
		assertEquals("b", input2Operator.getVariableName());
		assertNull(input2Operator.getLhsInput());
		assertNull(input2Operator.getRhsInput());
		assertEquals("borderse", ((ScanOperator) input2Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input2Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input2Operator).getPredicates().size());

		assertNotNull(input2Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input2Operator.getDataSource());

		assertNotNull(input2Operator.getResultType());
		ResultType resultType2 = input2Operator.getResultType();
		assertEquals(3, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "b.country1e", "b.country2e", "b.lengthe" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray2 = new String[3];
		DataType[] actualResultFieldTypesArray2 = new DataType[3];
		String[] actualCanonicalModelConstructNamesArray2 = new String[3];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[3];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);

		MappingOperator input11Operator = input1Operator.getLhsInput();
		isInstanceOf(ScanOperator.class, input11Operator);
		assertEquals("c", input11Operator.getVariableName());
		assertNull(input11Operator.getLhsInput());
		assertNull(input11Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input11Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input11Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input11Operator).getPredicates().size());

		assertNotNull(input11Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input11Operator.getDataSource());

		assertNotNull(input11Operator.getResultType());
		ResultType resultType3 = input11Operator.getResultType();
		assertEquals(6, resultType3.getResultFields().size());
		String[] expectedResultFieldNamesArray3 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee" };
		DataType[] expectedResultFieldTypesArray3 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray3 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray3 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray3 = new String[6];
		DataType[] actualResultFieldTypesArray3 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray3 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray3 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields3 = resultType3.getResultFields();
		Set<String> resultFieldNames3 = resultFields3.keySet();
		for (String resultFieldName : resultFieldNames3) {
			actualResultFieldNamesArray3[i] = resultFieldName;
			actualResultFieldTypesArray3[i] = resultFields3.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray3[i] = resultFields3.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields3.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray3[i] = ((SuperLexical) resultFields3.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray3, actualResultFieldNamesArray3);
		assertArrayEquals(expectedResultFieldTypesArray3, actualResultFieldTypesArray3);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray3, actualCanonicalModelConstructNamesArray3);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray3, actualParentCanonicalModelConstructNamesArray3);

		MappingOperator input12Operator = input1Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input12Operator);
		assertEquals("o", input12Operator.getVariableName());
		assertNull(input12Operator.getLhsInput());
		assertNull(input12Operator.getRhsInput());
		assertEquals("countrye", ((ScanOperator) input12Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input12Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input12Operator).getPredicates().size());

		assertNotNull(input12Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input12Operator.getDataSource());

		assertNotNull(input12Operator.getResultType());
		ResultType resultType4 = input12Operator.getResultType();
		assertEquals(6, resultType4.getResultFields().size());
		String[] expectedResultFieldNamesArray4 = { "o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		DataType[] expectedResultFieldTypesArray4 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT,
				DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray4 = { "namee", "codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray4 = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray4 = new String[6];
		DataType[] actualResultFieldTypesArray4 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray4 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray4 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields4 = resultType4.getResultFields();
		Set<String> resultFieldNames4 = resultFields4.keySet();
		for (String resultFieldName : resultFieldNames4) {
			actualResultFieldNamesArray4[i] = resultFieldName;
			actualResultFieldTypesArray4[i] = resultFields4.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray4[i] = resultFields4.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields4.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray4[i] = ((SuperLexical) resultFields4.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray4, actualResultFieldNamesArray4);
		assertArrayEquals(expectedResultFieldTypesArray4, actualResultFieldTypesArray4);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray4, actualCanonicalModelConstructNamesArray4);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray4, actualParentCanonicalModelConstructNamesArray4);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectStarFromJoinJoinWhereQueryWithVariableNameOneSource() {
		String selectStarFromJoinJoinWhereQueryWithVariableName = "Select * from citye c, countrye o, borderse b where c.countrye = o.codee and o.codee = b.country1e and o.codee = 'GB'";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectStarFromJoinJoinWhereQueryWithVariableName);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectStarFromJoinJoinWhereQueryWithVariableNameAst = parser.parseSQL(selectStarFromJoinJoinWhereQueryWithVariableName);
		logger.debug("selectStarFromJoinJoinWhereQueryWithVariableNameAst: " + selectStarFromJoinJoinWhereQueryWithVariableNameAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectStarFromJoinJoinWhereQueryWithVariableName,
				selectStarFromJoinJoinWhereQueryWithVariableNameAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(15, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals(
				"c.namee, c.countrye, c.provincee, c.populatione, c.longitudee, c.latitudee, o.namee, o.codee, o.capitale, o.provincee, o.areae, o.populatione, b.country1e, b.country2e, b.lengthe",
				((ReduceOperator) rootOperator).getReconcilingExpression().getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[15];
		String[] superAbstractNamesArray = new String[15];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee", "codee",
				"capitale", "provincee", "areae", "populatione", "country1e", "country2e", "lengthe" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "borderse", "borderse", "borderse" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[15];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee",
				"o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione", "b.country1e", "b.country2e", "b.lengthe" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType0 = rootOperator.getResultType();
		assertEquals(15, resultType0.getResultFields().size());
		String[] expectedResultFieldNamesArray0 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee",
				"o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione", "b.country1e", "b.country2e", "b.lengthe" };
		DataType[] expectedResultFieldTypesArray0 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER,
				DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray0 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione", "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray0 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye", "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray0 = new String[15];
		DataType[] actualResultFieldTypesArray0 = new DataType[15];
		String[] actualCanonicalModelConstructNamesArray0 = new String[15];
		String[] actualParentCanonicalModelConstructNamesArray0 = new String[15];

		i = 0;
		Map<String, ResultField> resultFields0 = resultType0.getResultFields();
		Set<String> resultFieldNames0 = resultFields0.keySet();
		for (String resultFieldName : resultFieldNames0) {
			actualResultFieldNamesArray0[i] = resultFieldName;
			actualResultFieldTypesArray0[i] = resultFields0.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultFields0.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields0.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultFields0.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray0, actualResultFieldNamesArray0);
		assertArrayEquals(expectedResultFieldTypesArray0, actualResultFieldTypesArray0);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray0, actualCanonicalModelConstructNamesArray0);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray0, actualParentCanonicalModelConstructNamesArray0);

		MappingOperator input0Operator = rootOperator.getLhsInput();

		isInstanceOf(JoinOperator.class, input0Operator);
		assertNull(input0Operator.getVariableName());
		assertNotNull(((JoinOperator) input0Operator).getReconcilingExpression());
		assertEquals("o.codee = b.country1e", ((JoinOperator) input0Operator).getReconcilingExpression().getExpression());
		assertNotNull(input0Operator.getLhsInput());
		assertNotNull(input0Operator.getRhsInput());
		assertEquals(input0Operator.getInput(), input0Operator.getLhsInput());

		assertNotNull(input0Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input0Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input0Operator).getPredicates().size());
		Predicate predicate = ((JoinOperator) input0Operator).getPredicates().iterator().next();
		assertEquals("codee", predicate.getSuperLexical1().getName());
		assertEquals("countrye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate.getOperator());
		assertEquals("country1e", predicate.getSuperLexical2().getName());
		assertEquals("borderse", predicate.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate.getLiteral1());
		assertNull(predicate.getLiteral2());

		assertNotNull(input0Operator.getResultType());
		ResultType resultType = input0Operator.getResultType();
		assertEquals(15, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee", "o.namee",
				"o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione", "b.country1e", "b.country2e", "b.lengthe" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER,
				DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione", "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye", "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray = new String[15];
		DataType[] actualResultFieldTypesArray = new DataType[15];
		String[] actualCanonicalModelConstructNamesArray = new String[15];
		String[] actualParentCanonicalModelConstructNamesArray = new String[15];

		i = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[i] = resultFieldName;
			actualResultFieldTypesArray[i] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input1Operator = input0Operator.getLhsInput();
		isInstanceOf(JoinOperator.class, input1Operator);
		assertNotNull(input1Operator.getVariableName());
		assertEquals("o", input1Operator.getVariableName());
		assertNotNull(((JoinOperator) input1Operator).getReconcilingExpression());
		assertEquals("c.countrye = o.codee", ((JoinOperator) input1Operator).getReconcilingExpression().getExpression());
		assertNotNull(input1Operator.getLhsInput());
		assertNotNull(input1Operator.getRhsInput());
		assertEquals(input1Operator.getInput(), input1Operator.getLhsInput());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input1Operator).getPredicates().size());
		Predicate predicate1 = ((JoinOperator) input1Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate1.getSuperLexical1().getName());
		assertEquals("citye", predicate1.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate1.getOperator());
		assertEquals("codee", predicate1.getSuperLexical2().getName());
		assertEquals("countrye", predicate1.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate1.getLiteral1());
		assertNull(predicate1.getLiteral2());

		assertNotNull(input1Operator.getResultType());
		ResultType resultType1 = input1Operator.getResultType();
		assertEquals(12, resultType1.getResultFields().size());
		String[] expectedResultFieldNamesArray1 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee",
				"o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		DataType[] expectedResultFieldTypesArray1 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray1 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray1 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray1 = new String[12];
		DataType[] actualResultFieldTypesArray1 = new DataType[12];
		String[] actualCanonicalModelConstructNamesArray1 = new String[12];
		String[] actualParentCanonicalModelConstructNamesArray1 = new String[12];

		i = 0;
		Map<String, ResultField> resultFields1 = resultType1.getResultFields();
		Set<String> resultFieldNames1 = resultFields1.keySet();
		for (String resultFieldName : resultFieldNames1) {
			actualResultFieldNamesArray1[i] = resultFieldName;
			actualResultFieldTypesArray1[i] = resultFields1.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray1[i] = resultFields1.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields1.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray1[i] = ((SuperLexical) resultFields1.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray1, actualResultFieldNamesArray1);
		assertArrayEquals(expectedResultFieldTypesArray1, actualResultFieldTypesArray1);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray1, actualCanonicalModelConstructNamesArray1);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray1, actualParentCanonicalModelConstructNamesArray1);

		MappingOperator input2Operator = input0Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input2Operator);
		assertEquals("b", input2Operator.getVariableName());
		assertNull(input2Operator.getLhsInput());
		assertNull(input2Operator.getRhsInput());
		assertEquals("borderse", ((ScanOperator) input2Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input2Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input2Operator).getPredicates().size());

		assertNotNull(input2Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input2Operator.getDataSource());

		assertNotNull(input2Operator.getResultType());
		ResultType resultType2 = input2Operator.getResultType();
		assertEquals(3, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "b.country1e", "b.country2e", "b.lengthe" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray2 = new String[3];
		DataType[] actualResultFieldTypesArray2 = new DataType[3];
		String[] actualCanonicalModelConstructNamesArray2 = new String[3];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[3];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);

		MappingOperator input11Operator = input1Operator.getLhsInput();
		isInstanceOf(ScanOperator.class, input11Operator);
		assertEquals("c", input11Operator.getVariableName());
		assertNull(input11Operator.getLhsInput());
		assertNull(input11Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input11Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input11Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input11Operator).getPredicates().size());

		assertNotNull(input11Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input11Operator.getDataSource());

		assertNotNull(input11Operator.getResultType());
		ResultType resultType3 = input11Operator.getResultType();
		assertEquals(6, resultType3.getResultFields().size());
		String[] expectedResultFieldNamesArray3 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee" };
		DataType[] expectedResultFieldTypesArray3 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray3 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray3 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray3 = new String[6];
		DataType[] actualResultFieldTypesArray3 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray3 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray3 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields3 = resultType3.getResultFields();
		Set<String> resultFieldNames3 = resultFields3.keySet();
		for (String resultFieldName : resultFieldNames3) {
			actualResultFieldNamesArray3[i] = resultFieldName;
			actualResultFieldTypesArray3[i] = resultFields3.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray3[i] = resultFields3.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields3.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray3[i] = ((SuperLexical) resultFields3.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray3, actualResultFieldNamesArray3);
		assertArrayEquals(expectedResultFieldTypesArray3, actualResultFieldTypesArray3);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray3, actualCanonicalModelConstructNamesArray3);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray3, actualParentCanonicalModelConstructNamesArray3);

		MappingOperator input12Operator = input1Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input12Operator);
		assertEquals("o", input12Operator.getVariableName());
		assertNull(input12Operator.getLhsInput());
		assertNull(input12Operator.getRhsInput());
		assertEquals("countrye", ((ScanOperator) input12Operator).getSuperAbstract().getName());
		assertEquals("o.codee = 'GB'", ((ScanOperator) input12Operator).getReconcilingExpression().getExpression());
		assertEquals("and", ((ScanOperator) input12Operator).getAndOr());

		assertNotNull(input12Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input12Operator.getDataSource());

		assertEquals(1, ((ScanOperator) input12Operator).getPredicates().size());
		Predicate predicate2 = ((ScanOperator) input12Operator).getPredicates().iterator().next();
		assertEquals("codee", predicate2.getSuperLexical1().getName());
		assertEquals("countrye", predicate2.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate2.getOperator());
		assertEquals("'GB'", predicate2.getLiteral2());
		assertEquals("and", predicate2.getAndOr());
		assertNull(predicate2.getLiteral1());
		assertNull(predicate2.getSuperLexical2());

		assertNotNull(input12Operator.getResultType());
		ResultType resultType4 = input12Operator.getResultType();
		assertEquals(6, resultType4.getResultFields().size());
		String[] expectedResultFieldNamesArray4 = { "o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		DataType[] expectedResultFieldTypesArray4 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT,
				DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray4 = { "namee", "codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray4 = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray4 = new String[6];
		DataType[] actualResultFieldTypesArray4 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray4 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray4 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields4 = resultType4.getResultFields();
		Set<String> resultFieldNames4 = resultFields4.keySet();
		for (String resultFieldName : resultFieldNames4) {
			actualResultFieldNamesArray4[i] = resultFieldName;
			actualResultFieldTypesArray4[i] = resultFields4.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray4[i] = resultFields4.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields4.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray4[i] = ((SuperLexical) resultFields4.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray4, actualResultFieldNamesArray4);
		assertArrayEquals(expectedResultFieldTypesArray4, actualResultFieldTypesArray4);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray4, actualCanonicalModelConstructNamesArray4);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray4, actualParentCanonicalModelConstructNamesArray4);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectStarFromJoinJoinWhereAndQueryWithVariableNameOneSource() {
		String selectStarFromJoinJoinWhereAndQueryWithVariableName = "Select * from citye c, countrye o, borderse b where c.countrye = o.codee and o.codee = b.country1e and o.codee = 'GB' and c.namee = 'Manchester'";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectStarFromJoinJoinWhereAndQueryWithVariableName);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectStarFromJoinJoinWhereAndQueryWithVariableNameAst = parser.parseSQL(selectStarFromJoinJoinWhereAndQueryWithVariableName);
		logger.debug("selectStarFromJoinJoinWhereAndQueryWithVariableNameAst: "
				+ selectStarFromJoinJoinWhereAndQueryWithVariableNameAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectStarFromJoinJoinWhereAndQueryWithVariableName,
				selectStarFromJoinJoinWhereAndQueryWithVariableNameAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(15, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals(
				"c.namee, c.countrye, c.provincee, c.populatione, c.longitudee, c.latitudee, o.namee, o.codee, o.capitale, o.provincee, o.areae, o.populatione, b.country1e, b.country2e, b.lengthe",
				((ReduceOperator) rootOperator).getReconcilingExpression().getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[15];
		String[] superAbstractNamesArray = new String[15];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee", "codee",
				"capitale", "provincee", "areae", "populatione", "country1e", "country2e", "lengthe" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "borderse", "borderse", "borderse" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[15];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee",
				"o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione", "b.country1e", "b.country2e", "b.lengthe" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType0 = rootOperator.getResultType();
		assertEquals(15, resultType0.getResultFields().size());
		String[] expectedResultFieldNamesArray0 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee",
				"o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione", "b.country1e", "b.country2e", "b.lengthe" };
		DataType[] expectedResultFieldTypesArray0 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER,
				DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray0 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione", "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray0 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye", "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray0 = new String[15];
		DataType[] actualResultFieldTypesArray0 = new DataType[15];
		String[] actualCanonicalModelConstructNamesArray0 = new String[15];
		String[] actualParentCanonicalModelConstructNamesArray0 = new String[15];

		i = 0;
		Map<String, ResultField> resultFields0 = resultType0.getResultFields();
		Set<String> resultFieldNames0 = resultFields0.keySet();
		for (String resultFieldName : resultFieldNames0) {
			actualResultFieldNamesArray0[i] = resultFieldName;
			actualResultFieldTypesArray0[i] = resultFields0.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultFields0.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields0.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultFields0.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray0, actualResultFieldNamesArray0);
		assertArrayEquals(expectedResultFieldTypesArray0, actualResultFieldTypesArray0);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray0, actualCanonicalModelConstructNamesArray0);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray0, actualParentCanonicalModelConstructNamesArray0);

		MappingOperator input0Operator = rootOperator.getLhsInput();

		isInstanceOf(JoinOperator.class, input0Operator);
		assertNull(input0Operator.getVariableName());
		assertNotNull(((JoinOperator) input0Operator).getReconcilingExpression());
		assertEquals("o.codee = b.country1e", ((JoinOperator) input0Operator).getReconcilingExpression().getExpression());
		assertNotNull(input0Operator.getLhsInput());
		assertNotNull(input0Operator.getRhsInput());
		assertEquals(input0Operator.getInput(), input0Operator.getLhsInput());

		assertNotNull(input0Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input0Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input0Operator).getPredicates().size());
		Predicate predicate = ((JoinOperator) input0Operator).getPredicates().iterator().next();
		assertEquals("codee", predicate.getSuperLexical1().getName());
		assertEquals("countrye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate.getOperator());
		assertEquals("country1e", predicate.getSuperLexical2().getName());
		assertEquals("borderse", predicate.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate.getLiteral1());
		assertNull(predicate.getLiteral2());

		assertNotNull(input0Operator.getResultType());
		ResultType resultType = input0Operator.getResultType();
		assertEquals(15, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee", "o.namee",
				"o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione", "b.country1e", "b.country2e", "b.lengthe" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER,
				DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione", "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye", "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray = new String[15];
		DataType[] actualResultFieldTypesArray = new DataType[15];
		String[] actualCanonicalModelConstructNamesArray = new String[15];
		String[] actualParentCanonicalModelConstructNamesArray = new String[15];

		i = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[i] = resultFieldName;
			actualResultFieldTypesArray[i] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input1Operator = input0Operator.getLhsInput();
		isInstanceOf(JoinOperator.class, input1Operator);
		assertNotNull(input1Operator.getVariableName());
		assertEquals("o", input1Operator.getVariableName());
		assertNotNull(((JoinOperator) input1Operator).getReconcilingExpression());
		assertEquals("c.countrye = o.codee", ((JoinOperator) input1Operator).getReconcilingExpression().getExpression());
		assertNotNull(input1Operator.getLhsInput());
		assertNotNull(input1Operator.getRhsInput());
		assertEquals(input1Operator.getInput(), input1Operator.getLhsInput());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input1Operator).getPredicates().size());
		Predicate predicate1 = ((JoinOperator) input1Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate1.getSuperLexical1().getName());
		assertEquals("citye", predicate1.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate1.getOperator());
		assertEquals("codee", predicate1.getSuperLexical2().getName());
		assertEquals("countrye", predicate1.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate1.getLiteral1());
		assertNull(predicate1.getLiteral2());

		assertNotNull(input1Operator.getResultType());
		ResultType resultType1 = input1Operator.getResultType();
		assertEquals(12, resultType1.getResultFields().size());
		String[] expectedResultFieldNamesArray1 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee",
				"o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		DataType[] expectedResultFieldTypesArray1 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray1 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray1 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray1 = new String[12];
		DataType[] actualResultFieldTypesArray1 = new DataType[12];
		String[] actualCanonicalModelConstructNamesArray1 = new String[12];
		String[] actualParentCanonicalModelConstructNamesArray1 = new String[12];

		i = 0;
		Map<String, ResultField> resultFields1 = resultType1.getResultFields();
		Set<String> resultFieldNames1 = resultFields1.keySet();
		for (String resultFieldName : resultFieldNames1) {
			actualResultFieldNamesArray1[i] = resultFieldName;
			actualResultFieldTypesArray1[i] = resultFields1.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray1[i] = resultFields1.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields1.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray1[i] = ((SuperLexical) resultFields1.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray1, actualResultFieldNamesArray1);
		assertArrayEquals(expectedResultFieldTypesArray1, actualResultFieldTypesArray1);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray1, actualCanonicalModelConstructNamesArray1);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray1, actualParentCanonicalModelConstructNamesArray1);

		MappingOperator input2Operator = input0Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input2Operator);
		assertEquals("b", input2Operator.getVariableName());
		assertNull(input2Operator.getLhsInput());
		assertNull(input2Operator.getRhsInput());
		assertEquals("borderse", ((ScanOperator) input2Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input2Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input2Operator).getPredicates().size());

		assertNotNull(input2Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input2Operator.getDataSource());

		assertNotNull(input2Operator.getResultType());
		ResultType resultType2 = input2Operator.getResultType();
		assertEquals(3, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "b.country1e", "b.country2e", "b.lengthe" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray2 = new String[3];
		DataType[] actualResultFieldTypesArray2 = new DataType[3];
		String[] actualCanonicalModelConstructNamesArray2 = new String[3];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[3];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);

		MappingOperator input11Operator = input1Operator.getLhsInput();
		isInstanceOf(ScanOperator.class, input11Operator);
		assertEquals("c", input11Operator.getVariableName());
		assertNull(input11Operator.getLhsInput());
		assertNull(input11Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input11Operator).getSuperAbstract().getName());
		assertEquals("c.namee = 'Manchester'", ((ScanOperator) input11Operator).getReconcilingExpression().getExpression());
		assertEquals("and", ((ScanOperator) input11Operator).getAndOr());

		assertNotNull(input11Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input11Operator.getDataSource());

		assertEquals(1, ((ScanOperator) input11Operator).getPredicates().size());
		Predicate predicate2 = ((ScanOperator) input11Operator).getPredicates().iterator().next();
		assertEquals("namee", predicate2.getSuperLexical1().getName());
		assertEquals("citye", predicate2.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate2.getOperator());
		assertEquals("'Manchester'", predicate2.getLiteral2());
		assertEquals("and", predicate2.getAndOr());
		assertNull(predicate2.getLiteral1());
		assertNull(predicate2.getSuperLexical2());

		assertNotNull(input11Operator.getResultType());
		ResultType resultType3 = input11Operator.getResultType();
		assertEquals(6, resultType3.getResultFields().size());
		String[] expectedResultFieldNamesArray3 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee" };
		DataType[] expectedResultFieldTypesArray3 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray3 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray3 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray3 = new String[6];
		DataType[] actualResultFieldTypesArray3 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray3 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray3 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields3 = resultType3.getResultFields();
		Set<String> resultFieldNames3 = resultFields3.keySet();
		for (String resultFieldName : resultFieldNames3) {
			actualResultFieldNamesArray3[i] = resultFieldName;
			actualResultFieldTypesArray3[i] = resultFields3.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray3[i] = resultFields3.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields3.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray3[i] = ((SuperLexical) resultFields3.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray3, actualResultFieldNamesArray3);
		assertArrayEquals(expectedResultFieldTypesArray3, actualResultFieldTypesArray3);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray3, actualCanonicalModelConstructNamesArray3);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray3, actualParentCanonicalModelConstructNamesArray3);

		MappingOperator input12Operator = input1Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input12Operator);
		assertEquals("o", input12Operator.getVariableName());
		assertNull(input12Operator.getLhsInput());
		assertNull(input12Operator.getRhsInput());
		assertEquals("countrye", ((ScanOperator) input12Operator).getSuperAbstract().getName());
		assertEquals("o.codee = 'GB'", ((ScanOperator) input12Operator).getReconcilingExpression().getExpression());
		assertEquals("and", ((ScanOperator) input12Operator).getAndOr());

		assertNotNull(input12Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input12Operator.getDataSource());

		assertEquals(1, ((ScanOperator) input12Operator).getPredicates().size());
		Predicate predicate3 = ((ScanOperator) input12Operator).getPredicates().iterator().next();
		assertEquals("codee", predicate3.getSuperLexical1().getName());
		assertEquals("countrye", predicate3.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate3.getOperator());
		assertEquals("'GB'", predicate3.getLiteral2());
		assertEquals("and", predicate3.getAndOr());
		assertNull(predicate3.getLiteral1());
		assertNull(predicate3.getSuperLexical2());

		assertNotNull(input12Operator.getResultType());
		ResultType resultType4 = input12Operator.getResultType();
		assertEquals(6, resultType4.getResultFields().size());
		String[] expectedResultFieldNamesArray4 = { "o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		DataType[] expectedResultFieldTypesArray4 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT,
				DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray4 = { "namee", "codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray4 = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray4 = new String[6];
		DataType[] actualResultFieldTypesArray4 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray4 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray4 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields4 = resultType4.getResultFields();
		Set<String> resultFieldNames4 = resultFields4.keySet();
		for (String resultFieldName : resultFieldNames4) {
			actualResultFieldNamesArray4[i] = resultFieldName;
			actualResultFieldTypesArray4[i] = resultFields4.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray4[i] = resultFields4.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields4.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray4[i] = ((SuperLexical) resultFields4.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray4, actualResultFieldNamesArray4);
		assertArrayEquals(expectedResultFieldTypesArray4, actualResultFieldTypesArray4);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray4, actualCanonicalModelConstructNamesArray4);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray4, actualParentCanonicalModelConstructNamesArray4);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	//@Test
	public void testTranslateAstIntoQuerySelectStarFromJoinJoinWhereOrQueryWithVariableNameOneSource() {
		String selectStarFromJoinJoinWhereOrQueryWithVariableName = "Select * from citye c, countrye o, borderse b where c.countrye = o.codee and o.codee = b.country1e and (o.codee = 'GB' or o.codee = 'D')";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectStarFromJoinJoinWhereOrQueryWithVariableName);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectStarFromJoinJoinWhereOrQueryWithVariableNameAst = parser.parseSQL(selectStarFromJoinJoinWhereOrQueryWithVariableName);
		logger
				.debug("selectStarFromJoinJoinWhereOrQueryWithVariableNameAst: "
						+ selectStarFromJoinJoinWhereOrQueryWithVariableNameAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectStarFromJoinJoinWhereOrQueryWithVariableName,
				selectStarFromJoinJoinWhereOrQueryWithVariableNameAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(15, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals(
				"c.namee, c.countrye, c.provincee, c.populatione, c.longitudee, c.latitudee, o.namee, o.codee, o.capitale, o.provincee, o.areae, o.populatione, b.country1e, b.country2e, b.lengthe",
				((ReduceOperator) rootOperator).getReconcilingExpression().getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[15];
		String[] superAbstractNamesArray = new String[15];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee", "codee",
				"capitale", "provincee", "areae", "populatione", "country1e", "country2e", "lengthe" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "borderse", "borderse", "borderse" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[15];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee",
				"o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione", "b.country1e", "b.country2e", "b.lengthe" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType0 = rootOperator.getResultType();
		assertEquals(15, resultType0.getResultFields().size());
		String[] expectedResultFieldNamesArray0 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee",
				"o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione", "b.country1e", "b.country2e", "b.lengthe" };
		DataType[] expectedResultFieldTypesArray0 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER,
				DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray0 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione", "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray0 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye", "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray0 = new String[15];
		DataType[] actualResultFieldTypesArray0 = new DataType[15];
		String[] actualCanonicalModelConstructNamesArray0 = new String[15];
		String[] actualParentCanonicalModelConstructNamesArray0 = new String[15];

		i = 0;
		Map<String, ResultField> resultFields0 = resultType0.getResultFields();
		Set<String> resultFieldNames0 = resultFields0.keySet();
		for (String resultFieldName : resultFieldNames0) {
			actualResultFieldNamesArray0[i] = resultFieldName;
			actualResultFieldTypesArray0[i] = resultFields0.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultFields0.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields0.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultFields0.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray0, actualResultFieldNamesArray0);
		assertArrayEquals(expectedResultFieldTypesArray0, actualResultFieldTypesArray0);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray0, actualCanonicalModelConstructNamesArray0);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray0, actualParentCanonicalModelConstructNamesArray0);

		MappingOperator input0Operator = rootOperator.getLhsInput();

		isInstanceOf(JoinOperator.class, input0Operator);
		assertNull(input0Operator.getVariableName());
		assertNotNull(((JoinOperator) input0Operator).getReconcilingExpression());
		assertEquals("o.codee = b.country1e", ((JoinOperator) input0Operator).getReconcilingExpression().getExpression());
		assertNotNull(input0Operator.getLhsInput());
		assertNotNull(input0Operator.getRhsInput());
		assertEquals(input0Operator.getInput(), input0Operator.getLhsInput());

		assertNotNull(input0Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input0Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input0Operator).getPredicates().size());
		Predicate predicate = ((JoinOperator) input0Operator).getPredicates().iterator().next();
		assertEquals("codee", predicate.getSuperLexical1().getName());
		assertEquals("countrye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate.getOperator());
		assertEquals("country1e", predicate.getSuperLexical2().getName());
		assertEquals("borderse", predicate.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate.getLiteral1());
		assertNull(predicate.getLiteral2());

		assertNotNull(input0Operator.getResultType());
		ResultType resultType = input0Operator.getResultType();
		assertEquals(15, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee", "o.namee",
				"o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione", "b.country1e", "b.country2e", "b.lengthe" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER,
				DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione", "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye", "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray = new String[15];
		DataType[] actualResultFieldTypesArray = new DataType[15];
		String[] actualCanonicalModelConstructNamesArray = new String[15];
		String[] actualParentCanonicalModelConstructNamesArray = new String[15];

		i = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[i] = resultFieldName;
			actualResultFieldTypesArray[i] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input1Operator = input0Operator.getLhsInput();
		isInstanceOf(JoinOperator.class, input1Operator);
		assertNotNull(input1Operator.getVariableName());
		assertEquals("o", input1Operator.getVariableName());
		assertNotNull(((JoinOperator) input1Operator).getReconcilingExpression());
		assertEquals("c.countrye = o.codee", ((JoinOperator) input1Operator).getReconcilingExpression().getExpression());
		assertNotNull(input1Operator.getLhsInput());
		assertNotNull(input1Operator.getRhsInput());
		assertEquals(input1Operator.getInput(), input1Operator.getLhsInput());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input1Operator).getPredicates().size());
		Predicate predicate1 = ((JoinOperator) input1Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate1.getSuperLexical1().getName());
		assertEquals("citye", predicate1.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate1.getOperator());
		assertEquals("codee", predicate1.getSuperLexical2().getName());
		assertEquals("countrye", predicate1.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate1.getLiteral1());
		assertNull(predicate1.getLiteral2());

		assertNotNull(input1Operator.getResultType());
		ResultType resultType1 = input1Operator.getResultType();
		assertEquals(12, resultType1.getResultFields().size());
		String[] expectedResultFieldNamesArray1 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee",
				"o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		DataType[] expectedResultFieldTypesArray1 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray1 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray1 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray1 = new String[12];
		DataType[] actualResultFieldTypesArray1 = new DataType[12];
		String[] actualCanonicalModelConstructNamesArray1 = new String[12];
		String[] actualParentCanonicalModelConstructNamesArray1 = new String[12];

		i = 0;
		Map<String, ResultField> resultFields1 = resultType1.getResultFields();
		Set<String> resultFieldNames1 = resultFields1.keySet();
		for (String resultFieldName : resultFieldNames1) {
			actualResultFieldNamesArray1[i] = resultFieldName;
			actualResultFieldTypesArray1[i] = resultFields1.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray1[i] = resultFields1.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields1.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray1[i] = ((SuperLexical) resultFields1.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray1, actualResultFieldNamesArray1);
		assertArrayEquals(expectedResultFieldTypesArray1, actualResultFieldTypesArray1);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray1, actualCanonicalModelConstructNamesArray1);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray1, actualParentCanonicalModelConstructNamesArray1);

		MappingOperator input2Operator = input0Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input2Operator);
		assertEquals("b", input2Operator.getVariableName());
		assertNull(input2Operator.getLhsInput());
		assertNull(input2Operator.getRhsInput());
		assertEquals("borderse", ((ScanOperator) input2Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input2Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input2Operator).getPredicates().size());

		assertNotNull(input2Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input2Operator.getDataSource());

		assertNotNull(input2Operator.getResultType());
		ResultType resultType2 = input2Operator.getResultType();
		assertEquals(3, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "b.country1e", "b.country2e", "b.lengthe" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray2 = new String[3];
		DataType[] actualResultFieldTypesArray2 = new DataType[3];
		String[] actualCanonicalModelConstructNamesArray2 = new String[3];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[3];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);

		MappingOperator input11Operator = input1Operator.getLhsInput();
		isInstanceOf(ScanOperator.class, input11Operator);
		assertEquals("c", input11Operator.getVariableName());
		assertNull(input11Operator.getLhsInput());
		assertNull(input11Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input11Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input11Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input11Operator).getPredicates().size());

		assertNotNull(input11Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input11Operator.getDataSource());

		assertNotNull(input11Operator.getResultType());
		ResultType resultType3 = input11Operator.getResultType();
		assertEquals(6, resultType3.getResultFields().size());
		String[] expectedResultFieldNamesArray3 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee" };
		DataType[] expectedResultFieldTypesArray3 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray3 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray3 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray3 = new String[6];
		DataType[] actualResultFieldTypesArray3 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray3 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray3 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields3 = resultType3.getResultFields();
		Set<String> resultFieldNames3 = resultFields3.keySet();
		for (String resultFieldName : resultFieldNames3) {
			actualResultFieldNamesArray3[i] = resultFieldName;
			actualResultFieldTypesArray3[i] = resultFields3.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray3[i] = resultFields3.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields3.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray3[i] = ((SuperLexical) resultFields3.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray3, actualResultFieldNamesArray3);
		assertArrayEquals(expectedResultFieldTypesArray3, actualResultFieldTypesArray3);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray3, actualCanonicalModelConstructNamesArray3);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray3, actualParentCanonicalModelConstructNamesArray3);

		MappingOperator input12Operator = input1Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input12Operator);
		assertEquals("o", input12Operator.getVariableName());
		assertNull(input12Operator.getLhsInput());
		assertNull(input12Operator.getRhsInput());
		assertEquals("countrye", ((ScanOperator) input12Operator).getSuperAbstract().getName());
		assertEquals("o.codee = 'GB' or o.codee = 'D'", ((ScanOperator) input12Operator).getReconcilingExpression().getExpression());
		assertEquals("and", ((ScanOperator) input12Operator).getAndOr());

		assertNotNull(input12Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input12Operator.getDataSource());

		assertEquals(2, ((ScanOperator) input12Operator).getPredicates().size());

		Set<Predicate> predicates = ((ScanOperator) input12Operator).getPredicates();

		int k = 0;

		for (Predicate predicate2 : predicates) {
			if (k == 0) {
				//Predicate predicate2 = ((ScanOperator) input12Operator).getPredicates().get(0);
				assertEquals("codee", predicate2.getSuperLexical1().getName());
				assertEquals("countrye", predicate2.getSuperLexical1().getParentSuperAbstract().getName());
				assertEquals("=", predicate2.getOperator());
				assertEquals("'GB'", predicate2.getLiteral2());
				assertEquals("and", predicate2.getAndOr());
				assertNull(predicate2.getLiteral1());
				assertNull(predicate2.getSuperLexical2());
			} else if (k == 1) {
				//Predicate predicate3 = ((ScanOperator) input12Operator).getPredicates().get(1);
				assertEquals("codee", predicate2.getSuperLexical1().getName());
				assertEquals("countrye", predicate2.getSuperLexical1().getParentSuperAbstract().getName());
				assertEquals("=", predicate2.getOperator());
				assertEquals("'D'", predicate2.getLiteral2());
				assertEquals("or", predicate2.getAndOr());
				assertNull(predicate2.getLiteral1());
				assertNull(predicate2.getSuperLexical2());
			}
			k++;
		}

		assertNotNull(input12Operator.getResultType());
		ResultType resultType4 = input12Operator.getResultType();
		assertEquals(6, resultType4.getResultFields().size());
		String[] expectedResultFieldNamesArray4 = { "o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		DataType[] expectedResultFieldTypesArray4 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT,
				DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray4 = { "namee", "codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray4 = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray4 = new String[6];
		DataType[] actualResultFieldTypesArray4 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray4 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray4 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields4 = resultType4.getResultFields();
		Set<String> resultFieldNames4 = resultFields4.keySet();
		for (String resultFieldName : resultFieldNames4) {
			actualResultFieldNamesArray4[i] = resultFieldName;
			actualResultFieldTypesArray4[i] = resultFields4.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray4[i] = resultFields4.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields4.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray4[i] = ((SuperLexical) resultFields4.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray4, actualResultFieldNamesArray4);
		assertArrayEquals(expectedResultFieldTypesArray4, actualResultFieldTypesArray4);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray4, actualCanonicalModelConstructNamesArray4);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray4, actualParentCanonicalModelConstructNamesArray4);
	}

	//---------------------------------------------------------------------

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectSuperLexicalsFromJoinJoinQueryWithVariableNameOneSource() {
		String selectSuperLexicalsFromJoinJoinQueryWithVariableName = "Select c.namee, c.countrye, c.provincee, o.namee, o.capitale, b.country2e from citye c, countrye o, borderse b where c.countrye = o.codee and o.codee = b.country1e";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectSuperLexicalsFromJoinJoinQueryWithVariableName);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectSuperLexicalsFromJoinJoinQueryWithVariableNameAst = parser.parseSQL(selectSuperLexicalsFromJoinJoinQueryWithVariableName);
		logger.debug("selectSuperLexicalsFromJoinJoinQueryWithVariableNameAst: "
				+ selectSuperLexicalsFromJoinJoinQueryWithVariableNameAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectSuperLexicalsFromJoinJoinQueryWithVariableName,
				selectSuperLexicalsFromJoinJoinQueryWithVariableNameAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(6, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals("c.namee, c.countrye, c.provincee, o.namee, o.capitale, b.country2e", ((ReduceOperator) rootOperator).getReconcilingExpression()
				.getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[6];
		String[] superAbstractNamesArray = new String[6];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "namee", "capitale", "country2e" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "countrye", "countrye", "borderse" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[6];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "c.namee", "c.countrye", "c.provincee", "o.namee", "o.capitale", "b.country2e" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType = rootOperator.getResultType();
		assertEquals(6, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "c.namee", "c.countrye", "c.provincee", "o.namee", "o.capitale", "b.country2e" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING,
				DataType.STRING };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "namee", "capitale", "country2e" };
		String[] expectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "countrye", "countrye", "borderse" };

		String[] actualResultFieldNamesArray = new String[6];
		DataType[] actualResultFieldTypesArray = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray = new String[6];

		int j = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[j] = resultFieldName;
			actualResultFieldTypesArray[j] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[j] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[j] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			j++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(expectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input0Operator = rootOperator.getLhsInput();
		isInstanceOf(JoinOperator.class, input0Operator);
		assertNull(input0Operator.getVariableName());
		assertNotNull(((JoinOperator) input0Operator).getReconcilingExpression());
		assertEquals("o.codee = b.country1e", ((JoinOperator) input0Operator).getReconcilingExpression().getExpression());
		assertNotNull(input0Operator.getLhsInput());
		assertNotNull(input0Operator.getRhsInput());
		assertEquals(input0Operator.getInput(), input0Operator.getLhsInput());

		assertNotNull(input0Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input0Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input0Operator).getPredicates().size());
		Predicate predicate = ((JoinOperator) input0Operator).getPredicates().iterator().next();
		assertEquals("codee", predicate.getSuperLexical1().getName());
		assertEquals("countrye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate.getOperator());
		assertEquals("country1e", predicate.getSuperLexical2().getName());
		assertEquals("borderse", predicate.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate.getLiteral1());
		assertNull(predicate.getLiteral2());

		assertNotNull(input0Operator.getResultType());
		ResultType resultType0 = input0Operator.getResultType();
		assertEquals(15, resultType0.getResultFields().size());
		String[] expectedResultFieldNamesArray0 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee",
				"o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione", "b.country1e", "b.country2e", "b.lengthe" };
		DataType[] expectedResultFieldTypesArray0 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER,
				DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray0 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione", "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray0 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye", "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray0 = new String[15];
		DataType[] actualResultFieldTypesArray0 = new DataType[15];
		String[] actualCanonicalModelConstructNamesArray0 = new String[15];
		String[] actualParentCanonicalModelConstructNamesArray0 = new String[15];

		i = 0;
		Map<String, ResultField> resultFields0 = resultType0.getResultFields();
		Set<String> resultFieldNames0 = resultFields0.keySet();
		for (String resultFieldName : resultFieldNames0) {
			actualResultFieldNamesArray0[i] = resultFieldName;
			actualResultFieldTypesArray0[i] = resultFields0.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultFields0.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields0.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultFields0.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray0, actualResultFieldNamesArray0);
		assertArrayEquals(expectedResultFieldTypesArray0, actualResultFieldTypesArray0);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray0, actualCanonicalModelConstructNamesArray0);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray0, actualParentCanonicalModelConstructNamesArray0);

		MappingOperator input1Operator = input0Operator.getLhsInput();
		isInstanceOf(JoinOperator.class, input1Operator);
		assertNotNull(input1Operator.getVariableName());
		assertEquals("o", input1Operator.getVariableName());
		assertNotNull(((JoinOperator) input1Operator).getReconcilingExpression());
		assertEquals("c.countrye = o.codee", ((JoinOperator) input1Operator).getReconcilingExpression().getExpression());
		assertNotNull(input1Operator.getLhsInput());
		assertNotNull(input1Operator.getRhsInput());
		assertEquals(input1Operator.getInput(), input1Operator.getLhsInput());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input1Operator).getPredicates().size());
		Predicate predicate1 = ((JoinOperator) input1Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate1.getSuperLexical1().getName());
		assertEquals("citye", predicate1.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate1.getOperator());
		assertEquals("codee", predicate1.getSuperLexical2().getName());
		assertEquals("countrye", predicate1.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate1.getLiteral1());
		assertNull(predicate1.getLiteral2());

		assertNotNull(input1Operator.getResultType());
		ResultType resultType1 = input1Operator.getResultType();
		assertEquals(12, resultType1.getResultFields().size());
		String[] expectedResultFieldNamesArray1 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee",
				"o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		DataType[] expectedResultFieldTypesArray1 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray1 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray1 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray1 = new String[12];
		DataType[] actualResultFieldTypesArray1 = new DataType[12];
		String[] actualCanonicalModelConstructNamesArray1 = new String[12];
		String[] actualParentCanonicalModelConstructNamesArray1 = new String[12];

		i = 0;
		Map<String, ResultField> resultFields1 = resultType1.getResultFields();
		Set<String> resultFieldNames1 = resultFields1.keySet();
		for (String resultFieldName : resultFieldNames1) {
			actualResultFieldNamesArray1[i] = resultFieldName;
			actualResultFieldTypesArray1[i] = resultFields1.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray1[i] = resultFields1.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields1.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray1[i] = ((SuperLexical) resultFields1.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray1, actualResultFieldNamesArray1);
		assertArrayEquals(expectedResultFieldTypesArray1, actualResultFieldTypesArray1);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray1, actualCanonicalModelConstructNamesArray1);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray1, actualParentCanonicalModelConstructNamesArray1);

		MappingOperator input2Operator = input0Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input2Operator);
		assertEquals("b", input2Operator.getVariableName());
		assertNull(input2Operator.getLhsInput());
		assertNull(input2Operator.getRhsInput());
		assertEquals("borderse", ((ScanOperator) input2Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input2Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input2Operator).getPredicates().size());

		assertNotNull(input2Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input2Operator.getDataSource());

		assertNotNull(input2Operator.getResultType());
		ResultType resultType2 = input2Operator.getResultType();
		assertEquals(3, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "b.country1e", "b.country2e", "b.lengthe" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray2 = new String[3];
		DataType[] actualResultFieldTypesArray2 = new DataType[3];
		String[] actualCanonicalModelConstructNamesArray2 = new String[3];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[3];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);

		MappingOperator input11Operator = input1Operator.getLhsInput();
		isInstanceOf(ScanOperator.class, input11Operator);
		assertEquals("c", input11Operator.getVariableName());
		assertNull(input11Operator.getLhsInput());
		assertNull(input11Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input11Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input11Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input11Operator).getPredicates().size());

		assertNotNull(input11Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input11Operator.getDataSource());

		assertNotNull(input11Operator.getResultType());
		ResultType resultType3 = input11Operator.getResultType();
		assertEquals(6, resultType3.getResultFields().size());
		String[] expectedResultFieldNamesArray3 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee" };
		DataType[] expectedResultFieldTypesArray3 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray3 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray3 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray3 = new String[6];
		DataType[] actualResultFieldTypesArray3 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray3 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray3 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields3 = resultType3.getResultFields();
		Set<String> resultFieldNames3 = resultFields3.keySet();
		for (String resultFieldName : resultFieldNames3) {
			actualResultFieldNamesArray3[i] = resultFieldName;
			actualResultFieldTypesArray3[i] = resultFields3.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray3[i] = resultFields3.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields3.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray3[i] = ((SuperLexical) resultFields3.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray3, actualResultFieldNamesArray3);
		assertArrayEquals(expectedResultFieldTypesArray3, actualResultFieldTypesArray3);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray3, actualCanonicalModelConstructNamesArray3);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray3, actualParentCanonicalModelConstructNamesArray3);

		MappingOperator input12Operator = input1Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input12Operator);
		assertEquals("o", input12Operator.getVariableName());
		assertNull(input12Operator.getLhsInput());
		assertNull(input12Operator.getRhsInput());
		assertEquals("countrye", ((ScanOperator) input12Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input12Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input12Operator).getPredicates().size());

		assertNotNull(input12Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input12Operator.getDataSource());

		assertNotNull(input12Operator.getResultType());
		ResultType resultType4 = input12Operator.getResultType();
		assertEquals(6, resultType4.getResultFields().size());
		String[] expectedResultFieldNamesArray4 = { "o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		DataType[] expectedResultFieldTypesArray4 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT,
				DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray4 = { "namee", "codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray4 = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray4 = new String[6];
		DataType[] actualResultFieldTypesArray4 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray4 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray4 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields4 = resultType4.getResultFields();
		Set<String> resultFieldNames4 = resultFields4.keySet();
		for (String resultFieldName : resultFieldNames4) {
			actualResultFieldNamesArray4[i] = resultFieldName;
			actualResultFieldTypesArray4[i] = resultFields4.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray4[i] = resultFields4.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields4.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray4[i] = ((SuperLexical) resultFields4.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray4, actualResultFieldNamesArray4);
		assertArrayEquals(expectedResultFieldTypesArray4, actualResultFieldTypesArray4);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray4, actualCanonicalModelConstructNamesArray4);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray4, actualParentCanonicalModelConstructNamesArray4);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectSuperLexicalsFromJoinJoinWhereQueryWithVariableNameOneSource() {
		String selectSuperLexicalsFromJoinJoinWhereQueryWithVariableName = "Select c.namee, c.countrye, c.provincee, o.namee, o.capitale, b.country2e from citye c, countrye o, borderse b where c.countrye = o.codee and o.codee = b.country1e and o.codee = 'GB'";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectSuperLexicalsFromJoinJoinWhereQueryWithVariableName);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectSuperLexicalsFromJoinJoinWhereQueryWithVariableNameAst = parser
				.parseSQL(selectSuperLexicalsFromJoinJoinWhereQueryWithVariableName);
		logger.debug("selectSuperLexicalsFromJoinJoinWhereQueryWithVariableNameAst: "
				+ selectSuperLexicalsFromJoinJoinWhereQueryWithVariableNameAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectSuperLexicalsFromJoinJoinWhereQueryWithVariableName,
				selectSuperLexicalsFromJoinJoinWhereQueryWithVariableNameAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(6, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals("c.namee, c.countrye, c.provincee, o.namee, o.capitale, b.country2e", ((ReduceOperator) rootOperator).getReconcilingExpression()
				.getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[6];
		String[] superAbstractNamesArray = new String[6];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "namee", "capitale", "country2e" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "countrye", "countrye", "borderse" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[6];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "c.namee", "c.countrye", "c.provincee", "o.namee", "o.capitale", "b.country2e" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType = rootOperator.getResultType();
		assertEquals(6, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "c.namee", "c.countrye", "c.provincee", "o.namee", "o.capitale", "b.country2e" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING,
				DataType.STRING };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "namee", "capitale", "country2e" };
		String[] expectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "countrye", "countrye", "borderse" };

		String[] actualResultFieldNamesArray = new String[6];
		DataType[] actualResultFieldTypesArray = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray = new String[6];

		int j = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[j] = resultFieldName;
			actualResultFieldTypesArray[j] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[j] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[j] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			j++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(expectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input0Operator = rootOperator.getLhsInput();
		isInstanceOf(JoinOperator.class, input0Operator);
		assertNull(input0Operator.getVariableName());
		assertNotNull(((JoinOperator) input0Operator).getReconcilingExpression());
		assertEquals("o.codee = b.country1e", ((JoinOperator) input0Operator).getReconcilingExpression().getExpression());
		assertNotNull(input0Operator.getLhsInput());
		assertNotNull(input0Operator.getRhsInput());
		assertEquals(input0Operator.getInput(), input0Operator.getLhsInput());

		assertNotNull(input0Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input0Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input0Operator).getPredicates().size());
		Predicate predicate0 = ((JoinOperator) input0Operator).getPredicates().iterator().next();
		assertEquals("codee", predicate0.getSuperLexical1().getName());
		assertEquals("countrye", predicate0.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate0.getOperator());
		assertEquals("country1e", predicate0.getSuperLexical2().getName());
		assertEquals("borderse", predicate0.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate0.getLiteral1());
		assertNull(predicate0.getLiteral2());

		assertNotNull(input0Operator.getResultType());
		ResultType resultType0 = input0Operator.getResultType();
		assertEquals(15, resultType0.getResultFields().size());
		String[] expectedResultFieldNamesArray0 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee",
				"o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione", "b.country1e", "b.country2e", "b.lengthe" };
		DataType[] expectedResultFieldTypesArray0 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER,
				DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray0 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione", "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray0 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye", "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray0 = new String[15];
		DataType[] actualResultFieldTypesArray0 = new DataType[15];
		String[] actualCanonicalModelConstructNamesArray0 = new String[15];
		String[] actualParentCanonicalModelConstructNamesArray0 = new String[15];

		i = 0;
		Map<String, ResultField> resultFields0 = resultType0.getResultFields();
		Set<String> resultFieldNames0 = resultFields0.keySet();
		for (String resultFieldName : resultFieldNames0) {
			actualResultFieldNamesArray0[i] = resultFieldName;
			actualResultFieldTypesArray0[i] = resultFields0.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultFields0.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields0.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultFields0.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray0, actualResultFieldNamesArray0);
		assertArrayEquals(expectedResultFieldTypesArray0, actualResultFieldTypesArray0);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray0, actualCanonicalModelConstructNamesArray0);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray0, actualParentCanonicalModelConstructNamesArray0);

		MappingOperator input1Operator = input0Operator.getLhsInput();
		isInstanceOf(JoinOperator.class, input1Operator);
		assertNotNull(input1Operator.getVariableName());
		assertEquals("o", input1Operator.getVariableName());
		assertNotNull(((JoinOperator) input1Operator).getReconcilingExpression());
		assertEquals("c.countrye = o.codee", ((JoinOperator) input1Operator).getReconcilingExpression().getExpression());
		assertNotNull(input1Operator.getLhsInput());
		assertNotNull(input1Operator.getRhsInput());
		assertEquals(input1Operator.getInput(), input1Operator.getLhsInput());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input1Operator).getPredicates().size());
		Predicate predicate1 = ((JoinOperator) input1Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate1.getSuperLexical1().getName());
		assertEquals("citye", predicate1.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate1.getOperator());
		assertEquals("codee", predicate1.getSuperLexical2().getName());
		assertEquals("countrye", predicate1.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate1.getLiteral1());
		assertNull(predicate1.getLiteral2());

		assertNotNull(input1Operator.getResultType());
		ResultType resultType1 = input1Operator.getResultType();
		assertEquals(12, resultType1.getResultFields().size());
		String[] expectedResultFieldNamesArray1 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee",
				"o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		DataType[] expectedResultFieldTypesArray1 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray1 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray1 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray1 = new String[12];
		DataType[] actualResultFieldTypesArray1 = new DataType[12];
		String[] actualCanonicalModelConstructNamesArray1 = new String[12];
		String[] actualParentCanonicalModelConstructNamesArray1 = new String[12];

		i = 0;
		Map<String, ResultField> resultFields1 = resultType1.getResultFields();
		Set<String> resultFieldNames1 = resultFields1.keySet();
		for (String resultFieldName : resultFieldNames1) {
			actualResultFieldNamesArray1[i] = resultFieldName;
			actualResultFieldTypesArray1[i] = resultFields1.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray1[i] = resultFields1.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields1.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray1[i] = ((SuperLexical) resultFields1.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray1, actualResultFieldNamesArray1);
		assertArrayEquals(expectedResultFieldTypesArray1, actualResultFieldTypesArray1);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray1, actualCanonicalModelConstructNamesArray1);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray1, actualParentCanonicalModelConstructNamesArray1);

		MappingOperator input2Operator = input0Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input2Operator);
		assertEquals("b", input2Operator.getVariableName());
		assertNull(input2Operator.getLhsInput());
		assertNull(input2Operator.getRhsInput());
		assertEquals("borderse", ((ScanOperator) input2Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input2Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input2Operator).getPredicates().size());

		assertNotNull(input2Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input2Operator.getDataSource());

		assertNotNull(input2Operator.getResultType());
		ResultType resultType2 = input2Operator.getResultType();
		assertEquals(3, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "b.country1e", "b.country2e", "b.lengthe" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray2 = new String[3];
		DataType[] actualResultFieldTypesArray2 = new DataType[3];
		String[] actualCanonicalModelConstructNamesArray2 = new String[3];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[3];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);

		MappingOperator input11Operator = input1Operator.getLhsInput();
		isInstanceOf(ScanOperator.class, input11Operator);
		assertEquals("c", input11Operator.getVariableName());
		assertNull(input11Operator.getLhsInput());
		assertNull(input11Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input11Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input11Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input11Operator).getPredicates().size());

		assertNotNull(input11Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input11Operator.getDataSource());

		assertNotNull(input11Operator.getResultType());
		ResultType resultType3 = input11Operator.getResultType();
		assertEquals(6, resultType3.getResultFields().size());
		String[] expectedResultFieldNamesArray3 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee" };
		DataType[] expectedResultFieldTypesArray3 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray3 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray3 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray3 = new String[6];
		DataType[] actualResultFieldTypesArray3 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray3 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray3 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields3 = resultType3.getResultFields();
		Set<String> resultFieldNames3 = resultFields3.keySet();
		for (String resultFieldName : resultFieldNames3) {
			actualResultFieldNamesArray3[i] = resultFieldName;
			actualResultFieldTypesArray3[i] = resultFields3.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray3[i] = resultFields3.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields3.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray3[i] = ((SuperLexical) resultFields3.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray3, actualResultFieldNamesArray3);
		assertArrayEquals(expectedResultFieldTypesArray3, actualResultFieldTypesArray3);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray3, actualCanonicalModelConstructNamesArray3);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray3, actualParentCanonicalModelConstructNamesArray3);

		MappingOperator input12Operator = input1Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input12Operator);
		assertEquals("o", input12Operator.getVariableName());
		assertNull(input12Operator.getLhsInput());
		assertNull(input12Operator.getRhsInput());
		assertEquals("countrye", ((ScanOperator) input12Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input12Operator).getReconcilingExpression());
		assertEquals("o.codee = 'GB'", ((ScanOperator) input12Operator).getReconcilingExpression().getExpression());
		assertEquals("and", ((ScanOperator) input12Operator).getAndOr());

		assertNotNull(input12Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input12Operator.getDataSource());

		assertEquals(1, ((ScanOperator) input12Operator).getPredicates().size());
		Predicate predicate2 = ((ScanOperator) input12Operator).getPredicates().iterator().next();
		assertEquals("codee", predicate2.getSuperLexical1().getName());
		assertEquals("countrye", predicate2.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate2.getOperator());
		assertEquals("'GB'", predicate2.getLiteral2());
		assertEquals("and", predicate2.getAndOr());
		assertNull(predicate2.getLiteral1());
		assertNull(predicate2.getSuperLexical2());

		assertNotNull(input12Operator.getResultType());
		ResultType resultType4 = input12Operator.getResultType();
		assertEquals(6, resultType4.getResultFields().size());
		String[] expectedResultFieldNamesArray4 = { "o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		DataType[] expectedResultFieldTypesArray4 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT,
				DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray4 = { "namee", "codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray4 = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray4 = new String[6];
		DataType[] actualResultFieldTypesArray4 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray4 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray4 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields4 = resultType4.getResultFields();
		Set<String> resultFieldNames4 = resultFields4.keySet();
		for (String resultFieldName : resultFieldNames4) {
			actualResultFieldNamesArray4[i] = resultFieldName;
			actualResultFieldTypesArray4[i] = resultFields4.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray4[i] = resultFields4.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields4.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray4[i] = ((SuperLexical) resultFields4.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray4, actualResultFieldNamesArray4);
		assertArrayEquals(expectedResultFieldTypesArray4, actualResultFieldTypesArray4);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray4, actualCanonicalModelConstructNamesArray4);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray4, actualParentCanonicalModelConstructNamesArray4);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectSuperLexicalsFromJoinJoinWhereAndQueryWithVariableNameOneSource() {
		String selectSuperLexicalsFromJoinJoinWhereAndQueryWithVariableName = "Select c.namee, c.countrye, c.provincee, o.namee, o.capitale, b.country2e from citye c, countrye o, borderse b where c.countrye = o.codee and o.codee = b.country1e and o.codee = 'GB' and c.namee = 'Manchester'";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectSuperLexicalsFromJoinJoinWhereAndQueryWithVariableName);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectSuperLexicalsFromJoinJoinWhereAndQueryWithVariableNameAst = parser
				.parseSQL(selectSuperLexicalsFromJoinJoinWhereAndQueryWithVariableName);
		logger.debug("selectSuperLexicalsFromJoinJoinWhereAndQueryWithVariableNameAst: "
				+ selectSuperLexicalsFromJoinJoinWhereAndQueryWithVariableNameAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectSuperLexicalsFromJoinJoinWhereAndQueryWithVariableName,
				selectSuperLexicalsFromJoinJoinWhereAndQueryWithVariableNameAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(6, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals("c.namee, c.countrye, c.provincee, o.namee, o.capitale, b.country2e", ((ReduceOperator) rootOperator).getReconcilingExpression()
				.getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[6];
		String[] superAbstractNamesArray = new String[6];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "namee", "capitale", "country2e" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "countrye", "countrye", "borderse" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[6];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "c.namee", "c.countrye", "c.provincee", "o.namee", "o.capitale", "b.country2e" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType = rootOperator.getResultType();
		assertEquals(6, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "c.namee", "c.countrye", "c.provincee", "o.namee", "o.capitale", "b.country2e" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING,
				DataType.STRING };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "namee", "capitale", "country2e" };
		String[] expectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "countrye", "countrye", "borderse" };

		String[] actualResultFieldNamesArray = new String[6];
		DataType[] actualResultFieldTypesArray = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray = new String[6];

		int j = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[j] = resultFieldName;
			actualResultFieldTypesArray[j] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[j] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[j] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			j++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(expectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input0Operator = rootOperator.getLhsInput();
		isInstanceOf(JoinOperator.class, input0Operator);
		assertNull(input0Operator.getVariableName());
		assertNotNull(((JoinOperator) input0Operator).getReconcilingExpression());
		assertEquals("o.codee = b.country1e", ((JoinOperator) input0Operator).getReconcilingExpression().getExpression());
		assertNotNull(input0Operator.getLhsInput());
		assertNotNull(input0Operator.getRhsInput());
		assertEquals(input0Operator.getInput(), input0Operator.getLhsInput());

		assertNotNull(input0Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input0Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input0Operator).getPredicates().size());
		Predicate predicate0 = ((JoinOperator) input0Operator).getPredicates().iterator().next();
		assertEquals("codee", predicate0.getSuperLexical1().getName());
		assertEquals("countrye", predicate0.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate0.getOperator());
		assertEquals("country1e", predicate0.getSuperLexical2().getName());
		assertEquals("borderse", predicate0.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate0.getLiteral1());
		assertNull(predicate0.getLiteral2());

		assertNotNull(input0Operator.getResultType());
		ResultType resultType0 = input0Operator.getResultType();
		assertEquals(15, resultType0.getResultFields().size());
		String[] expectedResultFieldNamesArray0 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee",
				"o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione", "b.country1e", "b.country2e", "b.lengthe" };
		DataType[] expectedResultFieldTypesArray0 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER,
				DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray0 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione", "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray0 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye", "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray0 = new String[15];
		DataType[] actualResultFieldTypesArray0 = new DataType[15];
		String[] actualCanonicalModelConstructNamesArray0 = new String[15];
		String[] actualParentCanonicalModelConstructNamesArray0 = new String[15];

		i = 0;
		Map<String, ResultField> resultFields0 = resultType0.getResultFields();
		Set<String> resultFieldNames0 = resultFields0.keySet();
		for (String resultFieldName : resultFieldNames0) {
			actualResultFieldNamesArray0[i] = resultFieldName;
			actualResultFieldTypesArray0[i] = resultFields0.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultFields0.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields0.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultFields0.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray0, actualResultFieldNamesArray0);
		assertArrayEquals(expectedResultFieldTypesArray0, actualResultFieldTypesArray0);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray0, actualCanonicalModelConstructNamesArray0);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray0, actualParentCanonicalModelConstructNamesArray0);

		MappingOperator input1Operator = input0Operator.getLhsInput();
		isInstanceOf(JoinOperator.class, input1Operator);
		assertNotNull(input1Operator.getVariableName());
		assertEquals("o", input1Operator.getVariableName());
		assertNotNull(((JoinOperator) input1Operator).getReconcilingExpression());
		assertEquals("c.countrye = o.codee", ((JoinOperator) input1Operator).getReconcilingExpression().getExpression());
		assertNotNull(input1Operator.getLhsInput());
		assertNotNull(input1Operator.getRhsInput());
		assertEquals(input1Operator.getInput(), input1Operator.getLhsInput());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input1Operator).getPredicates().size());
		Predicate predicate1 = ((JoinOperator) input1Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate1.getSuperLexical1().getName());
		assertEquals("citye", predicate1.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate1.getOperator());
		assertEquals("codee", predicate1.getSuperLexical2().getName());
		assertEquals("countrye", predicate1.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate1.getLiteral1());
		assertNull(predicate1.getLiteral2());

		assertNotNull(input1Operator.getResultType());
		ResultType resultType1 = input1Operator.getResultType();
		assertEquals(12, resultType1.getResultFields().size());
		String[] expectedResultFieldNamesArray1 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee",
				"o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		DataType[] expectedResultFieldTypesArray1 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray1 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray1 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray1 = new String[12];
		DataType[] actualResultFieldTypesArray1 = new DataType[12];
		String[] actualCanonicalModelConstructNamesArray1 = new String[12];
		String[] actualParentCanonicalModelConstructNamesArray1 = new String[12];

		i = 0;
		Map<String, ResultField> resultFields1 = resultType1.getResultFields();
		Set<String> resultFieldNames1 = resultFields1.keySet();
		for (String resultFieldName : resultFieldNames1) {
			actualResultFieldNamesArray1[i] = resultFieldName;
			actualResultFieldTypesArray1[i] = resultFields1.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray1[i] = resultFields1.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields1.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray1[i] = ((SuperLexical) resultFields1.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray1, actualResultFieldNamesArray1);
		assertArrayEquals(expectedResultFieldTypesArray1, actualResultFieldTypesArray1);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray1, actualCanonicalModelConstructNamesArray1);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray1, actualParentCanonicalModelConstructNamesArray1);

		MappingOperator input2Operator = input0Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input2Operator);
		assertEquals("b", input2Operator.getVariableName());
		assertNull(input2Operator.getLhsInput());
		assertNull(input2Operator.getRhsInput());
		assertEquals("borderse", ((ScanOperator) input2Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input2Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input2Operator).getPredicates().size());

		assertNotNull(input2Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input2Operator.getDataSource());

		assertNotNull(input2Operator.getResultType());
		ResultType resultType2 = input2Operator.getResultType();
		assertEquals(3, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "b.country1e", "b.country2e", "b.lengthe" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray2 = new String[3];
		DataType[] actualResultFieldTypesArray2 = new DataType[3];
		String[] actualCanonicalModelConstructNamesArray2 = new String[3];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[3];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);

		MappingOperator input11Operator = input1Operator.getLhsInput();
		isInstanceOf(ScanOperator.class, input11Operator);
		assertEquals("c", input11Operator.getVariableName());
		assertNull(input11Operator.getLhsInput());
		assertNull(input11Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input11Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input11Operator).getReconcilingExpression());
		assertEquals("c.namee = 'Manchester'", ((ScanOperator) input11Operator).getReconcilingExpression().getExpression());
		assertEquals("and", ((ScanOperator) input11Operator).getAndOr());

		assertNotNull(input11Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input11Operator.getDataSource());

		assertEquals(1, ((ScanOperator) input11Operator).getPredicates().size());
		Predicate predicate2 = ((ScanOperator) input11Operator).getPredicates().iterator().next();
		assertEquals("namee", predicate2.getSuperLexical1().getName());
		assertEquals("citye", predicate2.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate2.getOperator());
		assertEquals("'Manchester'", predicate2.getLiteral2());
		assertEquals("and", predicate2.getAndOr());
		assertNull(predicate2.getLiteral1());
		assertNull(predicate2.getSuperLexical2());

		assertNotNull(input11Operator.getResultType());
		ResultType resultType3 = input11Operator.getResultType();
		assertEquals(6, resultType3.getResultFields().size());
		String[] expectedResultFieldNamesArray3 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee" };
		DataType[] expectedResultFieldTypesArray3 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray3 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray3 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray3 = new String[6];
		DataType[] actualResultFieldTypesArray3 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray3 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray3 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields3 = resultType3.getResultFields();
		Set<String> resultFieldNames3 = resultFields3.keySet();
		for (String resultFieldName : resultFieldNames3) {
			actualResultFieldNamesArray3[i] = resultFieldName;
			actualResultFieldTypesArray3[i] = resultFields3.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray3[i] = resultFields3.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields3.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray3[i] = ((SuperLexical) resultFields3.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray3, actualResultFieldNamesArray3);
		assertArrayEquals(expectedResultFieldTypesArray3, actualResultFieldTypesArray3);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray3, actualCanonicalModelConstructNamesArray3);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray3, actualParentCanonicalModelConstructNamesArray3);

		MappingOperator input12Operator = input1Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input12Operator);
		assertEquals("o", input12Operator.getVariableName());
		assertNull(input12Operator.getLhsInput());
		assertNull(input12Operator.getRhsInput());
		assertEquals("countrye", ((ScanOperator) input12Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input12Operator).getReconcilingExpression());
		assertEquals("o.codee = 'GB'", ((ScanOperator) input12Operator).getReconcilingExpression().getExpression());
		assertEquals("and", ((ScanOperator) input12Operator).getAndOr());

		assertNotNull(input12Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input12Operator.getDataSource());

		assertEquals(1, ((ScanOperator) input12Operator).getPredicates().size());
		Predicate predicate3 = ((ScanOperator) input12Operator).getPredicates().iterator().next();
		assertEquals("codee", predicate3.getSuperLexical1().getName());
		assertEquals("countrye", predicate3.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate3.getOperator());
		assertEquals("'GB'", predicate3.getLiteral2());
		assertEquals("and", predicate3.getAndOr());
		assertNull(predicate3.getLiteral1());
		assertNull(predicate3.getSuperLexical2());

		assertNotNull(input12Operator.getResultType());
		ResultType resultType4 = input12Operator.getResultType();
		assertEquals(6, resultType4.getResultFields().size());
		String[] expectedResultFieldNamesArray4 = { "o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		DataType[] expectedResultFieldTypesArray4 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT,
				DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray4 = { "namee", "codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray4 = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray4 = new String[6];
		DataType[] actualResultFieldTypesArray4 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray4 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray4 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields4 = resultType4.getResultFields();
		Set<String> resultFieldNames4 = resultFields4.keySet();
		for (String resultFieldName : resultFieldNames4) {
			actualResultFieldNamesArray4[i] = resultFieldName;
			actualResultFieldTypesArray4[i] = resultFields4.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray4[i] = resultFields4.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields4.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray4[i] = ((SuperLexical) resultFields4.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray4, actualResultFieldNamesArray4);
		assertArrayEquals(expectedResultFieldTypesArray4, actualResultFieldTypesArray4);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray4, actualCanonicalModelConstructNamesArray4);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray4, actualParentCanonicalModelConstructNamesArray4);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	//@Test
	public void testTranslateAstIntoQuerySelectSuperLexicalsFromJoinJoinWhereOrQueryWithVariableNameOneSource() {
		String selectSuperLexicalsFromJoinJoinWhereOrQueryWithVariableName = "Select c.namee, c.countrye, c.provincee, o.namee, o.capitale, b.country2e from citye c, countrye o, borderse b where c.countrye = o.codee and o.codee = b.country1e and (o.codee = 'GB' or o.codee = 'D')";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectSuperLexicalsFromJoinJoinWhereOrQueryWithVariableName);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectSuperLexicalsFromJoinJoinWhereOrQueryWithVariableNameAst = parser
				.parseSQL(selectSuperLexicalsFromJoinJoinWhereOrQueryWithVariableName);
		logger.debug("selectSuperLexicalsFromJoinJoinWhereOrQueryWithVariableNameAst: "
				+ selectSuperLexicalsFromJoinJoinWhereOrQueryWithVariableNameAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectSuperLexicalsFromJoinJoinWhereOrQueryWithVariableName,
				selectSuperLexicalsFromJoinJoinWhereOrQueryWithVariableNameAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(6, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals("c.namee, c.countrye, c.provincee, o.namee, o.capitale, b.country2e", ((ReduceOperator) rootOperator).getReconcilingExpression()
				.getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[6];
		String[] superAbstractNamesArray = new String[6];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "namee", "capitale", "country2e" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "countrye", "countrye", "borderse" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[6];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "c.namee", "c.countrye", "c.provincee", "o.namee", "o.capitale", "b.country2e" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType = rootOperator.getResultType();
		assertEquals(6, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "c.namee", "c.countrye", "c.provincee", "o.namee", "o.capitale", "b.country2e" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING,
				DataType.STRING };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "namee", "capitale", "country2e" };
		String[] expectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "countrye", "countrye", "borderse" };

		String[] actualResultFieldNamesArray = new String[6];
		DataType[] actualResultFieldTypesArray = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray = new String[6];

		int j = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[j] = resultFieldName;
			actualResultFieldTypesArray[j] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[j] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[j] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			j++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(expectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input0Operator = rootOperator.getLhsInput();
		isInstanceOf(JoinOperator.class, input0Operator);
		assertNull(input0Operator.getVariableName());
		assertNotNull(((JoinOperator) input0Operator).getReconcilingExpression());
		assertEquals("o.codee = b.country1e", ((JoinOperator) input0Operator).getReconcilingExpression().getExpression());
		assertNotNull(input0Operator.getLhsInput());
		assertNotNull(input0Operator.getRhsInput());
		assertEquals(input0Operator.getInput(), input0Operator.getLhsInput());

		assertNotNull(input0Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input0Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input0Operator).getPredicates().size());
		Predicate predicate0 = ((JoinOperator) input0Operator).getPredicates().iterator().next();
		assertEquals("codee", predicate0.getSuperLexical1().getName());
		assertEquals("countrye", predicate0.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate0.getOperator());
		assertEquals("country1e", predicate0.getSuperLexical2().getName());
		assertEquals("borderse", predicate0.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate0.getLiteral1());
		assertNull(predicate0.getLiteral2());

		assertNotNull(input0Operator.getResultType());
		ResultType resultType0 = input0Operator.getResultType();
		assertEquals(15, resultType0.getResultFields().size());
		String[] expectedResultFieldNamesArray0 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee",
				"o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione", "b.country1e", "b.country2e", "b.lengthe" };
		DataType[] expectedResultFieldTypesArray0 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER,
				DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray0 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione", "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray0 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye", "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray0 = new String[15];
		DataType[] actualResultFieldTypesArray0 = new DataType[15];
		String[] actualCanonicalModelConstructNamesArray0 = new String[15];
		String[] actualParentCanonicalModelConstructNamesArray0 = new String[15];

		i = 0;
		Map<String, ResultField> resultFields0 = resultType0.getResultFields();
		Set<String> resultFieldNames0 = resultFields0.keySet();
		for (String resultFieldName : resultFieldNames0) {
			actualResultFieldNamesArray0[i] = resultFieldName;
			actualResultFieldTypesArray0[i] = resultFields0.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultFields0.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields0.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultFields0.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray0, actualResultFieldNamesArray0);
		assertArrayEquals(expectedResultFieldTypesArray0, actualResultFieldTypesArray0);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray0, actualCanonicalModelConstructNamesArray0);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray0, actualParentCanonicalModelConstructNamesArray0);

		MappingOperator input1Operator = input0Operator.getLhsInput();
		isInstanceOf(JoinOperator.class, input1Operator);
		assertNotNull(input1Operator.getVariableName());
		assertEquals("o", input1Operator.getVariableName());
		assertNotNull(((JoinOperator) input1Operator).getReconcilingExpression());
		assertEquals("c.countrye = o.codee", ((JoinOperator) input1Operator).getReconcilingExpression().getExpression());
		assertNotNull(input1Operator.getLhsInput());
		assertNotNull(input1Operator.getRhsInput());
		assertEquals(input1Operator.getInput(), input1Operator.getLhsInput());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input1Operator).getPredicates().size());
		Predicate predicate1 = ((JoinOperator) input1Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate1.getSuperLexical1().getName());
		assertEquals("citye", predicate1.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate1.getOperator());
		assertEquals("codee", predicate1.getSuperLexical2().getName());
		assertEquals("countrye", predicate1.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate1.getLiteral1());
		assertNull(predicate1.getLiteral2());

		assertNotNull(input1Operator.getResultType());
		ResultType resultType1 = input1Operator.getResultType();
		assertEquals(12, resultType1.getResultFields().size());
		String[] expectedResultFieldNamesArray1 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee",
				"o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		DataType[] expectedResultFieldTypesArray1 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray1 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray1 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray1 = new String[12];
		DataType[] actualResultFieldTypesArray1 = new DataType[12];
		String[] actualCanonicalModelConstructNamesArray1 = new String[12];
		String[] actualParentCanonicalModelConstructNamesArray1 = new String[12];

		i = 0;
		Map<String, ResultField> resultFields1 = resultType1.getResultFields();
		Set<String> resultFieldNames1 = resultFields1.keySet();
		for (String resultFieldName : resultFieldNames1) {
			actualResultFieldNamesArray1[i] = resultFieldName;
			actualResultFieldTypesArray1[i] = resultFields1.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray1[i] = resultFields1.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields1.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray1[i] = ((SuperLexical) resultFields1.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray1, actualResultFieldNamesArray1);
		assertArrayEquals(expectedResultFieldTypesArray1, actualResultFieldTypesArray1);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray1, actualCanonicalModelConstructNamesArray1);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray1, actualParentCanonicalModelConstructNamesArray1);

		MappingOperator input2Operator = input0Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input2Operator);
		assertEquals("b", input2Operator.getVariableName());
		assertNull(input2Operator.getLhsInput());
		assertNull(input2Operator.getRhsInput());
		assertEquals("borderse", ((ScanOperator) input2Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input2Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input2Operator).getPredicates().size());

		assertNotNull(input2Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input2Operator.getDataSource());

		assertNotNull(input2Operator.getResultType());
		ResultType resultType2 = input2Operator.getResultType();
		assertEquals(3, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "b.country1e", "b.country2e", "b.lengthe" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray2 = new String[3];
		DataType[] actualResultFieldTypesArray2 = new DataType[3];
		String[] actualCanonicalModelConstructNamesArray2 = new String[3];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[3];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);

		MappingOperator input11Operator = input1Operator.getLhsInput();
		isInstanceOf(ScanOperator.class, input11Operator);
		assertEquals("c", input11Operator.getVariableName());
		assertNull(input11Operator.getLhsInput());
		assertNull(input11Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input11Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input11Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input11Operator).getPredicates().size());

		assertNotNull(input11Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input11Operator.getDataSource());

		assertNotNull(input11Operator.getResultType());
		ResultType resultType3 = input11Operator.getResultType();
		assertEquals(6, resultType3.getResultFields().size());
		String[] expectedResultFieldNamesArray3 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee" };
		DataType[] expectedResultFieldTypesArray3 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray3 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray3 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray3 = new String[6];
		DataType[] actualResultFieldTypesArray3 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray3 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray3 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields3 = resultType3.getResultFields();
		Set<String> resultFieldNames3 = resultFields3.keySet();
		for (String resultFieldName : resultFieldNames3) {
			actualResultFieldNamesArray3[i] = resultFieldName;
			actualResultFieldTypesArray3[i] = resultFields3.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray3[i] = resultFields3.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields3.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray3[i] = ((SuperLexical) resultFields3.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray3, actualResultFieldNamesArray3);
		assertArrayEquals(expectedResultFieldTypesArray3, actualResultFieldTypesArray3);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray3, actualCanonicalModelConstructNamesArray3);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray3, actualParentCanonicalModelConstructNamesArray3);

		MappingOperator input12Operator = input1Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input12Operator);
		assertEquals("o", input12Operator.getVariableName());
		assertNull(input12Operator.getLhsInput());
		assertNull(input12Operator.getRhsInput());
		assertEquals("countrye", ((ScanOperator) input12Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input12Operator).getReconcilingExpression());
		assertEquals("o.codee = 'GB' or o.codee = 'D'", ((ScanOperator) input12Operator).getReconcilingExpression().getExpression());
		assertEquals("and", ((ScanOperator) input12Operator).getAndOr());

		assertNotNull(input12Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input12Operator.getDataSource());

		assertEquals(2, ((ScanOperator) input12Operator).getPredicates().size());

		Set<Predicate> predicates = ((ScanOperator) input12Operator).getPredicates();

		int k = 0;

		for (Predicate predicate2 : predicates) {
			if (k == 0) {
				//Predicate predicate2 = ((ScanOperator) input12Operator).getPredicates().get(0);
				assertEquals("codee", predicate2.getSuperLexical1().getName());
				assertEquals("countrye", predicate2.getSuperLexical1().getParentSuperAbstract().getName());
				assertEquals("=", predicate2.getOperator());
				assertEquals("'GB'", predicate2.getLiteral2());
				assertEquals("and", predicate2.getAndOr());
				assertNull(predicate2.getLiteral1());
				assertNull(predicate2.getSuperLexical2());
			} else if (k == 1) {
				//Predicate predicate3 = ((ScanOperator) input12Operator).getPredicates().get(1);
				assertEquals("codee", predicate2.getSuperLexical1().getName());
				assertEquals("countrye", predicate2.getSuperLexical1().getParentSuperAbstract().getName());
				assertEquals("=", predicate2.getOperator());
				assertEquals("'D'", predicate2.getLiteral2());
				assertEquals("or", predicate2.getAndOr());
				assertNull(predicate2.getLiteral1());
				assertNull(predicate2.getSuperLexical2());
			}
			k++;
		}
		assertNotNull(input12Operator.getResultType());
		ResultType resultType4 = input12Operator.getResultType();
		assertEquals(6, resultType4.getResultFields().size());
		String[] expectedResultFieldNamesArray4 = { "o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		DataType[] expectedResultFieldTypesArray4 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT,
				DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray4 = { "namee", "codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray4 = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray4 = new String[6];
		DataType[] actualResultFieldTypesArray4 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray4 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray4 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields4 = resultType4.getResultFields();
		Set<String> resultFieldNames4 = resultFields4.keySet();
		for (String resultFieldName : resultFieldNames4) {
			actualResultFieldNamesArray4[i] = resultFieldName;
			actualResultFieldTypesArray4[i] = resultFields4.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray4[i] = resultFields4.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields4.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray4[i] = ((SuperLexical) resultFields4.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray4, actualResultFieldNamesArray4);
		assertArrayEquals(expectedResultFieldTypesArray4, actualResultFieldTypesArray4);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray4, actualCanonicalModelConstructNamesArray4);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray4, actualParentCanonicalModelConstructNamesArray4);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectStarFromJoinQueryTwoSources() {
		String selectStarFromJoinQuery = "Select * from countrye, ethnicgroupe where countrye.codee = ethnicgroupe.countrye";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");
		Schema mondialLanguageEconomyReligionOfCountriesEuropeWRSchema = schemaRepository
				.getSchemaByName("MondialLanguageEconomyReligionOfCountriesEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);
		DataSource mondialLanguageEconomyReligionOfCountriesEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialLanguageEconomyReligionOfCountriesEuropeWR");
		logger.debug("mondialLanguageEconomyReligionOfCountriesEuropeWithRenameDS: " + mondialLanguageEconomyReligionOfCountriesEuropeWithRenameDS);

		Query query = new Query(queryName, selectStarFromJoinQuery);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		query.addSchema(mondialLanguageEconomyReligionOfCountriesEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);
		//query.addDataSource(mondialLanguageEconomyReligionOfCountriesEuropeWithRenameDS);

		CommonTree selectStarFromJoinQueryAst = parser.parseSQL(selectStarFromJoinQuery);
		logger.debug("selectStarFromJoinQueryAst: " + selectStarFromJoinQueryAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectStarFromJoinQuery, selectStarFromJoinQueryAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(9, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals(
				"countrye.namee, countrye.codee, countrye.capitale, countrye.provincee, countrye.areae, countrye.populatione, ethnicgroupe.countrye, ethnicgroupe.namee, ethnicgroupe.percentagee",
				((ReduceOperator) rootOperator).getReconcilingExpression().getExpression());

		assertNull(rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[9];
		String[] superAbstractNamesArray = new String[9];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "codee", "capitale", "provincee", "areae", "populatione", "countrye", "namee",
				"percentagee" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye", "ethnicgroupe",
				"ethnicgroupe", "ethnicgroupe" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[9];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee",
				"countrye.areae", "countrye.populatione", "ethnicgroupe.countrye", "ethnicgroupe.namee", "ethnicgroupe.percentagee" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType0 = rootOperator.getResultType();
		assertEquals(9, resultType0.getResultFields().size());
		String[] expectedResultFieldNamesArray0 = { "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione", "ethnicgroupe.countrye", "ethnicgroupe.namee", "ethnicgroupe.percentagee" };
		DataType[] expectedResultFieldTypesArray0 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT,
				DataType.INTEGER, DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray0 = { "namee", "codee", "capitale", "provincee", "areae", "populatione", "countrye",
				"namee", "percentagee" };
		String[] exptectedParentCanonicalModelConstructNamesArray0 = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye",
				"ethnicgroupe", "ethnicgroupe", "ethnicgroupe" };

		String[] actualResultFieldNamesArray0 = new String[9];
		DataType[] actualResultFieldTypesArray0 = new DataType[9];
		String[] actualCanonicalModelConstructNamesArray0 = new String[9];
		String[] actualParentCanonicalModelConstructNamesArray0 = new String[9];

		i = 0;
		Map<String, ResultField> resultFields0 = resultType0.getResultFields();
		Set<String> resultFieldNames0 = resultFields0.keySet();
		for (String resultFieldName : resultFieldNames0) {
			actualResultFieldNamesArray0[i] = resultFieldName;
			actualResultFieldTypesArray0[i] = resultFields0.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultFields0.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields0.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultFields0.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray0, actualResultFieldNamesArray0);
		assertArrayEquals(expectedResultFieldTypesArray0, actualResultFieldTypesArray0);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray0, actualCanonicalModelConstructNamesArray0);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray0, actualParentCanonicalModelConstructNamesArray0);

		MappingOperator input0Operator = rootOperator.getLhsInput();

		isInstanceOf(JoinOperator.class, input0Operator);
		assertNull(input0Operator.getVariableName());
		assertNotNull(((JoinOperator) input0Operator).getReconcilingExpression());
		assertEquals("countrye.codee = ethnicgroupe.countrye", ((JoinOperator) input0Operator).getReconcilingExpression().getExpression());
		assertNotNull(input0Operator.getLhsInput());
		assertNotNull(input0Operator.getRhsInput());
		assertEquals(input0Operator.getInput(), input0Operator.getLhsInput());

		assertNull(input0Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input0Operator).getPredicates().size());
		Predicate predicate = ((JoinOperator) input0Operator).getPredicates().iterator().next();
		assertEquals("codee", predicate.getSuperLexical1().getName());
		assertEquals("countrye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate.getOperator());
		assertEquals("countrye", predicate.getSuperLexical2().getName());
		assertEquals("ethnicgroupe", predicate.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate.getLiteral1());
		assertNull(predicate.getLiteral2());

		assertNotNull(input0Operator.getResultType());
		ResultType resultType = input0Operator.getResultType();
		assertEquals(9, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione", "ethnicgroupe.countrye", "ethnicgroupe.namee", "ethnicgroupe.percentagee" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT,
				DataType.INTEGER, DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "codee", "capitale", "provincee", "areae", "populatione", "countrye",
				"namee", "percentagee" };
		String[] exptectedParentCanonicalModelConstructNamesArray = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye",
				"ethnicgroupe", "ethnicgroupe", "ethnicgroupe" };

		String[] actualResultFieldNamesArray = new String[9];
		DataType[] actualResultFieldTypesArray = new DataType[9];
		String[] actualCanonicalModelConstructNamesArray = new String[9];
		String[] actualParentCanonicalModelConstructNamesArray = new String[9];

		i = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[i] = resultFieldName;
			actualResultFieldTypesArray[i] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input1Operator = input0Operator.getLhsInput();
		isInstanceOf(ScanOperator.class, input1Operator);
		assertEquals("countrye", input1Operator.getVariableName());
		assertNull(input1Operator.getLhsInput());
		assertNull(input1Operator.getRhsInput());
		assertEquals("countrye", ((ScanOperator) input1Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input1Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input1Operator).getPredicates().size());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertNotNull(input1Operator.getResultType());
		ResultType resultType2 = input1Operator.getResultType();
		assertEquals(6, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT,
				DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray2 = { "namee", "codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray2 = new String[6];
		DataType[] actualResultFieldTypesArray2 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray2 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);

		MappingOperator input2Operator = input0Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input2Operator);
		assertEquals("ethnicgroupe", input2Operator.getVariableName());
		assertNull(input2Operator.getLhsInput());
		assertNull(input2Operator.getRhsInput());
		assertEquals("ethnicgroupe", ((ScanOperator) input2Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input2Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input2Operator).getPredicates().size());

		assertNotNull(input2Operator.getDataSource());
		assertEquals(mondialLanguageEconomyReligionOfCountriesEuropeWithRenameDS, input2Operator.getDataSource());

		assertNotNull(input2Operator.getResultType());
		ResultType resultType3 = input2Operator.getResultType();
		assertEquals(3, resultType3.getResultFields().size());
		String[] expectedResultFieldNamesArray3 = { "ethnicgroupe.countrye", "ethnicgroupe.namee", "ethnicgroupe.percentagee" };
		DataType[] expectedResultFieldTypesArray3 = { DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray3 = { "countrye", "namee", "percentagee" };
		String[] exptectedParentCanonicalModelConstructNamesArray3 = { "ethnicgroupe", "ethnicgroupe", "ethnicgroupe" };

		String[] actualResultFieldNamesArray3 = new String[3];
		DataType[] actualResultFieldTypesArray3 = new DataType[3];
		String[] actualCanonicalModelConstructNamesArray3 = new String[3];
		String[] actualParentCanonicalModelConstructNamesArray3 = new String[3];

		i = 0;
		Map<String, ResultField> resultFields3 = resultType3.getResultFields();
		Set<String> resultFieldNames3 = resultFields3.keySet();
		for (String resultFieldName : resultFieldNames3) {
			actualResultFieldNamesArray3[i] = resultFieldName;
			actualResultFieldTypesArray3[i] = resultFields3.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray3[i] = resultFields3.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields3.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray3[i] = ((SuperLexical) resultFields3.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray3, actualResultFieldNamesArray3);
		assertArrayEquals(expectedResultFieldTypesArray3, actualResultFieldTypesArray3);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray3, actualCanonicalModelConstructNamesArray3);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray3, actualParentCanonicalModelConstructNamesArray3);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectStarFromJoinWhereAndQueryTwoSources() {
		String selectStarFromJoinQuery = "Select * from countrye, ethnicgroupe where countrye.codee = ethnicgroupe.countrye and countrye.codee = 'GB' and ethnicgroupe.namee = 'English'";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");
		Schema mondialLanguageEconomyReligionOfCountriesEuropeWRSchema = schemaRepository
				.getSchemaByName("MondialLanguageEconomyReligionOfCountriesEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);
		DataSource mondialLanguageEconomyReligionOfCountriesEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialLanguageEconomyReligionOfCountriesEuropeWR");
		logger.debug("mondialLanguageEconomyReligionOfCountriesEuropeWithRenameDS: " + mondialLanguageEconomyReligionOfCountriesEuropeWithRenameDS);

		Query query = new Query(queryName, selectStarFromJoinQuery);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		query.addSchema(mondialLanguageEconomyReligionOfCountriesEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);
		//query.addDataSource(mondialLanguageEconomyReligionOfCountriesEuropeWithRenameDS);

		CommonTree selectStarFromJoinQueryAst = parser.parseSQL(selectStarFromJoinQuery);
		logger.debug("selectStarFromJoinQueryAst: " + selectStarFromJoinQueryAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectStarFromJoinQuery, selectStarFromJoinQueryAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(9, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals(
				"countrye.namee, countrye.codee, countrye.capitale, countrye.provincee, countrye.areae, countrye.populatione, ethnicgroupe.countrye, ethnicgroupe.namee, ethnicgroupe.percentagee",
				((ReduceOperator) rootOperator).getReconcilingExpression().getExpression());

		assertNull(rootOperator.getDataSource());
		//assertEquals(mondialSmall1DS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[9];
		String[] superAbstractNamesArray = new String[9];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "codee", "capitale", "provincee", "areae", "populatione", "countrye", "namee",
				"percentagee" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye", "ethnicgroupe",
				"ethnicgroupe", "ethnicgroupe" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[9];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee",
				"countrye.areae", "countrye.populatione", "ethnicgroupe.countrye", "ethnicgroupe.namee", "ethnicgroupe.percentagee" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType0 = rootOperator.getResultType();
		assertEquals(9, resultType0.getResultFields().size());
		String[] expectedResultFieldNamesArray0 = { "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione", "ethnicgroupe.countrye", "ethnicgroupe.namee", "ethnicgroupe.percentagee" };
		DataType[] expectedResultFieldTypesArray0 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT,
				DataType.INTEGER, DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray0 = { "namee", "codee", "capitale", "provincee", "areae", "populatione", "countrye",
				"namee", "percentagee" };
		String[] exptectedParentCanonicalModelConstructNamesArray0 = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye",
				"ethnicgroupe", "ethnicgroupe", "ethnicgroupe" };

		String[] actualResultFieldNamesArray0 = new String[9];
		DataType[] actualResultFieldTypesArray0 = new DataType[9];
		String[] actualCanonicalModelConstructNamesArray0 = new String[9];
		String[] actualParentCanonicalModelConstructNamesArray0 = new String[9];

		i = 0;
		Map<String, ResultField> resultFields0 = resultType0.getResultFields();
		Set<String> resultFieldNames0 = resultFields0.keySet();
		for (String resultFieldName : resultFieldNames0) {
			actualResultFieldNamesArray0[i] = resultFieldName;
			actualResultFieldTypesArray0[i] = resultFields0.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultFields0.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields0.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultFields0.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray0, actualResultFieldNamesArray0);
		assertArrayEquals(expectedResultFieldTypesArray0, actualResultFieldTypesArray0);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray0, actualCanonicalModelConstructNamesArray0);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray0, actualParentCanonicalModelConstructNamesArray0);

		MappingOperator input0Operator = rootOperator.getLhsInput();

		isInstanceOf(JoinOperator.class, input0Operator);
		assertNull(input0Operator.getVariableName());
		assertNotNull(((JoinOperator) input0Operator).getReconcilingExpression());
		assertEquals("countrye.codee = ethnicgroupe.countrye", ((JoinOperator) input0Operator).getReconcilingExpression().getExpression());
		assertNotNull(input0Operator.getLhsInput());
		assertNotNull(input0Operator.getRhsInput());
		assertEquals(input0Operator.getInput(), input0Operator.getLhsInput());

		assertNull(input0Operator.getDataSource());
		//assertEquals(mondialSmall1DS, input0Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input0Operator).getPredicates().size());
		Predicate predicate = ((JoinOperator) input0Operator).getPredicates().iterator().next();
		assertEquals("codee", predicate.getSuperLexical1().getName());
		assertEquals("countrye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate.getOperator());
		assertEquals("countrye", predicate.getSuperLexical2().getName());
		assertEquals("ethnicgroupe", predicate.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate.getLiteral1());
		assertNull(predicate.getLiteral2());

		assertNotNull(input0Operator.getResultType());
		ResultType resultType = input0Operator.getResultType();
		assertEquals(9, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione", "ethnicgroupe.countrye", "ethnicgroupe.namee", "ethnicgroupe.percentagee" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT,
				DataType.INTEGER, DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "codee", "capitale", "provincee", "areae", "populatione", "countrye",
				"namee", "percentagee" };
		String[] exptectedParentCanonicalModelConstructNamesArray = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye",
				"ethnicgroupe", "ethnicgroupe", "ethnicgroupe" };

		String[] actualResultFieldNamesArray = new String[9];
		DataType[] actualResultFieldTypesArray = new DataType[9];
		String[] actualCanonicalModelConstructNamesArray = new String[9];
		String[] actualParentCanonicalModelConstructNamesArray = new String[9];

		i = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[i] = resultFieldName;
			actualResultFieldTypesArray[i] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input1Operator = input0Operator.getLhsInput();
		isInstanceOf(ScanOperator.class, input1Operator);
		assertEquals("countrye", input1Operator.getVariableName());
		assertNull(input1Operator.getLhsInput());
		assertNull(input1Operator.getRhsInput());
		assertEquals("countrye", ((ScanOperator) input1Operator).getSuperAbstract().getName());
		assertEquals("countrye.codee = 'GB'", ((ScanOperator) input1Operator).getReconcilingExpression().getExpression());
		assertEquals("and", ((ScanOperator) input1Operator).getAndOr());

		assertEquals(1, ((ScanOperator) input1Operator).getPredicates().size());
		Predicate predicate1 = ((ScanOperator) input1Operator).getPredicates().iterator().next();
		assertEquals("codee", predicate1.getSuperLexical1().getName());
		assertEquals("countrye", predicate1.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate1.getOperator());
		assertEquals("'GB'", predicate1.getLiteral2());
		assertEquals("and", predicate1.getAndOr());
		assertNull(predicate1.getLiteral1());
		assertNull(predicate1.getSuperLexical2());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertNotNull(input1Operator.getResultType());
		ResultType resultType2 = input1Operator.getResultType();
		assertEquals(6, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT,
				DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray2 = { "namee", "codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray2 = new String[6];
		DataType[] actualResultFieldTypesArray2 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray2 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);

		MappingOperator input2Operator = input0Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input2Operator);
		assertEquals("ethnicgroupe", input2Operator.getVariableName());
		assertNull(input2Operator.getLhsInput());
		assertNull(input2Operator.getRhsInput());
		assertEquals("ethnicgroupe", ((ScanOperator) input2Operator).getSuperAbstract().getName());
		assertEquals("ethnicgroupe.namee = 'English'", ((ScanOperator) input2Operator).getReconcilingExpression().getExpression());
		assertEquals("and", ((ScanOperator) input2Operator).getAndOr());

		assertEquals(1, ((ScanOperator) input2Operator).getPredicates().size());
		Predicate predicate2 = ((ScanOperator) input2Operator).getPredicates().iterator().next();
		assertEquals("namee", predicate2.getSuperLexical1().getName());
		assertEquals("ethnicgroupe", predicate2.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate2.getOperator());
		assertEquals("'English'", predicate2.getLiteral2());
		assertEquals("and", predicate2.getAndOr());
		assertNull(predicate2.getLiteral1());
		assertNull(predicate2.getSuperLexical2());

		assertNotNull(input2Operator.getDataSource());
		assertEquals(mondialLanguageEconomyReligionOfCountriesEuropeWithRenameDS, input2Operator.getDataSource());

		assertNotNull(input2Operator.getResultType());
		ResultType resultType3 = input2Operator.getResultType();
		assertEquals(3, resultType3.getResultFields().size());
		String[] expectedResultFieldNamesArray3 = { "ethnicgroupe.countrye", "ethnicgroupe.namee", "ethnicgroupe.percentagee" };
		DataType[] expectedResultFieldTypesArray3 = { DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray3 = { "countrye", "namee", "percentagee" };
		String[] exptectedParentCanonicalModelConstructNamesArray3 = { "ethnicgroupe", "ethnicgroupe", "ethnicgroupe" };

		String[] actualResultFieldNamesArray3 = new String[3];
		DataType[] actualResultFieldTypesArray3 = new DataType[3];
		String[] actualCanonicalModelConstructNamesArray3 = new String[3];
		String[] actualParentCanonicalModelConstructNamesArray3 = new String[3];

		i = 0;
		Map<String, ResultField> resultFields3 = resultType3.getResultFields();
		Set<String> resultFieldNames3 = resultFields3.keySet();
		for (String resultFieldName : resultFieldNames3) {
			actualResultFieldNamesArray3[i] = resultFieldName;
			actualResultFieldTypesArray3[i] = resultFields3.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray3[i] = resultFields3.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields3.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray3[i] = ((SuperLexical) resultFields3.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray3, actualResultFieldNamesArray3);
		assertArrayEquals(expectedResultFieldTypesArray3, actualResultFieldTypesArray3);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray3, actualCanonicalModelConstructNamesArray3);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray3, actualParentCanonicalModelConstructNamesArray3);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectSuperLexicalsFromJoinWhereAndQueryTwoSources() {
		String selectStarFromJoinQuery = "Select countrye.namee, countrye.codee, countrye.capitale, ethnicgroupe.namee, ethnicgroupe.percentagee from countrye, ethnicgroupe where countrye.codee = ethnicgroupe.countrye  and countrye.codee = 'GB' and ethnicgroupe.namee = 'English'";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");
		Schema mondialLanguageEconomyReligionOfCountriesEuropeWRSchema = schemaRepository
				.getSchemaByName("MondialLanguageEconomyReligionOfCountriesEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);
		DataSource mondialLanguageEconomyReligionOfCountriesEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialLanguageEconomyReligionOfCountriesEuropeWR");
		logger.debug("mondialLanguageEconomyReligionOfCountriesEuropeWithRenameDS: " + mondialLanguageEconomyReligionOfCountriesEuropeWithRenameDS);

		Query query = new Query(queryName, selectStarFromJoinQuery);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		query.addSchema(mondialLanguageEconomyReligionOfCountriesEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);
		//query.addDataSource(mondialLanguageEconomyReligionOfCountriesEuropeWithRenameDS);

		CommonTree selectStarFromJoinQueryAst = parser.parseSQL(selectStarFromJoinQuery);
		logger.debug("selectStarFromJoinQueryAst: " + selectStarFromJoinQueryAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectStarFromJoinQuery, selectStarFromJoinQueryAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(5, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals("countrye.namee, countrye.codee, countrye.capitale, ethnicgroupe.namee, ethnicgroupe.percentagee",
				((ReduceOperator) rootOperator).getReconcilingExpression().getExpression());

		assertNull(rootOperator.getDataSource());
		//assertEquals(mondialSmall1DS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[5];
		String[] superAbstractNamesArray = new String[5];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "codee", "capitale", "namee", "percentagee" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "countrye", "countrye", "countrye", "ethnicgroupe", "ethnicgroupe" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[5];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "countrye.namee", "countrye.codee", "countrye.capitale", "ethnicgroupe.namee",
				"ethnicgroupe.percentagee" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType0 = rootOperator.getResultType();
		assertEquals(5, resultType0.getResultFields().size());
		String[] expectedResultFieldNamesArray0 = { "countrye.namee", "countrye.codee", "countrye.capitale", "ethnicgroupe.namee",
				"ethnicgroupe.percentagee" };
		DataType[] expectedResultFieldTypesArray0 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray0 = { "namee", "codee", "capitale", "namee", "percentagee" };
		String[] exptectedParentCanonicalModelConstructNamesArray0 = { "countrye", "countrye", "countrye", "ethnicgroupe", "ethnicgroupe" };

		String[] actualResultFieldNamesArray0 = new String[5];
		DataType[] actualResultFieldTypesArray0 = new DataType[5];
		String[] actualCanonicalModelConstructNamesArray0 = new String[5];
		String[] actualParentCanonicalModelConstructNamesArray0 = new String[5];

		i = 0;
		Map<String, ResultField> resultFields0 = resultType0.getResultFields();
		Set<String> resultFieldNames0 = resultFields0.keySet();
		for (String resultFieldName : resultFieldNames0) {
			actualResultFieldNamesArray0[i] = resultFieldName;
			actualResultFieldTypesArray0[i] = resultFields0.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultFields0.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields0.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultFields0.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray0, actualResultFieldNamesArray0);
		assertArrayEquals(expectedResultFieldTypesArray0, actualResultFieldTypesArray0);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray0, actualCanonicalModelConstructNamesArray0);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray0, actualParentCanonicalModelConstructNamesArray0);

		MappingOperator input0Operator = rootOperator.getLhsInput();

		isInstanceOf(JoinOperator.class, input0Operator);
		assertNull(input0Operator.getVariableName());
		assertNotNull(((JoinOperator) input0Operator).getReconcilingExpression());
		assertEquals("countrye.codee = ethnicgroupe.countrye", ((JoinOperator) input0Operator).getReconcilingExpression().getExpression());
		assertNotNull(input0Operator.getLhsInput());
		assertNotNull(input0Operator.getRhsInput());
		assertEquals(input0Operator.getInput(), input0Operator.getLhsInput());

		assertNull(input0Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input0Operator).getPredicates().size());
		Predicate predicate = ((JoinOperator) input0Operator).getPredicates().iterator().next();
		assertEquals("codee", predicate.getSuperLexical1().getName());
		assertEquals("countrye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate.getOperator());
		assertEquals("countrye", predicate.getSuperLexical2().getName());
		assertEquals("ethnicgroupe", predicate.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate.getLiteral1());
		assertNull(predicate.getLiteral2());

		assertNotNull(input0Operator.getResultType());
		ResultType resultType = input0Operator.getResultType();
		assertEquals(9, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione", "ethnicgroupe.countrye", "ethnicgroupe.namee", "ethnicgroupe.percentagee" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT,
				DataType.INTEGER, DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "codee", "capitale", "provincee", "areae", "populatione", "countrye",
				"namee", "percentagee" };
		String[] exptectedParentCanonicalModelConstructNamesArray = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye",
				"ethnicgroupe", "ethnicgroupe", "ethnicgroupe" };

		String[] actualResultFieldNamesArray = new String[9];
		DataType[] actualResultFieldTypesArray = new DataType[9];
		String[] actualCanonicalModelConstructNamesArray = new String[9];
		String[] actualParentCanonicalModelConstructNamesArray = new String[9];

		i = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[i] = resultFieldName;
			actualResultFieldTypesArray[i] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input1Operator = input0Operator.getLhsInput();
		isInstanceOf(ScanOperator.class, input1Operator);
		assertEquals("countrye", input1Operator.getVariableName());
		assertNull(input1Operator.getLhsInput());
		assertNull(input1Operator.getRhsInput());
		assertEquals("countrye", ((ScanOperator) input1Operator).getSuperAbstract().getName());
		assertEquals("countrye.codee = 'GB'", ((ScanOperator) input1Operator).getReconcilingExpression().getExpression());
		assertEquals("and", ((ScanOperator) input1Operator).getAndOr());

		assertEquals(1, ((ScanOperator) input1Operator).getPredicates().size());
		Predicate predicate1 = ((ScanOperator) input1Operator).getPredicates().iterator().next();
		assertEquals("codee", predicate1.getSuperLexical1().getName());
		assertEquals("countrye", predicate1.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate1.getOperator());
		assertEquals("'GB'", predicate1.getLiteral2());
		assertEquals("and", predicate1.getAndOr());
		assertNull(predicate1.getLiteral1());
		assertNull(predicate1.getSuperLexical2());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertNotNull(input1Operator.getResultType());
		ResultType resultType2 = input1Operator.getResultType();
		assertEquals(6, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "countrye.namee", "countrye.codee", "countrye.capitale", "countrye.provincee", "countrye.areae",
				"countrye.populatione" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT,
				DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray2 = { "namee", "codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray2 = new String[6];
		DataType[] actualResultFieldTypesArray2 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray2 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);

		MappingOperator input2Operator = input0Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input2Operator);
		assertEquals("ethnicgroupe", input2Operator.getVariableName());
		assertNull(input2Operator.getLhsInput());
		assertNull(input2Operator.getRhsInput());
		assertEquals("ethnicgroupe", ((ScanOperator) input2Operator).getSuperAbstract().getName());
		assertEquals("ethnicgroupe.namee = 'English'", ((ScanOperator) input2Operator).getReconcilingExpression().getExpression());
		assertEquals("and", ((ScanOperator) input2Operator).getAndOr());

		assertEquals(1, ((ScanOperator) input2Operator).getPredicates().size());
		Predicate predicate2 = ((ScanOperator) input2Operator).getPredicates().iterator().next();
		assertEquals("namee", predicate2.getSuperLexical1().getName());
		assertEquals("ethnicgroupe", predicate2.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate2.getOperator());
		assertEquals("'English'", predicate2.getLiteral2());
		assertEquals("and", predicate2.getAndOr());
		assertNull(predicate2.getLiteral1());
		assertNull(predicate2.getSuperLexical2());

		assertNotNull(input2Operator.getDataSource());
		assertEquals(mondialLanguageEconomyReligionOfCountriesEuropeWithRenameDS, input2Operator.getDataSource());

		assertNotNull(input2Operator.getResultType());
		ResultType resultType3 = input2Operator.getResultType();
		assertEquals(3, resultType3.getResultFields().size());
		String[] expectedResultFieldNamesArray3 = { "ethnicgroupe.countrye", "ethnicgroupe.namee", "ethnicgroupe.percentagee" };
		DataType[] expectedResultFieldTypesArray3 = { DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray3 = { "countrye", "namee", "percentagee" };
		String[] exptectedParentCanonicalModelConstructNamesArray3 = { "ethnicgroupe", "ethnicgroupe", "ethnicgroupe" };

		String[] actualResultFieldNamesArray3 = new String[3];
		DataType[] actualResultFieldTypesArray3 = new DataType[3];
		String[] actualCanonicalModelConstructNamesArray3 = new String[3];
		String[] actualParentCanonicalModelConstructNamesArray3 = new String[3];

		i = 0;
		Map<String, ResultField> resultFields3 = resultType3.getResultFields();
		Set<String> resultFieldNames3 = resultFields3.keySet();
		for (String resultFieldName : resultFieldNames3) {
			actualResultFieldNamesArray3[i] = resultFieldName;
			actualResultFieldTypesArray3[i] = resultFields3.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray3[i] = resultFields3.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields3.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray3[i] = ((SuperLexical) resultFields3.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray3, actualResultFieldNamesArray3);
		assertArrayEquals(expectedResultFieldTypesArray3, actualResultFieldTypesArray3);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray3, actualCanonicalModelConstructNamesArray3);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray3, actualParentCanonicalModelConstructNamesArray3);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectSuperLexicalsFromJoinJoinJoinWhereAndQueryWithVariableNameTwoSources() {
		String selectSuperLexicalsFromJoinJoinWhereAndQueryWithVariableName = "Select c.namee, c.countrye, c.provincee, o.namee, o.capitale, o.populatione, b.country1e, b.country2e, g.namee, g.percentagee from citye c, countrye o, borderse b, ethnicgroupe g where c.countrye = o.codee and o.codee = b.country1e and o.codee = g.countrye and o.codee = 'GB' and c.namee = 'Manchester'";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");
		Schema mondialLanguageEconomyReligionOfCountriesEuropeWRSchema = schemaRepository
				.getSchemaByName("MondialLanguageEconomyReligionOfCountriesEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);
		DataSource mondialLanguageEconomyReligionOfCountriesEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialLanguageEconomyReligionOfCountriesEuropeWR");
		logger.debug("mondialLanguageEconomyReligionOfCountriesEuropeWithRenameDS: " + mondialLanguageEconomyReligionOfCountriesEuropeWithRenameDS);

		Query query = new Query(queryName, selectSuperLexicalsFromJoinJoinWhereAndQueryWithVariableName);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		query.addSchema(mondialLanguageEconomyReligionOfCountriesEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);
		//query.addDataSource(mondialLanguageEconomyReligionOfCountriesEuropeWithRenameDS);

		CommonTree selectSuperLexicalsFromJoinJoinWhereAndQueryWithVariableNameAst = parser
				.parseSQL(selectSuperLexicalsFromJoinJoinWhereAndQueryWithVariableName);
		logger.debug("selectSuperLexicalsFromJoinJoinWhereAndQueryWithVariableNameAst: "
				+ selectSuperLexicalsFromJoinJoinWhereAndQueryWithVariableNameAst.toStringTree());
		query = globalTranslator.translateAstIntoQuery(query, selectSuperLexicalsFromJoinJoinWhereAndQueryWithVariableName,
				selectSuperLexicalsFromJoinJoinWhereAndQueryWithVariableNameAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(10, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals("c.namee, c.countrye, c.provincee, o.namee, o.capitale, o.populatione, b.country1e, b.country2e, g.namee, g.percentagee",
				((ReduceOperator) rootOperator).getReconcilingExpression().getExpression());

		assertNull(rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[10];
		String[] superAbstractNamesArray = new String[10];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "namee", "capitale", "populatione", "country1e", "country2e",
				"namee", "percentagee" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "countrye", "countrye", "countrye", "borderse", "borderse",
				"ethnicgroupe", "ethnicgroupe" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[10];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "c.namee", "c.countrye", "c.provincee", "o.namee", "o.capitale", "o.populatione",
				"b.country1e", "b.country2e", "g.namee", "g.percentagee" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType = rootOperator.getResultType();
		assertEquals(10, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "c.namee", "c.countrye", "c.provincee", "o.namee", "o.capitale", "o.populatione", "b.country1e",
				"b.country2e", "g.namee", "g.percentagee" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING,
				DataType.INTEGER, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "namee", "capitale", "populatione", "country1e",
				"country2e", "namee", "percentagee" };
		String[] expectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "countrye", "countrye", "countrye", "borderse",
				"borderse", "ethnicgroupe", "ethnicgroupe" };

		String[] actualResultFieldNamesArray = new String[10];
		DataType[] actualResultFieldTypesArray = new DataType[10];
		String[] actualCanonicalModelConstructNamesArray = new String[10];
		String[] actualParentCanonicalModelConstructNamesArray = new String[10];

		int j = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[j] = resultFieldName;
			actualResultFieldTypesArray[j] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[j] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[j] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			j++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(expectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator inputJEgOperator = rootOperator.getLhsInput();

		isInstanceOf(JoinOperator.class, inputJEgOperator);
		assertNull(inputJEgOperator.getVariableName());
		assertNotNull(((JoinOperator) inputJEgOperator).getReconcilingExpression());
		assertEquals("o.codee = g.countrye", ((JoinOperator) inputJEgOperator).getReconcilingExpression().getExpression());
		assertNotNull(inputJEgOperator.getLhsInput());
		assertNotNull(inputJEgOperator.getRhsInput());
		assertEquals(inputJEgOperator.getInput(), inputJEgOperator.getLhsInput());

		assertNull(inputJEgOperator.getDataSource());

		assertEquals(1, ((JoinOperator) inputJEgOperator).getPredicates().size());
		Predicate predicateJEg = ((JoinOperator) inputJEgOperator).getPredicates().iterator().next();
		assertEquals("codee", predicateJEg.getSuperLexical1().getName());
		assertEquals("countrye", predicateJEg.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicateJEg.getOperator());
		assertEquals("countrye", predicateJEg.getSuperLexical2().getName());
		assertEquals("ethnicgroupe", predicateJEg.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicateJEg.getLiteral1());
		assertNull(predicateJEg.getLiteral2());

		assertNotNull(inputJEgOperator.getResultType());
		ResultType resultTypeJEg = inputJEgOperator.getResultType();
		assertEquals(18, resultTypeJEg.getResultFields().size());
		String[] expectedResultFieldNamesArrayJEg = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee",
				"o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione", "b.country1e", "b.country2e", "b.lengthe",
				"g.countrye", "g.namee", "g.percentagee" };
		DataType[] expectedResultFieldTypesArrayJEg = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER,
				DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArrayJEg = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee",
				"namee", "codee", "capitale", "provincee", "areae", "populatione", "country1e", "country2e", "lengthe", "countrye", "namee",
				"percentagee" };
		String[] exptectedParentCanonicalModelConstructNamesArrayJEg = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye",
				"countrye", "countrye", "countrye", "countrye", "countrye", "borderse", "borderse", "borderse", "ethnicgroupe", "ethnicgroupe",
				"ethnicgroupe" };

		String[] actualResultFieldNamesArrayJEg = new String[18];
		DataType[] actualResultFieldTypesArrayJEg = new DataType[18];
		String[] actualCanonicalModelConstructNamesArrayJEg = new String[18];
		String[] actualParentCanonicalModelConstructNamesArrayJEg = new String[18];

		i = 0;
		Map<String, ResultField> resultFieldsJEg = resultTypeJEg.getResultFields();
		Set<String> resultFieldNamesJEg = resultFieldsJEg.keySet();
		for (String resultFieldName : resultFieldNamesJEg) {
			actualResultFieldNamesArrayJEg[i] = resultFieldName;
			actualResultFieldTypesArrayJEg[i] = resultFieldsJEg.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArrayJEg[i] = resultFieldsJEg.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFieldsJEg.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArrayJEg[i] = ((SuperLexical) resultFieldsJEg.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArrayJEg, actualResultFieldNamesArrayJEg);
		assertArrayEquals(expectedResultFieldTypesArrayJEg, actualResultFieldTypesArrayJEg);
		assertArrayEquals(expectedCanonicalModelConstructNamesArrayJEg, actualCanonicalModelConstructNamesArrayJEg);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArrayJEg, actualParentCanonicalModelConstructNamesArrayJEg);

		MappingOperator input0Operator = inputJEgOperator.getLhsInput();

		isInstanceOf(JoinOperator.class, input0Operator);
		assertNotNull(input0Operator.getVariableName());
		assertEquals("o", input0Operator.getVariableName());
		assertNotNull(((JoinOperator) input0Operator).getReconcilingExpression());
		assertEquals("o.codee = b.country1e", ((JoinOperator) input0Operator).getReconcilingExpression().getExpression());
		assertNotNull(input0Operator.getLhsInput());
		assertNotNull(input0Operator.getRhsInput());
		assertEquals(input0Operator.getInput(), input0Operator.getLhsInput());

		assertNotNull(input0Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input0Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input0Operator).getPredicates().size());
		Predicate predicate0 = ((JoinOperator) input0Operator).getPredicates().iterator().next();
		assertEquals("codee", predicate0.getSuperLexical1().getName());
		assertEquals("countrye", predicate0.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate0.getOperator());
		assertEquals("country1e", predicate0.getSuperLexical2().getName());
		assertEquals("borderse", predicate0.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate0.getLiteral1());
		assertNull(predicate0.getLiteral2());

		assertNotNull(input0Operator.getResultType());
		ResultType resultType0 = input0Operator.getResultType();
		assertEquals(15, resultType0.getResultFields().size());
		String[] expectedResultFieldNamesArray0 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee",
				"o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione", "b.country1e", "b.country2e", "b.lengthe" };
		DataType[] expectedResultFieldTypesArray0 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER,
				DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray0 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione", "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray0 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye", "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray0 = new String[15];
		DataType[] actualResultFieldTypesArray0 = new DataType[15];
		String[] actualCanonicalModelConstructNamesArray0 = new String[15];
		String[] actualParentCanonicalModelConstructNamesArray0 = new String[15];

		i = 0;
		Map<String, ResultField> resultFields0 = resultType0.getResultFields();
		Set<String> resultFieldNames0 = resultFields0.keySet();
		for (String resultFieldName : resultFieldNames0) {
			actualResultFieldNamesArray0[i] = resultFieldName;
			actualResultFieldTypesArray0[i] = resultFields0.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultFields0.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields0.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultFields0.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray0, actualResultFieldNamesArray0);
		assertArrayEquals(expectedResultFieldTypesArray0, actualResultFieldTypesArray0);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray0, actualCanonicalModelConstructNamesArray0);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray0, actualParentCanonicalModelConstructNamesArray0);

		MappingOperator inputSEgOperator = inputJEgOperator.getRhsInput();
		isInstanceOf(ScanOperator.class, inputSEgOperator);
		assertEquals("g", inputSEgOperator.getVariableName());
		assertNull(inputSEgOperator.getLhsInput());
		assertNull(inputSEgOperator.getRhsInput());
		assertEquals("ethnicgroupe", ((ScanOperator) inputSEgOperator).getSuperAbstract().getName());
		assertNull(((ScanOperator) inputSEgOperator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) inputSEgOperator).getPredicates().size());

		assertNotNull(inputSEgOperator.getDataSource());
		assertEquals(mondialLanguageEconomyReligionOfCountriesEuropeWithRenameDS, inputSEgOperator.getDataSource());

		assertNotNull(inputSEgOperator.getResultType());
		ResultType resultTypeSEg = inputSEgOperator.getResultType();
		assertEquals(3, resultTypeSEg.getResultFields().size());
		String[] expectedResultFieldNamesArraySEg = { "g.countrye", "g.namee", "g.percentagee" };
		DataType[] expectedResultFieldTypesArraySEg = { DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArraySEg = { "countrye", "namee", "percentagee" };
		String[] exptectedParentCanonicalModelConstructNamesArraySEg = { "ethnicgroupe", "ethnicgroupe", "ethnicgroupe" };

		String[] actualResultFieldNamesArraySEg = new String[3];
		DataType[] actualResultFieldTypesArraySEg = new DataType[3];
		String[] actualCanonicalModelConstructNamesArraySEg = new String[3];
		String[] actualParentCanonicalModelConstructNamesArraySEg = new String[3];

		i = 0;
		Map<String, ResultField> resultFieldsSEg = resultTypeSEg.getResultFields();
		Set<String> resultFieldNamesSEg = resultFieldsSEg.keySet();
		for (String resultFieldName : resultFieldNamesSEg) {
			actualResultFieldNamesArraySEg[i] = resultFieldName;
			actualResultFieldTypesArraySEg[i] = resultFieldsSEg.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArraySEg[i] = resultFieldsSEg.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFieldsSEg.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArraySEg[i] = ((SuperLexical) resultFieldsSEg.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArraySEg, actualResultFieldNamesArraySEg);
		assertArrayEquals(expectedResultFieldTypesArraySEg, actualResultFieldTypesArraySEg);
		assertArrayEquals(expectedCanonicalModelConstructNamesArraySEg, actualCanonicalModelConstructNamesArraySEg);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArraySEg, actualParentCanonicalModelConstructNamesArraySEg);

		MappingOperator input1Operator = input0Operator.getLhsInput();
		isInstanceOf(JoinOperator.class, input1Operator);
		assertNotNull(input1Operator.getVariableName());
		assertEquals("o", input1Operator.getVariableName());
		assertNotNull(((JoinOperator) input1Operator).getReconcilingExpression());
		assertEquals("c.countrye = o.codee", ((JoinOperator) input1Operator).getReconcilingExpression().getExpression());
		assertNotNull(input1Operator.getLhsInput());
		assertNotNull(input1Operator.getRhsInput());
		assertEquals(input1Operator.getInput(), input1Operator.getLhsInput());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input1Operator).getPredicates().size());
		Predicate predicate1 = ((JoinOperator) input1Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate1.getSuperLexical1().getName());
		assertEquals("citye", predicate1.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate1.getOperator());
		assertEquals("codee", predicate1.getSuperLexical2().getName());
		assertEquals("countrye", predicate1.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate1.getLiteral1());
		assertNull(predicate1.getLiteral2());

		assertNotNull(input1Operator.getResultType());
		ResultType resultType1 = input1Operator.getResultType();
		assertEquals(12, resultType1.getResultFields().size());
		String[] expectedResultFieldNamesArray1 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee",
				"o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		DataType[] expectedResultFieldTypesArray1 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT, DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray1 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee",
				"codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray1 = { "citye", "citye", "citye", "citye", "citye", "citye", "countrye", "countrye",
				"countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray1 = new String[12];
		DataType[] actualResultFieldTypesArray1 = new DataType[12];
		String[] actualCanonicalModelConstructNamesArray1 = new String[12];
		String[] actualParentCanonicalModelConstructNamesArray1 = new String[12];

		i = 0;
		Map<String, ResultField> resultFields1 = resultType1.getResultFields();
		Set<String> resultFieldNames1 = resultFields1.keySet();
		for (String resultFieldName : resultFieldNames1) {
			actualResultFieldNamesArray1[i] = resultFieldName;
			actualResultFieldTypesArray1[i] = resultFields1.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray1[i] = resultFields1.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields1.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray1[i] = ((SuperLexical) resultFields1.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray1, actualResultFieldNamesArray1);
		assertArrayEquals(expectedResultFieldTypesArray1, actualResultFieldTypesArray1);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray1, actualCanonicalModelConstructNamesArray1);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray1, actualParentCanonicalModelConstructNamesArray1);

		MappingOperator input2Operator = input0Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input2Operator);
		assertEquals("b", input2Operator.getVariableName());
		assertNull(input2Operator.getLhsInput());
		assertNull(input2Operator.getRhsInput());
		assertEquals("borderse", ((ScanOperator) input2Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input2Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input2Operator).getPredicates().size());

		assertNotNull(input2Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input2Operator.getDataSource());

		assertNotNull(input2Operator.getResultType());
		ResultType resultType2 = input2Operator.getResultType();
		assertEquals(3, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "b.country1e", "b.country2e", "b.lengthe" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "country1e", "country2e", "lengthe" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "borderse", "borderse", "borderse" };

		String[] actualResultFieldNamesArray2 = new String[3];
		DataType[] actualResultFieldTypesArray2 = new DataType[3];
		String[] actualCanonicalModelConstructNamesArray2 = new String[3];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[3];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);

		MappingOperator input11Operator = input1Operator.getLhsInput();
		isInstanceOf(ScanOperator.class, input11Operator);
		assertEquals("c", input11Operator.getVariableName());
		assertNull(input11Operator.getLhsInput());
		assertNull(input11Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input11Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input11Operator).getReconcilingExpression());
		assertEquals("c.namee = 'Manchester'", ((ScanOperator) input11Operator).getReconcilingExpression().getExpression());
		assertEquals("and", ((ScanOperator) input11Operator).getAndOr());

		assertNotNull(input11Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input11Operator.getDataSource());

		assertEquals(1, ((ScanOperator) input11Operator).getPredicates().size());
		Predicate predicate2 = ((ScanOperator) input11Operator).getPredicates().iterator().next();
		assertEquals("namee", predicate2.getSuperLexical1().getName());
		assertEquals("citye", predicate2.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate2.getOperator());
		assertEquals("'Manchester'", predicate2.getLiteral2());
		assertEquals("and", predicate2.getAndOr());
		assertNull(predicate2.getLiteral1());
		assertNull(predicate2.getSuperLexical2());

		assertNotNull(input11Operator.getResultType());
		ResultType resultType3 = input11Operator.getResultType();
		assertEquals(6, resultType3.getResultFields().size());
		String[] expectedResultFieldNamesArray3 = { "c.namee", "c.countrye", "c.provincee", "c.populatione", "c.longitudee", "c.latitudee" };
		DataType[] expectedResultFieldTypesArray3 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray3 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray3 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray3 = new String[6];
		DataType[] actualResultFieldTypesArray3 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray3 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray3 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields3 = resultType3.getResultFields();
		Set<String> resultFieldNames3 = resultFields3.keySet();
		for (String resultFieldName : resultFieldNames3) {
			actualResultFieldNamesArray3[i] = resultFieldName;
			actualResultFieldTypesArray3[i] = resultFields3.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray3[i] = resultFields3.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields3.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray3[i] = ((SuperLexical) resultFields3.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray3, actualResultFieldNamesArray3);
		assertArrayEquals(expectedResultFieldTypesArray3, actualResultFieldTypesArray3);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray3, actualCanonicalModelConstructNamesArray3);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray3, actualParentCanonicalModelConstructNamesArray3);

		MappingOperator input12Operator = input1Operator.getRhsInput();
		isInstanceOf(ScanOperator.class, input12Operator);
		assertEquals("o", input12Operator.getVariableName());
		assertNull(input12Operator.getLhsInput());
		assertNull(input12Operator.getRhsInput());
		assertEquals("countrye", ((ScanOperator) input12Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input12Operator).getReconcilingExpression());
		assertEquals("o.codee = 'GB'", ((ScanOperator) input12Operator).getReconcilingExpression().getExpression());
		assertEquals("and", ((ScanOperator) input12Operator).getAndOr());

		assertNotNull(input12Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input12Operator.getDataSource());

		assertEquals(1, ((ScanOperator) input12Operator).getPredicates().size());
		Predicate predicate3 = ((ScanOperator) input12Operator).getPredicates().iterator().next();
		assertEquals("codee", predicate3.getSuperLexical1().getName());
		assertEquals("countrye", predicate3.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate3.getOperator());
		assertEquals("'GB'", predicate3.getLiteral2());
		assertEquals("and", predicate3.getAndOr());
		assertNull(predicate3.getLiteral1());
		assertNull(predicate3.getSuperLexical2());

		assertNotNull(input12Operator.getResultType());
		ResultType resultType4 = input12Operator.getResultType();
		assertEquals(6, resultType4.getResultFields().size());
		String[] expectedResultFieldNamesArray4 = { "o.namee", "o.codee", "o.capitale", "o.provincee", "o.areae", "o.populatione" };
		DataType[] expectedResultFieldTypesArray4 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.STRING, DataType.FLOAT,
				DataType.INTEGER };
		String[] expectedCanonicalModelConstructNamesArray4 = { "namee", "codee", "capitale", "provincee", "areae", "populatione" };
		String[] exptectedParentCanonicalModelConstructNamesArray4 = { "countrye", "countrye", "countrye", "countrye", "countrye", "countrye" };

		String[] actualResultFieldNamesArray4 = new String[6];
		DataType[] actualResultFieldTypesArray4 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray4 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray4 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields4 = resultType4.getResultFields();
		Set<String> resultFieldNames4 = resultFields4.keySet();
		for (String resultFieldName : resultFieldNames4) {
			actualResultFieldNamesArray4[i] = resultFieldName;
			actualResultFieldTypesArray4[i] = resultFields4.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray4[i] = resultFields4.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields4.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray4[i] = ((SuperLexical) resultFields4.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray4, actualResultFieldNamesArray4);
		assertArrayEquals(expectedResultFieldTypesArray4, actualResultFieldTypesArray4);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray4, actualCanonicalModelConstructNamesArray4);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray4, actualParentCanonicalModelConstructNamesArray4);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectStarSubqueryQueryOneSource() {
		String selectStarSubqueryQuery = "Select * from citye where citye.namee in (Select citye.namee from citye where citye.countrye = 'GB')";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectStarSubqueryQuery);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectStarSubqueryQueryAst = parser.parseSQL(selectStarSubqueryQuery);
		logger.debug("selectStarSubqueryQueryAst: " + selectStarSubqueryQueryAst.toStringTree());

		query = globalTranslator.translateAstIntoQuery(query, selectStarSubqueryQuery, selectStarSubqueryQueryAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(7, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals("citye.namee, citye.countrye, citye.provincee, citye.populatione, citye.longitudee, citye.latitudee, subquery1.citye.namee",
				((ReduceOperator) rootOperator).getReconcilingExpression().getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[7];
		String[] superAbstractNamesArray = new String[7];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye", "citye" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[7];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione",
				"citye.longitudee", "citye.latitudee", "subquery1.citye.namee" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType0 = rootOperator.getResultType();
		assertEquals(7, resultType0.getResultFields().size());
		String[] expectedResultFieldNamesArray0 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee", "subquery1.citye.namee" };
		DataType[] expectedResultFieldTypesArray0 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING };
		String[] expectedCanonicalModelConstructNamesArray0 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee" };
		String[] exptectedParentCanonicalModelConstructNamesArray0 = { "citye", "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray0 = new String[7];
		DataType[] actualResultFieldTypesArray0 = new DataType[7];
		String[] actualCanonicalModelConstructNamesArray0 = new String[7];
		String[] actualParentCanonicalModelConstructNamesArray0 = new String[7];

		i = 0;
		Map<String, ResultField> resultFields0 = resultType0.getResultFields();
		Set<String> resultFieldNames0 = resultFields0.keySet();
		for (String resultFieldName : resultFieldNames0) {
			actualResultFieldNamesArray0[i] = resultFieldName;
			actualResultFieldTypesArray0[i] = resultFields0.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultFields0.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields0.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultFields0.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray0, actualResultFieldNamesArray0);
		assertArrayEquals(expectedResultFieldTypesArray0, actualResultFieldTypesArray0);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray0, actualCanonicalModelConstructNamesArray0);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray0, actualParentCanonicalModelConstructNamesArray0);

		MappingOperator input0Operator = rootOperator.getLhsInput();

		isInstanceOf(JoinOperator.class, input0Operator);
		assertNull(input0Operator.getVariableName());
		assertNotNull(input0Operator.getLhsInput());
		assertNotNull(input0Operator.getRhsInput());
		assertNotNull(((JoinOperator) input0Operator).getReconcilingExpression());
		assertEquals("citye.namee = subquery1.citye.namee", ((JoinOperator) input0Operator).getReconcilingExpression().getExpression());
		assertNotNull(input0Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input0Operator.getDataSource());

		assertEquals(1, ((JoinOperator) input0Operator).getPredicates().size());
		Predicate predicate = ((JoinOperator) input0Operator).getPredicates().iterator().next();
		assertEquals("namee", predicate.getSuperLexical1().getName());
		assertEquals("citye", predicate.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate.getOperator());
		assertEquals("namee", predicate.getSuperLexical2().getName());
		assertEquals("citye", predicate.getSuperLexical2().getParentSuperAbstract().getName());
		assertNull(predicate.getLiteral1());
		assertNull(predicate.getLiteral2());

		assertNotNull(input0Operator.getResultType());
		ResultType resultType = input0Operator.getResultType();
		assertEquals(7, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee", "subquery1.citye.namee" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT, DataType.STRING };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee", "namee" };
		String[] exptectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray = new String[7];
		DataType[] actualResultFieldTypesArray = new DataType[7];
		String[] actualCanonicalModelConstructNamesArray = new String[7];
		String[] actualParentCanonicalModelConstructNamesArray = new String[7];

		i = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[i] = resultFieldName;
			actualResultFieldTypesArray[i] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input1Operator = input0Operator.getLhsInput();

		isInstanceOf(ScanOperator.class, input1Operator);
		assertEquals("citye", input1Operator.getVariableName());
		assertNull(input1Operator.getLhsInput());
		assertNull(input1Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input1Operator).getSuperAbstract().getName());
		assertNull(((ScanOperator) input1Operator).getReconcilingExpression());
		assertEquals(0, ((ScanOperator) input1Operator).getPredicates().size());
		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		assertNotNull(input1Operator.getResultType());
		ResultType resultType1 = input1Operator.getResultType();
		assertEquals(6, resultType1.getResultFields().size());
		String[] expectedResultFieldNamesArray1 = { "citye.namee", "citye.countrye", "citye.provincee", "citye.populatione", "citye.longitudee",
				"citye.latitudee" };
		DataType[] expectedResultFieldTypesArray1 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray1 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray1 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray1 = new String[6];
		DataType[] actualResultFieldTypesArray1 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray1 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray1 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields1 = resultType1.getResultFields();
		Set<String> resultFieldNames1 = resultFields1.keySet();
		for (String resultFieldName : resultFieldNames1) {
			actualResultFieldNamesArray1[i] = resultFieldName;
			actualResultFieldTypesArray1[i] = resultFields1.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray1[i] = resultFields1.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields1.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray1[i] = ((SuperLexical) resultFields1.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray1, actualResultFieldNamesArray1);
		assertArrayEquals(expectedResultFieldTypesArray1, actualResultFieldTypesArray1);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray1, actualCanonicalModelConstructNamesArray1);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray1, actualParentCanonicalModelConstructNamesArray1);

		MappingOperator input2Operator = input0Operator.getRhsInput();

		isInstanceOf(ReduceOperator.class, input2Operator);
		assertEquals("subquery1", input2Operator.getVariableName());
		assertNotNull(input2Operator.getLhsInput());
		assertNull(input2Operator.getRhsInput());
		assertNotNull(((ReduceOperator) input2Operator).getReconcilingExpression());
		assertEquals("subquery1.citye.namee", ((ReduceOperator) input2Operator).getReconcilingExpression().getExpression());
		assertNotNull(input2Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input2Operator.getDataSource());

		assertNotNull(input2Operator.getResultType());
		ResultType resultType2 = input2Operator.getResultType();
		assertEquals(1, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "subquery1.citye.namee" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING };
		String[] expectedCanonicalModelConstructNamesArray2 = { "namee" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "citye" };

		String[] actualResultFieldNamesArray2 = new String[1];
		DataType[] actualResultFieldTypesArray2 = new DataType[1];
		String[] actualCanonicalModelConstructNamesArray2 = new String[1];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[1];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);

		MappingOperator input21Operator = input2Operator.getLhsInput();

		isInstanceOf(ScanOperator.class, input21Operator);
		assertEquals("subquery1.citye", input21Operator.getVariableName());
		assertNull(input21Operator.getLhsInput());
		assertNull(input21Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input21Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input21Operator).getReconcilingExpression());
		assertEquals("subquery1.citye.countrye = 'GB'", ((ScanOperator) input21Operator).getReconcilingExpression().getExpression());
		assertNotNull(input21Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input21Operator.getDataSource());

		assertEquals(1, ((ScanOperator) input21Operator).getPredicates().size());
		Predicate predicate21 = ((ScanOperator) input21Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate21.getSuperLexical1().getName());
		assertEquals("citye", predicate21.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate21.getOperator());
		assertEquals("'GB'", predicate21.getLiteral2());
		assertNull(predicate21.getLiteral1());
		assertNull(predicate21.getSuperLexical2());

		assertNotNull(input21Operator.getResultType());
		ResultType resultType3 = input21Operator.getResultType();
		assertEquals(6, resultType3.getResultFields().size());
		String[] expectedResultFieldNamesArray3 = { "subquery1.citye.namee", "subquery1.citye.countrye", "subquery1.citye.provincee",
				"subquery1.citye.populatione", "subquery1.citye.longitudee", "subquery1.citye.latitudee" };
		DataType[] expectedResultFieldTypesArray3 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray3 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray3 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray3 = new String[6];
		DataType[] actualResultFieldTypesArray3 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray3 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray3 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields3 = resultType3.getResultFields();
		Set<String> resultFieldNames3 = resultFields3.keySet();
		for (String resultFieldName : resultFieldNames3) {
			actualResultFieldNamesArray3[i] = resultFieldName;
			actualResultFieldTypesArray3[i] = resultFields3.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray3[i] = resultFields3.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields3.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray3[i] = ((SuperLexical) resultFields3.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray3, actualResultFieldNamesArray3);
		assertArrayEquals(expectedResultFieldTypesArray3, actualResultFieldTypesArray3);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray3, actualCanonicalModelConstructNamesArray3);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray3, actualParentCanonicalModelConstructNamesArray3);
	}

	//---------------------------------------------------------------------

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectStarFromWhereUnionQueryOneSource() {
		String selectStarFromWhereUnionQuery = "Select * from citye where citye.countrye = 'GB' union select * from citye where citye.countrye = 'D'";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectStarFromWhereUnionQuery);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectStarFromWhereUnionQueryAst = parser.parseSQL(selectStarFromWhereUnionQuery);
		logger.debug("selectStarFromWhereUnionQueryAst: " + selectStarFromWhereUnionQueryAst.toStringTree());

		query = globalTranslator.translateAstIntoQuery(query, selectStarFromWhereUnionQuery, selectStarFromWhereUnionQueryAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(6, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals(
				"union1.citye.namee, union1.citye.countrye, union1.citye.provincee, union1.citye.populatione, union1.citye.longitudee, union1.citye.latitudee",
				((ReduceOperator) rootOperator).getReconcilingExpression().getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[6];
		String[] superAbstractNamesArray = new String[6];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[6];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "union1.citye.namee", "union1.citye.countrye", "union1.citye.provincee",
				"union1.citye.populatione", "union1.citye.longitudee", "union1.citye.latitudee" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType0 = rootOperator.getResultType();
		assertEquals(6, resultType0.getResultFields().size());
		String[] expectedResultFieldNamesArray0 = { "union1.citye.namee", "union1.citye.countrye", "union1.citye.provincee",
				"union1.citye.populatione", "union1.citye.longitudee", "union1.citye.latitudee" };
		DataType[] expectedResultFieldTypesArray0 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray0 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray0 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray0 = new String[6];
		DataType[] actualResultFieldTypesArray0 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray0 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray0 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields0 = resultType0.getResultFields();
		Set<String> resultFieldNames0 = resultFields0.keySet();
		for (String resultFieldName : resultFieldNames0) {
			actualResultFieldNamesArray0[i] = resultFieldName;
			actualResultFieldTypesArray0[i] = resultFields0.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultFields0.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields0.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultFields0.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray0, actualResultFieldNamesArray0);
		assertArrayEquals(expectedResultFieldTypesArray0, actualResultFieldTypesArray0);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray0, actualCanonicalModelConstructNamesArray0);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray0, actualParentCanonicalModelConstructNamesArray0);

		MappingOperator input0Operator = rootOperator.getLhsInput();

		isInstanceOf(SetOperator.class, input0Operator);
		assertNull(input0Operator.getVariableName());
		assertNotNull(input0Operator.getLhsInput());
		assertNotNull(input0Operator.getRhsInput());
		assertEquals(input0Operator.getInput(), input0Operator.getLhsInput());
		assertNull(((SetOperator) input0Operator).getReconcilingExpression());

		assertNotNull(input0Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input0Operator.getDataSource());

		assertNotNull(input0Operator.getResultType());
		ResultType resultType = input0Operator.getResultType();
		assertEquals(6, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "union1.citye.namee", "union1.citye.countrye", "union1.citye.provincee",
				"union1.citye.populatione", "union1.citye.longitudee", "union1.citye.latitudee" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray = new String[6];
		DataType[] actualResultFieldTypesArray = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray = new String[6];

		i = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[i] = resultFieldName;
			actualResultFieldTypesArray[i] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input1Operator = input0Operator.getLhsInput();

		isInstanceOf(ReduceOperator.class, input1Operator);
		assertNull(input1Operator.getVariableName());
		assertNotNull(input1Operator.getInput());
		assertNotNull(input1Operator.getLhsInput());
		assertEquals(input1Operator.getInput(), input1Operator.getLhsInput());
		assertNull(input1Operator.getRhsInput());
		assertEquals(6, ((ReduceOperator) input1Operator).getSuperLexicals().size());
		assertEquals(
				"union1.citye.namee, union1.citye.countrye, union1.citye.provincee, union1.citye.populatione, union1.citye.longitudee, union1.citye.latitudee",
				((ReduceOperator) input1Operator).getReconcilingExpression().getExpression());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		Collection<SuperLexical> superLexicals10 = ((ReduceOperator) input1Operator).getSuperLexicals().values();
		String[] superLexicalNamesArray10 = new String[6];
		String[] superAbstractNamesArray10 = new String[6];
		i = 0;
		for (SuperLexical superLexical : superLexicals10) {
			superLexicalNamesArray10[i] = superLexical.getName();
			superAbstractNamesArray10[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray10 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		assertArrayEquals(expectedSuperLexicalNamesArray10, superLexicalNamesArray10);
		String[] expectedSuperAbstractNamesArray10 = { "citye", "citye", "citye", "citye", "citye", "citye" };
		assertArrayEquals(expectedSuperAbstractNamesArray10, superAbstractNamesArray10);
		Set<String> superLexicalVariableNames10 = ((ReduceOperator) input1Operator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray10 = new String[6];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames10) {
			superLexicalVariableNamesArray10[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray10 = { "union1.citye.namee", "union1.citye.countrye", "union1.citye.provincee",
				"union1.citye.populatione", "union1.citye.longitudee", "union1.citye.latitudee" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray10, superLexicalVariableNamesArray10);

		assertNotNull(input1Operator.getResultType());
		ResultType resultType10 = input1Operator.getResultType();
		assertEquals(6, resultType10.getResultFields().size());
		String[] expectedResultFieldNamesArray10 = { "union1.citye.namee", "union1.citye.countrye", "union1.citye.provincee",
				"union1.citye.populatione", "union1.citye.longitudee", "union1.citye.latitudee" };
		DataType[] expectedResultFieldTypesArray10 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray10 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray10 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray10 = new String[6];
		DataType[] actualResultFieldTypesArray10 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray10 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray10 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields10 = resultType10.getResultFields();
		Set<String> resultFieldNames10 = resultFields10.keySet();
		for (String resultFieldName : resultFieldNames10) {
			actualResultFieldNamesArray10[i] = resultFieldName;
			actualResultFieldTypesArray10[i] = resultFields10.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray10[i] = resultFields10.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields10.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray10[i] = ((SuperLexical) resultFields10.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray10, actualResultFieldNamesArray10);
		assertArrayEquals(expectedResultFieldTypesArray10, actualResultFieldTypesArray10);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray10, actualCanonicalModelConstructNamesArray10);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray10, actualParentCanonicalModelConstructNamesArray10);

		MappingOperator input11Operator = input1Operator.getLhsInput();

		isInstanceOf(ScanOperator.class, input11Operator);
		assertEquals("union1.citye", input11Operator.getVariableName());
		assertNull(input11Operator.getLhsInput());
		assertNull(input11Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input11Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input11Operator).getReconcilingExpression());
		assertEquals("union1.citye.countrye = 'GB'", ((ScanOperator) input11Operator).getReconcilingExpression().getExpression());

		assertNotNull(input11Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input11Operator.getDataSource());

		assertEquals(1, ((ScanOperator) input11Operator).getPredicates().size());
		Predicate predicate1 = ((ScanOperator) input11Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate1.getSuperLexical1().getName());
		assertEquals("citye", predicate1.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate1.getOperator());
		assertEquals("'GB'", predicate1.getLiteral2());
		assertNull(predicate1.getLiteral1());
		assertNull(predicate1.getSuperLexical2());

		assertNotNull(input11Operator.getResultType());
		ResultType resultType1 = input11Operator.getResultType();
		assertEquals(6, resultType1.getResultFields().size());
		String[] expectedResultFieldNamesArray1 = { "union1.citye.namee", "union1.citye.countrye", "union1.citye.provincee",
				"union1.citye.populatione", "union1.citye.longitudee", "union1.citye.latitudee" };
		DataType[] expectedResultFieldTypesArray1 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray1 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray1 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray1 = new String[6];
		DataType[] actualResultFieldTypesArray1 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray1 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray1 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields1 = resultType1.getResultFields();
		Set<String> resultFieldNames1 = resultFields1.keySet();
		for (String resultFieldName : resultFieldNames1) {
			actualResultFieldNamesArray1[i] = resultFieldName;
			actualResultFieldTypesArray1[i] = resultFields1.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray1[i] = resultFields1.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields1.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray1[i] = ((SuperLexical) resultFields1.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray1, actualResultFieldNamesArray1);
		assertArrayEquals(expectedResultFieldTypesArray1, actualResultFieldTypesArray1);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray1, actualCanonicalModelConstructNamesArray1);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray1, actualParentCanonicalModelConstructNamesArray1);

		MappingOperator input2Operator = input0Operator.getRhsInput();

		isInstanceOf(ReduceOperator.class, input2Operator);
		assertNull(input2Operator.getVariableName());
		assertNotNull(input2Operator.getInput());
		assertNotNull(input2Operator.getLhsInput());
		assertEquals(input2Operator.getInput(), input2Operator.getLhsInput());
		assertNull(input2Operator.getRhsInput());
		assertEquals(6, ((ReduceOperator) input2Operator).getSuperLexicals().size());
		assertEquals(
				"union2.citye.namee, union2.citye.countrye, union2.citye.provincee, union2.citye.populatione, union2.citye.longitudee, union2.citye.latitudee",
				((ReduceOperator) input2Operator).getReconcilingExpression().getExpression());

		assertNotNull(input2Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input2Operator.getDataSource());

		Collection<SuperLexical> superLexicals20 = ((ReduceOperator) input2Operator).getSuperLexicals().values();
		String[] superLexicalNamesArray20 = new String[6];
		String[] superAbstractNamesArray20 = new String[6];
		i = 0;
		for (SuperLexical superLexical : superLexicals20) {
			superLexicalNamesArray20[i] = superLexical.getName();
			superAbstractNamesArray20[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray20 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		assertArrayEquals(expectedSuperLexicalNamesArray20, superLexicalNamesArray20);
		String[] expectedSuperAbstractNamesArray20 = { "citye", "citye", "citye", "citye", "citye", "citye" };
		assertArrayEquals(expectedSuperAbstractNamesArray20, superAbstractNamesArray20);
		Set<String> superLexicalVariableNames20 = ((ReduceOperator) input2Operator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray20 = new String[6];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames20) {
			superLexicalVariableNamesArray20[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray20 = { "union2.citye.namee", "union2.citye.countrye", "union2.citye.provincee",
				"union2.citye.populatione", "union2.citye.longitudee", "union2.citye.latitudee" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray20, superLexicalVariableNamesArray20);

		assertNotNull(input2Operator.getResultType());
		ResultType resultType20 = input2Operator.getResultType();
		assertEquals(6, resultType20.getResultFields().size());
		String[] expectedResultFieldNamesArray20 = { "union2.citye.namee", "union2.citye.countrye", "union2.citye.provincee",
				"union2.citye.populatione", "union2.citye.longitudee", "union2.citye.latitudee" };
		DataType[] expectedResultFieldTypesArray20 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray20 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray20 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray20 = new String[6];
		DataType[] actualResultFieldTypesArray20 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray20 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray20 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields20 = resultType20.getResultFields();
		Set<String> resultFieldNames20 = resultFields20.keySet();
		for (String resultFieldName : resultFieldNames20) {
			actualResultFieldNamesArray20[i] = resultFieldName;
			actualResultFieldTypesArray20[i] = resultFields20.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray20[i] = resultFields20.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields20.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray20[i] = ((SuperLexical) resultFields20.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray20, actualResultFieldNamesArray20);
		assertArrayEquals(expectedResultFieldTypesArray20, actualResultFieldTypesArray20);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray20, actualCanonicalModelConstructNamesArray20);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray20, actualParentCanonicalModelConstructNamesArray20);

		MappingOperator input12Operator = input2Operator.getLhsInput();

		isInstanceOf(ScanOperator.class, input12Operator);
		assertEquals("union2.citye", input12Operator.getVariableName());
		assertNull(input12Operator.getLhsInput());
		assertNull(input12Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input12Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input12Operator).getReconcilingExpression());
		assertEquals("union2.citye.countrye = 'D'", ((ScanOperator) input12Operator).getReconcilingExpression().getExpression());

		assertNotNull(input12Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input12Operator.getDataSource());

		assertEquals(1, ((ScanOperator) input12Operator).getPredicates().size());
		Predicate predicate2 = ((ScanOperator) input12Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate2.getSuperLexical1().getName());
		assertEquals("citye", predicate2.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate2.getOperator());
		assertEquals("'D'", predicate2.getLiteral2());
		assertNull(predicate2.getLiteral1());
		assertNull(predicate2.getSuperLexical2());

		assertNotNull(input12Operator.getResultType());
		ResultType resultType2 = input12Operator.getResultType();
		assertEquals(6, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "union2.citye.namee", "union2.citye.countrye", "union2.citye.provincee",
				"union2.citye.populatione", "union2.citye.longitudee", "union2.citye.latitudee" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray2 = new String[6];
		DataType[] actualResultFieldTypesArray2 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray2 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectStarFromWhereUnionUnionQueryOneSource() {
		String selectStarFromWhereUnionUnionQuery = "Select * from citye where citye.countrye = 'GB' union select * from citye where citye.countrye = 'D' union select * from citye where citye.countrye = 'IRL'";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);

		Query query = new Query(queryName, selectStarFromWhereUnionUnionQuery);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);

		CommonTree selectStarFromWhereUnionUnionQueryAst = parser.parseSQL(selectStarFromWhereUnionUnionQuery);
		logger.debug("selectStarFromWhereUnionQueryAst: " + selectStarFromWhereUnionUnionQueryAst.toStringTree());

		query = globalTranslator.translateAstIntoQuery(query, selectStarFromWhereUnionUnionQuery, selectStarFromWhereUnionUnionQueryAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(6, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals(
				"union1.union1.citye.namee, union1.union1.citye.countrye, union1.union1.citye.provincee, union1.union1.citye.populatione, union1.union1.citye.longitudee, union1.union1.citye.latitudee",
				((ReduceOperator) rootOperator).getReconcilingExpression().getExpression());

		assertNotNull(rootOperator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[6];
		String[] superAbstractNamesArray = new String[6];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[6];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "union1.union1.citye.namee", "union1.union1.citye.countrye",
				"union1.union1.citye.provincee", "union1.union1.citye.populatione", "union1.union1.citye.longitudee", "union1.union1.citye.latitudee" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType0 = rootOperator.getResultType();
		assertEquals(6, resultType0.getResultFields().size());
		String[] expectedResultFieldNamesArray0 = { "union1.union1.citye.namee", "union1.union1.citye.countrye", "union1.union1.citye.provincee",
				"union1.union1.citye.populatione", "union1.union1.citye.longitudee", "union1.union1.citye.latitudee" };
		DataType[] expectedResultFieldTypesArray0 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray0 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray0 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray0 = new String[6];
		DataType[] actualResultFieldTypesArray0 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray0 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray0 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields0 = resultType0.getResultFields();
		Set<String> resultFieldNames0 = resultFields0.keySet();
		for (String resultFieldName : resultFieldNames0) {
			actualResultFieldNamesArray0[i] = resultFieldName;
			actualResultFieldTypesArray0[i] = resultFields0.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultFields0.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields0.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultFields0.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray0, actualResultFieldNamesArray0);
		assertArrayEquals(expectedResultFieldTypesArray0, actualResultFieldTypesArray0);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray0, actualCanonicalModelConstructNamesArray0);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray0, actualParentCanonicalModelConstructNamesArray0);

		MappingOperator input0Operator = rootOperator.getLhsInput();

		isInstanceOf(SetOperator.class, input0Operator);
		assertNull(input0Operator.getVariableName());
		assertNotNull(input0Operator.getLhsInput());
		assertNotNull(input0Operator.getRhsInput());
		assertEquals(input0Operator.getInput(), input0Operator.getLhsInput());
		assertNull(((SetOperator) input0Operator).getReconcilingExpression());

		assertNotNull(input0Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input0Operator.getDataSource());

		assertNotNull(input0Operator.getResultType());
		ResultType resultType = input0Operator.getResultType();
		assertEquals(6, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "union1.union1.citye.namee", "union1.union1.citye.countrye", "union1.union1.citye.provincee",
				"union1.union1.citye.populatione", "union1.union1.citye.longitudee", "union1.union1.citye.latitudee" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray = new String[6];
		DataType[] actualResultFieldTypesArray = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray = new String[6];

		i = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[i] = resultFieldName;
			actualResultFieldTypesArray[i] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input1Operator = input0Operator.getLhsInput();

		isInstanceOf(ReduceOperator.class, input1Operator);
		assertNull(input1Operator.getVariableName());
		assertNotNull(input1Operator.getInput());
		assertNotNull(input1Operator.getLhsInput());
		assertEquals(input1Operator.getInput(), input1Operator.getLhsInput());
		assertNull(input1Operator.getRhsInput());
		assertEquals(6, ((ReduceOperator) input1Operator).getSuperLexicals().size());
		assertEquals(
				"union1.union1.citye.namee, union1.union1.citye.countrye, union1.union1.citye.provincee, union1.union1.citye.populatione, union1.union1.citye.longitudee, union1.union1.citye.latitudee",
				((ReduceOperator) input1Operator).getReconcilingExpression().getExpression());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		Collection<SuperLexical> superLexicals10 = ((ReduceOperator) input1Operator).getSuperLexicals().values();
		String[] superLexicalNamesArray10 = new String[6];
		String[] superAbstractNamesArray10 = new String[6];
		i = 0;
		for (SuperLexical superLexical : superLexicals10) {
			superLexicalNamesArray10[i] = superLexical.getName();
			superAbstractNamesArray10[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray10 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		assertArrayEquals(expectedSuperLexicalNamesArray10, superLexicalNamesArray10);
		String[] expectedSuperAbstractNamesArray10 = { "citye", "citye", "citye", "citye", "citye", "citye" };
		assertArrayEquals(expectedSuperAbstractNamesArray10, superAbstractNamesArray10);
		Set<String> superLexicalVariableNames10 = ((ReduceOperator) input1Operator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray10 = new String[6];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames10) {
			superLexicalVariableNamesArray10[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray10 = { "union1.union1.citye.namee", "union1.union1.citye.countrye",
				"union1.union1.citye.provincee", "union1.union1.citye.populatione", "union1.union1.citye.longitudee", "union1.union1.citye.latitudee" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray10, superLexicalVariableNamesArray10);

		assertNotNull(input1Operator.getResultType());
		ResultType resultType10 = input1Operator.getResultType();
		assertEquals(6, resultType10.getResultFields().size());
		String[] expectedResultFieldNamesArray10 = { "union1.union1.citye.namee", "union1.union1.citye.countrye", "union1.union1.citye.provincee",
				"union1.union1.citye.populatione", "union1.union1.citye.longitudee", "union1.union1.citye.latitudee" };
		DataType[] expectedResultFieldTypesArray10 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray10 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray10 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray10 = new String[6];
		DataType[] actualResultFieldTypesArray10 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray10 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray10 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields10 = resultType10.getResultFields();
		Set<String> resultFieldNames10 = resultFields10.keySet();
		for (String resultFieldName : resultFieldNames10) {
			actualResultFieldNamesArray10[i] = resultFieldName;
			actualResultFieldTypesArray10[i] = resultFields10.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray10[i] = resultFields10.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields10.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray10[i] = ((SuperLexical) resultFields10.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray10, actualResultFieldNamesArray10);
		assertArrayEquals(expectedResultFieldTypesArray10, actualResultFieldTypesArray10);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray10, actualCanonicalModelConstructNamesArray10);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray10, actualParentCanonicalModelConstructNamesArray10);

		MappingOperator input11Operator = input1Operator.getLhsInput();

		isInstanceOf(SetOperator.class, input11Operator);
		assertNull(input11Operator.getVariableName());
		assertNotNull(input11Operator.getLhsInput());
		assertNotNull(input11Operator.getRhsInput());
		assertEquals(input11Operator.getInput(), input11Operator.getLhsInput());
		assertNull(((SetOperator) input11Operator).getReconcilingExpression());

		assertNotNull(input11Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input11Operator.getDataSource());

		assertNotNull(input11Operator.getResultType());
		ResultType resultType110 = input11Operator.getResultType();
		assertEquals(6, resultType110.getResultFields().size());
		String[] expectedResultFieldNamesArray110 = { "union1.union1.citye.namee", "union1.union1.citye.countrye", "union1.union1.citye.provincee",
				"union1.union1.citye.populatione", "union1.union1.citye.longitudee", "union1.union1.citye.latitudee" };
		DataType[] expectedResultFieldTypesArray110 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray110 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray110 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray110 = new String[6];
		DataType[] actualResultFieldTypesArray110 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray110 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray110 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields110 = resultType110.getResultFields();
		Set<String> resultFieldNames110 = resultFields110.keySet();
		for (String resultFieldName : resultFieldNames110) {
			actualResultFieldNamesArray110[i] = resultFieldName;
			actualResultFieldTypesArray110[i] = resultFields110.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray110[i] = resultFields110.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields110.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray110[i] = ((SuperLexical) resultFields110.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray110, actualResultFieldNamesArray110);
		assertArrayEquals(expectedResultFieldTypesArray110, actualResultFieldTypesArray110);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray110, actualCanonicalModelConstructNamesArray110);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray110, actualParentCanonicalModelConstructNamesArray110);

		MappingOperator input2Operator = input0Operator.getRhsInput();

		isInstanceOf(ReduceOperator.class, input2Operator);
		assertNull(input2Operator.getVariableName());
		assertNotNull(input2Operator.getInput());
		assertNotNull(input2Operator.getLhsInput());
		assertEquals(input2Operator.getInput(), input2Operator.getLhsInput());
		assertNull(input2Operator.getRhsInput());
		assertEquals(6, ((ReduceOperator) input2Operator).getSuperLexicals().size());
		assertEquals(
				"union2.citye.namee, union2.citye.countrye, union2.citye.provincee, union2.citye.populatione, union2.citye.longitudee, union2.citye.latitudee",
				((ReduceOperator) input2Operator).getReconcilingExpression().getExpression());

		assertNotNull(input2Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input2Operator.getDataSource());

		Collection<SuperLexical> superLexicals20 = ((ReduceOperator) input2Operator).getSuperLexicals().values();
		String[] superLexicalNamesArray20 = new String[6];
		String[] superAbstractNamesArray20 = new String[6];
		i = 0;
		for (SuperLexical superLexical : superLexicals20) {
			superLexicalNamesArray20[i] = superLexical.getName();
			superAbstractNamesArray20[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray20 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		assertArrayEquals(expectedSuperLexicalNamesArray20, superLexicalNamesArray20);
		String[] expectedSuperAbstractNamesArray20 = { "citye", "citye", "citye", "citye", "citye", "citye" };
		assertArrayEquals(expectedSuperAbstractNamesArray20, superAbstractNamesArray20);
		Set<String> superLexicalVariableNames20 = ((ReduceOperator) input2Operator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray20 = new String[6];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames20) {
			superLexicalVariableNamesArray20[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray20 = { "union2.citye.namee", "union2.citye.countrye", "union2.citye.provincee",
				"union2.citye.populatione", "union2.citye.longitudee", "union2.citye.latitudee" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray20, superLexicalVariableNamesArray20);

		assertNotNull(input2Operator.getResultType());
		ResultType resultType20 = input2Operator.getResultType();
		assertEquals(6, resultType20.getResultFields().size());
		String[] expectedResultFieldNamesArray20 = { "union2.citye.namee", "union2.citye.countrye", "union2.citye.provincee",
				"union2.citye.populatione", "union2.citye.longitudee", "union2.citye.latitudee" };
		DataType[] expectedResultFieldTypesArray20 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray20 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray20 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray20 = new String[6];
		DataType[] actualResultFieldTypesArray20 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray20 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray20 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields20 = resultType20.getResultFields();
		Set<String> resultFieldNames20 = resultFields20.keySet();
		for (String resultFieldName : resultFieldNames20) {
			actualResultFieldNamesArray20[i] = resultFieldName;
			actualResultFieldTypesArray20[i] = resultFields20.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray20[i] = resultFields20.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields20.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray20[i] = ((SuperLexical) resultFields20.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray20, actualResultFieldNamesArray20);
		assertArrayEquals(expectedResultFieldTypesArray20, actualResultFieldTypesArray20);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray20, actualCanonicalModelConstructNamesArray20);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray20, actualParentCanonicalModelConstructNamesArray20);

		MappingOperator input12Operator = input2Operator.getLhsInput();

		isInstanceOf(ScanOperator.class, input12Operator);
		assertEquals("union2.citye", input12Operator.getVariableName());
		assertNull(input12Operator.getLhsInput());
		assertNull(input12Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input12Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input12Operator).getReconcilingExpression());
		assertEquals("union2.citye.countrye = 'IRL'", ((ScanOperator) input12Operator).getReconcilingExpression().getExpression());

		assertNotNull(input12Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input12Operator.getDataSource());

		assertEquals(1, ((ScanOperator) input12Operator).getPredicates().size());
		Predicate predicate2 = ((ScanOperator) input12Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate2.getSuperLexical1().getName());
		assertEquals("citye", predicate2.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate2.getOperator());
		assertEquals("'IRL'", predicate2.getLiteral2());
		assertNull(predicate2.getLiteral1());
		assertNull(predicate2.getSuperLexical2());

		assertNotNull(input12Operator.getResultType());
		ResultType resultType1 = input12Operator.getResultType();
		assertEquals(6, resultType1.getResultFields().size());
		String[] expectedResultFieldNamesArray1 = { "union2.citye.namee", "union2.citye.countrye", "union2.citye.provincee",
				"union2.citye.populatione", "union2.citye.longitudee", "union2.citye.latitudee" };
		DataType[] expectedResultFieldTypesArray1 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray1 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray1 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray1 = new String[6];
		DataType[] actualResultFieldTypesArray1 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray1 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray1 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields1 = resultType1.getResultFields();
		Set<String> resultFieldNames1 = resultFields1.keySet();
		for (String resultFieldName : resultFieldNames1) {
			actualResultFieldNamesArray1[i] = resultFieldName;
			actualResultFieldTypesArray1[i] = resultFields1.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray1[i] = resultFields1.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields1.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray1[i] = ((SuperLexical) resultFields1.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray1, actualResultFieldNamesArray1);
		assertArrayEquals(expectedResultFieldTypesArray1, actualResultFieldTypesArray1);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray1, actualCanonicalModelConstructNamesArray1);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray1, actualParentCanonicalModelConstructNamesArray1);

		MappingOperator input121Operator = input11Operator.getLhsInput();

		isInstanceOf(ReduceOperator.class, input121Operator);
		assertNull(input121Operator.getVariableName());
		assertNotNull(input121Operator.getInput());
		assertNotNull(input121Operator.getLhsInput());
		assertEquals(input121Operator.getInput(), input121Operator.getLhsInput());
		assertNull(input121Operator.getRhsInput());
		assertEquals(6, ((ReduceOperator) input121Operator).getSuperLexicals().size());
		assertEquals(
				"union1.union1.citye.namee, union1.union1.citye.countrye, union1.union1.citye.provincee, union1.union1.citye.populatione, union1.union1.citye.longitudee, union1.union1.citye.latitudee",
				((ReduceOperator) input121Operator).getReconcilingExpression().getExpression());

		assertNotNull(input121Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input121Operator.getDataSource());

		Collection<SuperLexical> superLexicals1210 = ((ReduceOperator) input121Operator).getSuperLexicals().values();
		String[] superLexicalNamesArray1210 = new String[6];
		String[] superAbstractNamesArray1210 = new String[6];
		i = 0;
		for (SuperLexical superLexical : superLexicals1210) {
			superLexicalNamesArray1210[i] = superLexical.getName();
			superAbstractNamesArray1210[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray1210 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		assertArrayEquals(expectedSuperLexicalNamesArray1210, superLexicalNamesArray1210);
		String[] expectedSuperAbstractNamesArray1210 = { "citye", "citye", "citye", "citye", "citye", "citye" };
		assertArrayEquals(expectedSuperAbstractNamesArray1210, superAbstractNamesArray1210);
		Set<String> superLexicalVariableNames1210 = ((ReduceOperator) input121Operator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray1210 = new String[6];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames1210) {
			superLexicalVariableNamesArray1210[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray1210 = { "union1.union1.citye.namee", "union1.union1.citye.countrye",
				"union1.union1.citye.provincee", "union1.union1.citye.populatione", "union1.union1.citye.longitudee", "union1.union1.citye.latitudee" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray1210, superLexicalVariableNamesArray1210);

		assertNotNull(input121Operator.getResultType());
		ResultType resultType1210 = input121Operator.getResultType();
		assertEquals(6, resultType1210.getResultFields().size());
		String[] expectedResultFieldNamesArray1210 = { "union1.union1.citye.namee", "union1.union1.citye.countrye", "union1.union1.citye.provincee",
				"union1.union1.citye.populatione", "union1.union1.citye.longitudee", "union1.union1.citye.latitudee" };
		DataType[] expectedResultFieldTypesArray1210 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray1210 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray1210 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray1210 = new String[6];
		DataType[] actualResultFieldTypesArray1210 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray1210 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray1210 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields1210 = resultType1210.getResultFields();
		Set<String> resultFieldNames1210 = resultFields1210.keySet();
		for (String resultFieldName : resultFieldNames1210) {
			actualResultFieldNamesArray1210[i] = resultFieldName;
			actualResultFieldTypesArray1210[i] = resultFields1210.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray1210[i] = resultFields1210.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields1210.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray1210[i] = ((SuperLexical) resultFields1210.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray1210, actualResultFieldNamesArray1210);
		assertArrayEquals(expectedResultFieldTypesArray1210, actualResultFieldTypesArray1210);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray1210, actualCanonicalModelConstructNamesArray1210);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray1210, actualParentCanonicalModelConstructNamesArray1210);

		MappingOperator input1211Operator = input121Operator.getLhsInput();

		isInstanceOf(ScanOperator.class, input1211Operator);
		assertEquals("union1.union1.citye", input1211Operator.getVariableName());
		assertNull(input1211Operator.getLhsInput());
		assertNull(input1211Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input1211Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input1211Operator).getReconcilingExpression());
		assertEquals("union1.union1.citye.countrye = 'GB'", ((ScanOperator) input1211Operator).getReconcilingExpression().getExpression());

		assertNotNull(input1211Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1211Operator.getDataSource());

		assertEquals(1, ((ScanOperator) input1211Operator).getPredicates().size());
		Predicate predicate11 = ((ScanOperator) input1211Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate11.getSuperLexical1().getName());
		assertEquals("citye", predicate11.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate11.getOperator());
		assertEquals("'GB'", predicate11.getLiteral2());
		assertNull(predicate11.getLiteral1());
		assertNull(predicate11.getSuperLexical2());

		assertNotNull(input1211Operator.getResultType());
		ResultType resultType2 = input1211Operator.getResultType();
		assertEquals(6, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "union1.union1.citye.namee", "union1.union1.citye.countrye", "union1.union1.citye.provincee",
				"union1.union1.citye.populatione", "union1.union1.citye.longitudee", "union1.union1.citye.latitudee" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray2 = new String[6];
		DataType[] actualResultFieldTypesArray2 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray2 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);

		MappingOperator input112Operator = input11Operator.getRhsInput();

		isInstanceOf(ReduceOperator.class, input112Operator);
		assertNull(input112Operator.getVariableName());
		assertNotNull(input112Operator.getInput());
		assertNotNull(input112Operator.getLhsInput());
		assertEquals(input112Operator.getInput(), input112Operator.getLhsInput());
		assertNull(input112Operator.getRhsInput());
		assertEquals(6, ((ReduceOperator) input112Operator).getSuperLexicals().size());
		assertEquals(
				"union2.union1.citye.namee, union2.union1.citye.countrye, union2.union1.citye.provincee, union2.union1.citye.populatione, union2.union1.citye.longitudee, union2.union1.citye.latitudee",
				((ReduceOperator) input112Operator).getReconcilingExpression().getExpression());

		assertNotNull(input112Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input112Operator.getDataSource());

		Collection<SuperLexical> superLexicals1120 = ((ReduceOperator) input112Operator).getSuperLexicals().values();
		String[] superLexicalNamesArray1120 = new String[6];
		String[] superAbstractNamesArray1120 = new String[6];
		i = 0;
		for (SuperLexical superLexical : superLexicals1120) {
			superLexicalNamesArray1120[i] = superLexical.getName();
			superAbstractNamesArray1120[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray1120 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		assertArrayEquals(expectedSuperLexicalNamesArray1120, superLexicalNamesArray1120);
		String[] expectedSuperAbstractNamesArray1120 = { "citye", "citye", "citye", "citye", "citye", "citye" };
		assertArrayEquals(expectedSuperAbstractNamesArray1120, superAbstractNamesArray1120);
		Set<String> superLexicalVariableNames1120 = ((ReduceOperator) input112Operator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray1120 = new String[6];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames1120) {
			superLexicalVariableNamesArray1120[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray1120 = { "union2.union1.citye.namee", "union2.union1.citye.countrye",
				"union2.union1.citye.provincee", "union2.union1.citye.populatione", "union2.union1.citye.longitudee", "union2.union1.citye.latitudee" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray1120, superLexicalVariableNamesArray1120);

		assertNotNull(input112Operator.getResultType());
		ResultType resultType1120 = input112Operator.getResultType();
		assertEquals(6, resultType1120.getResultFields().size());
		String[] expectedResultFieldNamesArray1120 = { "union2.union1.citye.namee", "union2.union1.citye.countrye", "union2.union1.citye.provincee",
				"union2.union1.citye.populatione", "union2.union1.citye.longitudee", "union2.union1.citye.latitudee" };
		DataType[] expectedResultFieldTypesArray1120 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray1120 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray1120 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray1120 = new String[6];
		DataType[] actualResultFieldTypesArray1120 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray1120 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray1120 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields1120 = resultType1120.getResultFields();
		Set<String> resultFieldNames1120 = resultFields1120.keySet();
		for (String resultFieldName : resultFieldNames1120) {
			actualResultFieldNamesArray1120[i] = resultFieldName;
			actualResultFieldTypesArray1120[i] = resultFields1120.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray1120[i] = resultFields1120.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields1120.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray1120[i] = ((SuperLexical) resultFields1120.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray1120, actualResultFieldNamesArray1120);
		assertArrayEquals(expectedResultFieldTypesArray1120, actualResultFieldTypesArray1120);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray1120, actualCanonicalModelConstructNamesArray1120);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray1120, actualParentCanonicalModelConstructNamesArray1120);

		MappingOperator input1121Operator = input112Operator.getLhsInput();

		isInstanceOf(ScanOperator.class, input1121Operator);
		assertEquals("union2.union1.citye", input1121Operator.getVariableName());
		assertNull(input1121Operator.getLhsInput());
		assertNull(input1121Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input1121Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input1121Operator).getReconcilingExpression());
		assertEquals("union2.union1.citye.countrye = 'D'", ((ScanOperator) input1121Operator).getReconcilingExpression().getExpression());

		assertNotNull(input1121Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1121Operator.getDataSource());

		assertEquals(1, ((ScanOperator) input1121Operator).getPredicates().size());
		Predicate predicate12 = ((ScanOperator) input1121Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate12.getSuperLexical1().getName());
		assertEquals("citye", predicate12.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate12.getOperator());
		assertEquals("'D'", predicate12.getLiteral2());
		assertNull(predicate12.getLiteral1());
		assertNull(predicate12.getSuperLexical2());

		assertNotNull(input1121Operator.getResultType());
		ResultType resultType3 = input1121Operator.getResultType();
		assertEquals(6, resultType3.getResultFields().size());
		String[] expectedResultFieldNamesArray3 = { "union2.union1.citye.namee", "union2.union1.citye.countrye", "union2.union1.citye.provincee",
				"union2.union1.citye.populatione", "union2.union1.citye.longitudee", "union2.union1.citye.latitudee" };
		DataType[] expectedResultFieldTypesArray3 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray3 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray3 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray3 = new String[6];
		DataType[] actualResultFieldTypesArray3 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray3 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray3 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields3 = resultType3.getResultFields();
		Set<String> resultFieldNames3 = resultFields3.keySet();
		for (String resultFieldName : resultFieldNames3) {
			actualResultFieldNamesArray3[i] = resultFieldName;
			actualResultFieldTypesArray3[i] = resultFields3.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray3[i] = resultFields3.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields3.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray3[i] = ((SuperLexical) resultFields3.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray3, actualResultFieldNamesArray3);
		assertArrayEquals(expectedResultFieldTypesArray3, actualResultFieldTypesArray3);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray3, actualCanonicalModelConstructNamesArray3);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray3, actualParentCanonicalModelConstructNamesArray3);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectStarFromWhereUnionQueryTwoSources() {
		String selectStarFromWhereUnionQuery = "Select * from citye where citye.countrye = 'GB' union select * from citya where citya.countrya = 'MA'";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");
		Schema mondialCityProvinceCountryContinentAfricaWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentAfricaWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);
		DataSource mondialCityProvinceCountryContinentAfricaWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentAfricaWR");
		logger.debug("mondialCityProvinceCountryContinentAfricaWithRenameDS: " + mondialCityProvinceCountryContinentAfricaWithRenameDS);

		Query query = new Query(queryName, selectStarFromWhereUnionQuery);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		query.addSchema(mondialCityProvinceCountryContinentAfricaWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);
		//query.addDataSource(mondialCityProvinceCountryContinentAfricaWithRenameDS);

		CommonTree selectStarFromWhereUnionQueryAst = parser.parseSQL(selectStarFromWhereUnionQuery);
		logger.debug("selectStarFromWhereUnionQueryAst: " + selectStarFromWhereUnionQueryAst.toStringTree());

		query = globalTranslator.translateAstIntoQuery(query, selectStarFromWhereUnionQuery, selectStarFromWhereUnionQueryAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(6, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals(
				"union1.citye.namee, union1.citye.countrye, union1.citye.provincee, union1.citye.populatione, union1.citye.longitudee, union1.citye.latitudee",
				((ReduceOperator) rootOperator).getReconcilingExpression().getExpression());

		assertNull(rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[6];
		String[] superAbstractNamesArray = new String[6];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[6];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "union1.citye.namee", "union1.citye.countrye", "union1.citye.provincee",
				"union1.citye.populatione", "union1.citye.longitudee", "union1.citye.latitudee" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType0 = rootOperator.getResultType();
		assertEquals(6, resultType0.getResultFields().size());
		String[] expectedResultFieldNamesArray0 = { "union1.citye.namee", "union1.citye.countrye", "union1.citye.provincee",
				"union1.citye.populatione", "union1.citye.longitudee", "union1.citye.latitudee" };
		DataType[] expectedResultFieldTypesArray0 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray0 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray0 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray0 = new String[6];
		DataType[] actualResultFieldTypesArray0 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray0 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray0 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields0 = resultType0.getResultFields();
		Set<String> resultFieldNames0 = resultFields0.keySet();
		for (String resultFieldName : resultFieldNames0) {
			actualResultFieldNamesArray0[i] = resultFieldName;
			actualResultFieldTypesArray0[i] = resultFields0.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultFields0.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields0.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultFields0.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray0, actualResultFieldNamesArray0);
		assertArrayEquals(expectedResultFieldTypesArray0, actualResultFieldTypesArray0);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray0, actualCanonicalModelConstructNamesArray0);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray0, actualParentCanonicalModelConstructNamesArray0);

		MappingOperator input0Operator = rootOperator.getLhsInput();

		isInstanceOf(SetOperator.class, input0Operator);
		assertNull(input0Operator.getVariableName());
		assertNotNull(input0Operator.getLhsInput());
		assertNotNull(input0Operator.getRhsInput());
		assertEquals(input0Operator.getInput(), input0Operator.getLhsInput());
		assertNull(((SetOperator) input0Operator).getReconcilingExpression());

		assertNull(input0Operator.getDataSource());

		assertNotNull(input0Operator.getResultType());
		ResultType resultType = input0Operator.getResultType();
		assertEquals(6, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "union1.citye.namee", "union1.citye.countrye", "union1.citye.provincee",
				"union1.citye.populatione", "union1.citye.longitudee", "union1.citye.latitudee" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray = new String[6];
		DataType[] actualResultFieldTypesArray = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray = new String[6];

		i = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[i] = resultFieldName;
			actualResultFieldTypesArray[i] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input1Operator = input0Operator.getLhsInput();

		isInstanceOf(ReduceOperator.class, input1Operator);
		assertNull(input1Operator.getVariableName());
		assertNotNull(input1Operator.getInput());
		assertNotNull(input1Operator.getLhsInput());
		assertEquals(input1Operator.getInput(), input1Operator.getLhsInput());
		assertNull(input1Operator.getRhsInput());
		assertEquals(6, ((ReduceOperator) input1Operator).getSuperLexicals().size());
		assertEquals(
				"union1.citye.namee, union1.citye.countrye, union1.citye.provincee, union1.citye.populatione, union1.citye.longitudee, union1.citye.latitudee",
				((ReduceOperator) input1Operator).getReconcilingExpression().getExpression());

		assertNotNull(input1Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1Operator.getDataSource());

		Collection<SuperLexical> superLexicals10 = ((ReduceOperator) input1Operator).getSuperLexicals().values();
		String[] superLexicalNamesArray10 = new String[6];
		String[] superAbstractNamesArray10 = new String[6];
		i = 0;
		for (SuperLexical superLexical : superLexicals10) {
			superLexicalNamesArray10[i] = superLexical.getName();
			superAbstractNamesArray10[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray10 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		assertArrayEquals(expectedSuperLexicalNamesArray10, superLexicalNamesArray10);
		String[] expectedSuperAbstractNamesArray10 = { "citye", "citye", "citye", "citye", "citye", "citye" };
		assertArrayEquals(expectedSuperAbstractNamesArray10, superAbstractNamesArray10);
		Set<String> superLexicalVariableNames10 = ((ReduceOperator) input1Operator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray10 = new String[6];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames10) {
			superLexicalVariableNamesArray10[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray10 = { "union1.citye.namee", "union1.citye.countrye", "union1.citye.provincee",
				"union1.citye.populatione", "union1.citye.longitudee", "union1.citye.latitudee" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray10, superLexicalVariableNamesArray10);

		assertNotNull(input1Operator.getResultType());
		ResultType resultType10 = input1Operator.getResultType();
		assertEquals(6, resultType10.getResultFields().size());
		String[] expectedResultFieldNamesArray10 = { "union1.citye.namee", "union1.citye.countrye", "union1.citye.provincee",
				"union1.citye.populatione", "union1.citye.longitudee", "union1.citye.latitudee" };
		DataType[] expectedResultFieldTypesArray10 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray10 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray10 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray10 = new String[6];
		DataType[] actualResultFieldTypesArray10 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray10 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray10 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields10 = resultType10.getResultFields();
		Set<String> resultFieldNames10 = resultFields10.keySet();
		for (String resultFieldName : resultFieldNames10) {
			actualResultFieldNamesArray10[i] = resultFieldName;
			actualResultFieldTypesArray10[i] = resultFields10.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray10[i] = resultFields10.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields10.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray10[i] = ((SuperLexical) resultFields10.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray10, actualResultFieldNamesArray10);
		assertArrayEquals(expectedResultFieldTypesArray10, actualResultFieldTypesArray10);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray10, actualCanonicalModelConstructNamesArray10);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray10, actualParentCanonicalModelConstructNamesArray10);

		MappingOperator input11Operator = input1Operator.getLhsInput();

		isInstanceOf(ScanOperator.class, input11Operator);
		assertEquals("union1.citye", input11Operator.getVariableName());
		assertNull(input11Operator.getLhsInput());
		assertNull(input11Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input11Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input11Operator).getReconcilingExpression());
		assertEquals("union1.citye.countrye = 'GB'", ((ScanOperator) input11Operator).getReconcilingExpression().getExpression());

		assertNotNull(input11Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input11Operator.getDataSource());

		assertEquals(1, ((ScanOperator) input11Operator).getPredicates().size());
		Predicate predicate1 = ((ScanOperator) input11Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate1.getSuperLexical1().getName());
		assertEquals("citye", predicate1.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate1.getOperator());
		assertEquals("'GB'", predicate1.getLiteral2());
		assertNull(predicate1.getLiteral1());
		assertNull(predicate1.getSuperLexical2());

		assertNotNull(input11Operator.getResultType());
		ResultType resultType1 = input11Operator.getResultType();
		assertEquals(6, resultType1.getResultFields().size());
		String[] expectedResultFieldNamesArray1 = { "union1.citye.namee", "union1.citye.countrye", "union1.citye.provincee",
				"union1.citye.populatione", "union1.citye.longitudee", "union1.citye.latitudee" };
		DataType[] expectedResultFieldTypesArray1 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray1 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray1 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray1 = new String[6];
		DataType[] actualResultFieldTypesArray1 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray1 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray1 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields1 = resultType1.getResultFields();
		Set<String> resultFieldNames1 = resultFields1.keySet();
		for (String resultFieldName : resultFieldNames1) {
			actualResultFieldNamesArray1[i] = resultFieldName;
			actualResultFieldTypesArray1[i] = resultFields1.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray1[i] = resultFields1.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields1.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray1[i] = ((SuperLexical) resultFields1.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray1, actualResultFieldNamesArray1);
		assertArrayEquals(expectedResultFieldTypesArray1, actualResultFieldTypesArray1);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray1, actualCanonicalModelConstructNamesArray1);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray1, actualParentCanonicalModelConstructNamesArray1);

		MappingOperator input2Operator = input0Operator.getRhsInput();

		isInstanceOf(ReduceOperator.class, input2Operator);
		assertNull(input2Operator.getVariableName());
		assertNotNull(input2Operator.getInput());
		assertNotNull(input2Operator.getLhsInput());
		assertEquals(input2Operator.getInput(), input2Operator.getLhsInput());
		assertNull(input2Operator.getRhsInput());
		assertEquals(6, ((ReduceOperator) input2Operator).getSuperLexicals().size());
		assertEquals(
				"union2.citya.namea, union2.citya.countrya, union2.citya.provincea, union2.citya.populationa, union2.citya.longitudea, union2.citya.latitudea",
				((ReduceOperator) input2Operator).getReconcilingExpression().getExpression());

		assertNotNull(input2Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentAfricaWithRenameDS, input2Operator.getDataSource());

		Collection<SuperLexical> superLexicals20 = ((ReduceOperator) input2Operator).getSuperLexicals().values();
		String[] superLexicalNamesArray20 = new String[6];
		String[] superAbstractNamesArray20 = new String[6];
		i = 0;
		for (SuperLexical superLexical : superLexicals20) {
			superLexicalNamesArray20[i] = superLexical.getName();
			superAbstractNamesArray20[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray20 = { "namea", "countrya", "provincea", "populationa", "longitudea", "latitudea" };
		assertArrayEquals(expectedSuperLexicalNamesArray20, superLexicalNamesArray20);
		String[] expectedSuperAbstractNamesArray20 = { "citya", "citya", "citya", "citya", "citya", "citya" };
		assertArrayEquals(expectedSuperAbstractNamesArray20, superAbstractNamesArray20);
		Set<String> superLexicalVariableNames20 = ((ReduceOperator) input2Operator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray20 = new String[6];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames20) {
			superLexicalVariableNamesArray20[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray20 = { "union2.citya.namea", "union2.citya.countrya", "union2.citya.provincea",
				"union2.citya.populationa", "union2.citya.longitudea", "union2.citya.latitudea" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray20, superLexicalVariableNamesArray20);

		assertNotNull(input2Operator.getResultType());
		ResultType resultType20 = input2Operator.getResultType();
		assertEquals(6, resultType20.getResultFields().size());
		String[] expectedResultFieldNamesArray20 = { "union2.citya.namea", "union2.citya.countrya", "union2.citya.provincea",
				"union2.citya.populationa", "union2.citya.longitudea", "union2.citya.latitudea" };
		DataType[] expectedResultFieldTypesArray20 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray20 = { "namea", "countrya", "provincea", "populationa", "longitudea", "latitudea" };
		String[] exptectedParentCanonicalModelConstructNamesArray20 = { "citya", "citya", "citya", "citya", "citya", "citya" };

		String[] actualResultFieldNamesArray20 = new String[6];
		DataType[] actualResultFieldTypesArray20 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray20 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray20 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields20 = resultType20.getResultFields();
		Set<String> resultFieldNames20 = resultFields20.keySet();
		for (String resultFieldName : resultFieldNames20) {
			actualResultFieldNamesArray20[i] = resultFieldName;
			actualResultFieldTypesArray20[i] = resultFields20.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray20[i] = resultFields20.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields20.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray20[i] = ((SuperLexical) resultFields20.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray20, actualResultFieldNamesArray20);
		assertArrayEquals(expectedResultFieldTypesArray20, actualResultFieldTypesArray20);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray20, actualCanonicalModelConstructNamesArray20);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray20, actualParentCanonicalModelConstructNamesArray20);

		MappingOperator input12Operator = input2Operator.getLhsInput();

		isInstanceOf(ScanOperator.class, input12Operator);
		assertEquals("union2.citya", input12Operator.getVariableName());
		assertNull(input12Operator.getLhsInput());
		assertNull(input12Operator.getRhsInput());
		assertEquals("citya", ((ScanOperator) input12Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input12Operator).getReconcilingExpression());
		assertEquals("union2.citya.countrya = 'MA'", ((ScanOperator) input12Operator).getReconcilingExpression().getExpression());

		assertNotNull(input12Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentAfricaWithRenameDS, input12Operator.getDataSource());

		assertEquals(1, ((ScanOperator) input12Operator).getPredicates().size());
		Predicate predicate2 = ((ScanOperator) input12Operator).getPredicates().iterator().next();
		assertEquals("countrya", predicate2.getSuperLexical1().getName());
		assertEquals("citya", predicate2.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate2.getOperator());
		assertEquals("'MA'", predicate2.getLiteral2());
		assertNull(predicate2.getLiteral1());
		assertNull(predicate2.getSuperLexical2());

		assertNotNull(input12Operator.getResultType());
		ResultType resultType2 = input12Operator.getResultType();
		assertEquals(6, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "union2.citya.namea", "union2.citya.countrya", "union2.citya.provincea",
				"union2.citya.populationa", "union2.citya.longitudea", "union2.citya.latitudea" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "namea", "countrya", "provincea", "populationa", "longitudea", "latitudea" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "citya", "citya", "citya", "citya", "citya", "citya" };

		String[] actualResultFieldNamesArray2 = new String[6];
		DataType[] actualResultFieldTypesArray2 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray2 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);
	}

	/**
	 * Test method for {@link uk.ac.manchester.dataspaces.service.impl.operators.query.querytranslator.GlobalQueryTranslatorServiceImpl#translateAstIntoQuery(org.antlr.runtime.tree.CommonTree)}.
	 */
	@Test
	public void testTranslateAstIntoQuerySelectStarFromWhereUnionUnionQueryTwoSources() {
		String selectStarFromWhereUnionUnionQuery = "Select * from citye where citye.countrye = 'GB' union select * from citya where citya.countrya = 'MA' union select * from citye where citye.countrye = 'IRL'";
		String queryName = "queryName";
		Schema mondialCityProvinceCountryContinentEuropeWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentEuropeWR");
		Schema mondialCityProvinceCountryContinentAfricaWRSchema = schemaRepository.getSchemaByName("MondialCityProvinceCountryContinentAfricaWR");

		DataSource mondialCityProvinceCountryContinentEuropeWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentEuropeWR");
		logger.debug("mondialCityProvinceCountryContinentEuropeWithRenameDS: " + mondialCityProvinceCountryContinentEuropeWithRenameDS);
		DataSource mondialCityProvinceCountryContinentAfricaWithRenameDS = dataSourceRepository
				.getDataSourceWithSchemaName("MondialCityProvinceCountryContinentAfricaWR");
		logger.debug("mondialCityProvinceCountryContinentAfricaWithRenameDS: " + mondialCityProvinceCountryContinentAfricaWithRenameDS);

		Query query = new Query(queryName, selectStarFromWhereUnionUnionQuery);
		query.addSchema(mondialCityProvinceCountryContinentEuropeWRSchema);
		query.addSchema(mondialCityProvinceCountryContinentAfricaWRSchema);
		//query.addDataSource(mondialCityProvinceCountryContinentEuropeWithRenameDS);
		//query.addDataSource(mondialCityProvinceCountryContinentAfricaWithRenameDS);

		CommonTree selectStarFromWhereUnionUnionQueryAst = parser.parseSQL(selectStarFromWhereUnionUnionQuery);
		logger.debug("selectStarFromWhereUnionQueryAst: " + selectStarFromWhereUnionUnionQueryAst.toStringTree());

		query = globalTranslator.translateAstIntoQuery(query, selectStarFromWhereUnionUnionQuery, selectStarFromWhereUnionUnionQueryAst);

		MappingOperator rootOperator = query.getRootOperator();

		isInstanceOf(ReduceOperator.class, rootOperator);
		assertNull(rootOperator.getVariableName());
		assertNotNull(rootOperator.getInput());
		assertNotNull(rootOperator.getLhsInput());
		assertEquals(rootOperator.getInput(), rootOperator.getLhsInput());
		assertNull(rootOperator.getRhsInput());
		assertEquals(6, ((ReduceOperator) rootOperator).getSuperLexicals().size());
		assertEquals(
				"union1.union1.citye.namee, union1.union1.citye.countrye, union1.union1.citye.provincee, union1.union1.citye.populatione, union1.union1.citye.longitudee, union1.union1.citye.latitudee",
				((ReduceOperator) rootOperator).getReconcilingExpression().getExpression());

		assertNull(rootOperator.getDataSource());

		Collection<SuperLexical> superLexicals = ((ReduceOperator) rootOperator).getSuperLexicals().values();
		String[] superLexicalNamesArray = new String[6];
		String[] superAbstractNamesArray = new String[6];
		int i = 0;
		for (SuperLexical superLexical : superLexicals) {
			superLexicalNamesArray[i] = superLexical.getName();
			superAbstractNamesArray[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		assertArrayEquals(expectedSuperLexicalNamesArray, superLexicalNamesArray);
		String[] expectedSuperAbstractNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye" };
		assertArrayEquals(expectedSuperAbstractNamesArray, superAbstractNamesArray);
		Set<String> superLexicalVariableNames = ((ReduceOperator) rootOperator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray = new String[6];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames) {
			superLexicalVariableNamesArray[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray = { "union1.union1.citye.namee", "union1.union1.citye.countrye",
				"union1.union1.citye.provincee", "union1.union1.citye.populatione", "union1.union1.citye.longitudee", "union1.union1.citye.latitudee" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray, superLexicalVariableNamesArray);

		assertNotNull(rootOperator.getResultType());
		ResultType resultType0 = rootOperator.getResultType();
		assertEquals(6, resultType0.getResultFields().size());
		String[] expectedResultFieldNamesArray0 = { "union1.union1.citye.namee", "union1.union1.citye.countrye", "union1.union1.citye.provincee",
				"union1.union1.citye.populatione", "union1.union1.citye.longitudee", "union1.union1.citye.latitudee" };
		DataType[] expectedResultFieldTypesArray0 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray0 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray0 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray0 = new String[6];
		DataType[] actualResultFieldTypesArray0 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray0 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray0 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields0 = resultType0.getResultFields();
		Set<String> resultFieldNames0 = resultFields0.keySet();
		for (String resultFieldName : resultFieldNames0) {
			actualResultFieldNamesArray0[i] = resultFieldName;
			actualResultFieldTypesArray0[i] = resultFields0.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray0[i] = resultFields0.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields0.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray0[i] = ((SuperLexical) resultFields0.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray0, actualResultFieldNamesArray0);
		assertArrayEquals(expectedResultFieldTypesArray0, actualResultFieldTypesArray0);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray0, actualCanonicalModelConstructNamesArray0);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray0, actualParentCanonicalModelConstructNamesArray0);

		MappingOperator input0Operator = rootOperator.getLhsInput();

		isInstanceOf(SetOperator.class, input0Operator);
		assertNull(input0Operator.getVariableName());
		assertNotNull(input0Operator.getLhsInput());
		assertNotNull(input0Operator.getRhsInput());
		assertEquals(input0Operator.getInput(), input0Operator.getLhsInput());
		assertNull(((SetOperator) input0Operator).getReconcilingExpression());

		assertNull(input0Operator.getDataSource());

		assertNotNull(input0Operator.getResultType());
		ResultType resultType = input0Operator.getResultType();
		assertEquals(6, resultType.getResultFields().size());
		String[] expectedResultFieldNamesArray = { "union1.union1.citye.namee", "union1.union1.citye.countrye", "union1.union1.citye.provincee",
				"union1.union1.citye.populatione", "union1.union1.citye.longitudee", "union1.union1.citye.latitudee" };
		DataType[] expectedResultFieldTypesArray = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray = new String[6];
		DataType[] actualResultFieldTypesArray = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray = new String[6];

		i = 0;
		Map<String, ResultField> resultFields = resultType.getResultFields();
		Set<String> resultFieldNames = resultFields.keySet();
		for (String resultFieldName : resultFieldNames) {
			actualResultFieldNamesArray[i] = resultFieldName;
			actualResultFieldTypesArray[i] = resultFields.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray[i] = resultFields.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray[i] = ((SuperLexical) resultFields.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray, actualResultFieldNamesArray);
		assertArrayEquals(expectedResultFieldTypesArray, actualResultFieldTypesArray);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray, actualCanonicalModelConstructNamesArray);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray, actualParentCanonicalModelConstructNamesArray);

		MappingOperator input1Operator = input0Operator.getLhsInput();

		isInstanceOf(ReduceOperator.class, input1Operator);
		assertNull(input1Operator.getVariableName());
		assertNotNull(input1Operator.getInput());
		assertNotNull(input1Operator.getLhsInput());
		assertEquals(input1Operator.getInput(), input1Operator.getLhsInput());
		assertNull(input1Operator.getRhsInput());
		assertEquals(6, ((ReduceOperator) input1Operator).getSuperLexicals().size());
		assertEquals(
				"union1.union1.citye.namee, union1.union1.citye.countrye, union1.union1.citye.provincee, union1.union1.citye.populatione, union1.union1.citye.longitudee, union1.union1.citye.latitudee",
				((ReduceOperator) input1Operator).getReconcilingExpression().getExpression());

		assertNull(input1Operator.getDataSource());

		Collection<SuperLexical> superLexicals10 = ((ReduceOperator) input1Operator).getSuperLexicals().values();
		String[] superLexicalNamesArray10 = new String[6];
		String[] superAbstractNamesArray10 = new String[6];
		i = 0;
		for (SuperLexical superLexical : superLexicals10) {
			superLexicalNamesArray10[i] = superLexical.getName();
			superAbstractNamesArray10[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray10 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		assertArrayEquals(expectedSuperLexicalNamesArray10, superLexicalNamesArray10);
		String[] expectedSuperAbstractNamesArray10 = { "citye", "citye", "citye", "citye", "citye", "citye" };
		assertArrayEquals(expectedSuperAbstractNamesArray10, superAbstractNamesArray10);
		Set<String> superLexicalVariableNames10 = ((ReduceOperator) input1Operator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray10 = new String[6];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames10) {
			superLexicalVariableNamesArray10[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray10 = { "union1.union1.citye.namee", "union1.union1.citye.countrye",
				"union1.union1.citye.provincee", "union1.union1.citye.populatione", "union1.union1.citye.longitudee", "union1.union1.citye.latitudee" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray10, superLexicalVariableNamesArray10);

		assertNotNull(input1Operator.getResultType());
		ResultType resultType10 = input1Operator.getResultType();
		assertEquals(6, resultType10.getResultFields().size());
		String[] expectedResultFieldNamesArray10 = { "union1.union1.citye.namee", "union1.union1.citye.countrye", "union1.union1.citye.provincee",
				"union1.union1.citye.populatione", "union1.union1.citye.longitudee", "union1.union1.citye.latitudee" };
		DataType[] expectedResultFieldTypesArray10 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray10 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray10 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray10 = new String[6];
		DataType[] actualResultFieldTypesArray10 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray10 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray10 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields10 = resultType10.getResultFields();
		Set<String> resultFieldNames10 = resultFields10.keySet();
		for (String resultFieldName : resultFieldNames10) {
			actualResultFieldNamesArray10[i] = resultFieldName;
			actualResultFieldTypesArray10[i] = resultFields10.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray10[i] = resultFields10.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields10.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray10[i] = ((SuperLexical) resultFields10.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray10, actualResultFieldNamesArray10);
		assertArrayEquals(expectedResultFieldTypesArray10, actualResultFieldTypesArray10);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray10, actualCanonicalModelConstructNamesArray10);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray10, actualParentCanonicalModelConstructNamesArray10);

		MappingOperator input11Operator = input1Operator.getLhsInput();

		isInstanceOf(SetOperator.class, input11Operator);
		assertNull(input11Operator.getVariableName());
		assertNotNull(input11Operator.getLhsInput());
		assertNotNull(input11Operator.getRhsInput());
		assertEquals(input11Operator.getInput(), input11Operator.getLhsInput());
		assertNull(((SetOperator) input11Operator).getReconcilingExpression());

		assertNull(input11Operator.getDataSource());

		assertNotNull(input11Operator.getResultType());
		ResultType resultType110 = input11Operator.getResultType();
		assertEquals(6, resultType110.getResultFields().size());
		String[] expectedResultFieldNamesArray110 = { "union1.union1.citye.namee", "union1.union1.citye.countrye", "union1.union1.citye.provincee",
				"union1.union1.citye.populatione", "union1.union1.citye.longitudee", "union1.union1.citye.latitudee" };
		DataType[] expectedResultFieldTypesArray110 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray110 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray110 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray110 = new String[6];
		DataType[] actualResultFieldTypesArray110 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray110 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray110 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields110 = resultType110.getResultFields();
		Set<String> resultFieldNames110 = resultFields110.keySet();
		for (String resultFieldName : resultFieldNames110) {
			actualResultFieldNamesArray110[i] = resultFieldName;
			actualResultFieldTypesArray110[i] = resultFields110.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray110[i] = resultFields110.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields110.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray110[i] = ((SuperLexical) resultFields110.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray110, actualResultFieldNamesArray110);
		assertArrayEquals(expectedResultFieldTypesArray110, actualResultFieldTypesArray110);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray110, actualCanonicalModelConstructNamesArray110);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray110, actualParentCanonicalModelConstructNamesArray110);

		MappingOperator input2Operator = input0Operator.getRhsInput();

		isInstanceOf(ReduceOperator.class, input2Operator);
		assertNull(input2Operator.getVariableName());
		assertNotNull(input2Operator.getInput());
		assertNotNull(input2Operator.getLhsInput());
		assertEquals(input2Operator.getInput(), input2Operator.getLhsInput());
		assertNull(input2Operator.getRhsInput());
		assertEquals(6, ((ReduceOperator) input2Operator).getSuperLexicals().size());
		assertEquals(
				"union2.citye.namee, union2.citye.countrye, union2.citye.provincee, union2.citye.populatione, union2.citye.longitudee, union2.citye.latitudee",
				((ReduceOperator) input2Operator).getReconcilingExpression().getExpression());

		assertNotNull(input2Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input2Operator.getDataSource());

		Collection<SuperLexical> superLexicals20 = ((ReduceOperator) input2Operator).getSuperLexicals().values();
		String[] superLexicalNamesArray20 = new String[6];
		String[] superAbstractNamesArray20 = new String[6];
		i = 0;
		for (SuperLexical superLexical : superLexicals20) {
			superLexicalNamesArray20[i] = superLexical.getName();
			superAbstractNamesArray20[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray20 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		assertArrayEquals(expectedSuperLexicalNamesArray20, superLexicalNamesArray20);
		String[] expectedSuperAbstractNamesArray20 = { "citye", "citye", "citye", "citye", "citye", "citye" };
		assertArrayEquals(expectedSuperAbstractNamesArray20, superAbstractNamesArray20);
		Set<String> superLexicalVariableNames20 = ((ReduceOperator) input2Operator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray20 = new String[6];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames20) {
			superLexicalVariableNamesArray20[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray20 = { "union2.citye.namee", "union2.citye.countrye", "union2.citye.provincee",
				"union2.citye.populatione", "union2.citye.longitudee", "union2.citye.latitudee" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray20, superLexicalVariableNamesArray20);

		assertNotNull(input2Operator.getResultType());
		ResultType resultType20 = input2Operator.getResultType();
		assertEquals(6, resultType20.getResultFields().size());
		String[] expectedResultFieldNamesArray20 = { "union2.citye.namee", "union2.citye.countrye", "union2.citye.provincee",
				"union2.citye.populatione", "union2.citye.longitudee", "union2.citye.latitudee" };
		DataType[] expectedResultFieldTypesArray20 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray20 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray20 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray20 = new String[6];
		DataType[] actualResultFieldTypesArray20 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray20 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray20 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields20 = resultType20.getResultFields();
		Set<String> resultFieldNames20 = resultFields20.keySet();
		for (String resultFieldName : resultFieldNames20) {
			actualResultFieldNamesArray20[i] = resultFieldName;
			actualResultFieldTypesArray20[i] = resultFields20.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray20[i] = resultFields20.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields20.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray20[i] = ((SuperLexical) resultFields20.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray20, actualResultFieldNamesArray20);
		assertArrayEquals(expectedResultFieldTypesArray20, actualResultFieldTypesArray20);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray20, actualCanonicalModelConstructNamesArray20);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray20, actualParentCanonicalModelConstructNamesArray20);

		MappingOperator input12Operator = input2Operator.getLhsInput();

		isInstanceOf(ScanOperator.class, input12Operator);
		assertEquals("union2.citye", input12Operator.getVariableName());
		assertNull(input12Operator.getLhsInput());
		assertNull(input12Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input12Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input12Operator).getReconcilingExpression());
		assertEquals("union2.citye.countrye = 'IRL'", ((ScanOperator) input12Operator).getReconcilingExpression().getExpression());

		assertNotNull(input12Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input12Operator.getDataSource());

		assertEquals(1, ((ScanOperator) input12Operator).getPredicates().size());
		Predicate predicate2 = ((ScanOperator) input12Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate2.getSuperLexical1().getName());
		assertEquals("citye", predicate2.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate2.getOperator());
		assertEquals("'IRL'", predicate2.getLiteral2());
		assertNull(predicate2.getLiteral1());
		assertNull(predicate2.getSuperLexical2());

		assertNotNull(input12Operator.getResultType());
		ResultType resultType1 = input12Operator.getResultType();
		assertEquals(6, resultType1.getResultFields().size());
		String[] expectedResultFieldNamesArray1 = { "union2.citye.namee", "union2.citye.countrye", "union2.citye.provincee",
				"union2.citye.populatione", "union2.citye.longitudee", "union2.citye.latitudee" };
		DataType[] expectedResultFieldTypesArray1 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray1 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray1 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray1 = new String[6];
		DataType[] actualResultFieldTypesArray1 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray1 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray1 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields1 = resultType1.getResultFields();
		Set<String> resultFieldNames1 = resultFields1.keySet();
		for (String resultFieldName : resultFieldNames1) {
			actualResultFieldNamesArray1[i] = resultFieldName;
			actualResultFieldTypesArray1[i] = resultFields1.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray1[i] = resultFields1.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields1.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray1[i] = ((SuperLexical) resultFields1.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray1, actualResultFieldNamesArray1);
		assertArrayEquals(expectedResultFieldTypesArray1, actualResultFieldTypesArray1);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray1, actualCanonicalModelConstructNamesArray1);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray1, actualParentCanonicalModelConstructNamesArray1);

		MappingOperator input121Operator = input11Operator.getLhsInput();

		isInstanceOf(ReduceOperator.class, input121Operator);
		assertNull(input121Operator.getVariableName());
		assertNotNull(input121Operator.getInput());
		assertNotNull(input121Operator.getLhsInput());
		assertEquals(input121Operator.getInput(), input121Operator.getLhsInput());
		assertNull(input121Operator.getRhsInput());
		assertEquals(6, ((ReduceOperator) input121Operator).getSuperLexicals().size());
		assertEquals(
				"union1.union1.citye.namee, union1.union1.citye.countrye, union1.union1.citye.provincee, union1.union1.citye.populatione, union1.union1.citye.longitudee, union1.union1.citye.latitudee",
				((ReduceOperator) input121Operator).getReconcilingExpression().getExpression());

		assertNotNull(input121Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input121Operator.getDataSource());

		Collection<SuperLexical> superLexicals1210 = ((ReduceOperator) input121Operator).getSuperLexicals().values();
		String[] superLexicalNamesArray1210 = new String[6];
		String[] superAbstractNamesArray1210 = new String[6];
		i = 0;
		for (SuperLexical superLexical : superLexicals1210) {
			superLexicalNamesArray1210[i] = superLexical.getName();
			superAbstractNamesArray1210[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray1210 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		assertArrayEquals(expectedSuperLexicalNamesArray1210, superLexicalNamesArray1210);
		String[] expectedSuperAbstractNamesArray1210 = { "citye", "citye", "citye", "citye", "citye", "citye" };
		assertArrayEquals(expectedSuperAbstractNamesArray1210, superAbstractNamesArray1210);
		Set<String> superLexicalVariableNames1210 = ((ReduceOperator) input121Operator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray1210 = new String[6];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames1210) {
			superLexicalVariableNamesArray1210[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray1210 = { "union1.union1.citye.namee", "union1.union1.citye.countrye",
				"union1.union1.citye.provincee", "union1.union1.citye.populatione", "union1.union1.citye.longitudee", "union1.union1.citye.latitudee" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray1210, superLexicalVariableNamesArray1210);

		assertNotNull(input121Operator.getResultType());
		ResultType resultType1210 = input121Operator.getResultType();
		assertEquals(6, resultType1210.getResultFields().size());
		String[] expectedResultFieldNamesArray1210 = { "union1.union1.citye.namee", "union1.union1.citye.countrye", "union1.union1.citye.provincee",
				"union1.union1.citye.populatione", "union1.union1.citye.longitudee", "union1.union1.citye.latitudee" };
		DataType[] expectedResultFieldTypesArray1210 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray1210 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray1210 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray1210 = new String[6];
		DataType[] actualResultFieldTypesArray1210 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray1210 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray1210 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields1210 = resultType1210.getResultFields();
		Set<String> resultFieldNames1210 = resultFields1210.keySet();
		for (String resultFieldName : resultFieldNames1210) {
			actualResultFieldNamesArray1210[i] = resultFieldName;
			actualResultFieldTypesArray1210[i] = resultFields1210.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray1210[i] = resultFields1210.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields1210.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray1210[i] = ((SuperLexical) resultFields1210.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray1210, actualResultFieldNamesArray1210);
		assertArrayEquals(expectedResultFieldTypesArray1210, actualResultFieldTypesArray1210);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray1210, actualCanonicalModelConstructNamesArray1210);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray1210, actualParentCanonicalModelConstructNamesArray1210);

		MappingOperator input1211Operator = input121Operator.getLhsInput();

		isInstanceOf(ScanOperator.class, input1211Operator);
		assertEquals("union1.union1.citye", input1211Operator.getVariableName());
		assertNull(input1211Operator.getLhsInput());
		assertNull(input1211Operator.getRhsInput());
		assertEquals("citye", ((ScanOperator) input1211Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input1211Operator).getReconcilingExpression());
		assertEquals("union1.union1.citye.countrye = 'GB'", ((ScanOperator) input1211Operator).getReconcilingExpression().getExpression());

		assertNotNull(input1211Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentEuropeWithRenameDS, input1211Operator.getDataSource());

		assertEquals(1, ((ScanOperator) input1211Operator).getPredicates().size());
		Predicate predicate11 = ((ScanOperator) input1211Operator).getPredicates().iterator().next();
		assertEquals("countrye", predicate11.getSuperLexical1().getName());
		assertEquals("citye", predicate11.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate11.getOperator());
		assertEquals("'GB'", predicate11.getLiteral2());
		assertNull(predicate11.getLiteral1());
		assertNull(predicate11.getSuperLexical2());

		assertNotNull(input1211Operator.getResultType());
		ResultType resultType2 = input1211Operator.getResultType();
		assertEquals(6, resultType2.getResultFields().size());
		String[] expectedResultFieldNamesArray2 = { "union1.union1.citye.namee", "union1.union1.citye.countrye", "union1.union1.citye.provincee",
				"union1.union1.citye.populatione", "union1.union1.citye.longitudee", "union1.union1.citye.latitudee" };
		DataType[] expectedResultFieldTypesArray2 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray2 = { "namee", "countrye", "provincee", "populatione", "longitudee", "latitudee" };
		String[] exptectedParentCanonicalModelConstructNamesArray2 = { "citye", "citye", "citye", "citye", "citye", "citye" };

		String[] actualResultFieldNamesArray2 = new String[6];
		DataType[] actualResultFieldTypesArray2 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray2 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray2 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields2 = resultType2.getResultFields();
		Set<String> resultFieldNames2 = resultFields2.keySet();
		for (String resultFieldName : resultFieldNames2) {
			actualResultFieldNamesArray2[i] = resultFieldName;
			actualResultFieldTypesArray2[i] = resultFields2.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray2[i] = resultFields2.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields2.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray2[i] = ((SuperLexical) resultFields2.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray2, actualResultFieldNamesArray2);
		assertArrayEquals(expectedResultFieldTypesArray2, actualResultFieldTypesArray2);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray2, actualCanonicalModelConstructNamesArray2);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray2, actualParentCanonicalModelConstructNamesArray2);

		MappingOperator input112Operator = input11Operator.getRhsInput();

		isInstanceOf(ReduceOperator.class, input112Operator);
		assertNull(input112Operator.getVariableName());
		assertNotNull(input112Operator.getInput());
		assertNotNull(input112Operator.getLhsInput());
		assertEquals(input112Operator.getInput(), input112Operator.getLhsInput());
		assertNull(input112Operator.getRhsInput());
		assertEquals(6, ((ReduceOperator) input112Operator).getSuperLexicals().size());
		assertEquals(
				"union2.union1.citya.namea, union2.union1.citya.countrya, union2.union1.citya.provincea, union2.union1.citya.populationa, union2.union1.citya.longitudea, union2.union1.citya.latitudea",
				((ReduceOperator) input112Operator).getReconcilingExpression().getExpression());

		assertNotNull(input112Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentAfricaWithRenameDS, input112Operator.getDataSource());

		Collection<SuperLexical> superLexicals1120 = ((ReduceOperator) input112Operator).getSuperLexicals().values();
		String[] superLexicalNamesArray1120 = new String[6];
		String[] superAbstractNamesArray1120 = new String[6];
		i = 0;
		for (SuperLexical superLexical : superLexicals1120) {
			superLexicalNamesArray1120[i] = superLexical.getName();
			superAbstractNamesArray1120[i] = superLexical.getParentSuperAbstract().getName();
			i++;
		}
		String[] expectedSuperLexicalNamesArray1120 = { "namea", "countrya", "provincea", "populationa", "longitudea", "latitudea" };
		assertArrayEquals(expectedSuperLexicalNamesArray1120, superLexicalNamesArray1120);
		String[] expectedSuperAbstractNamesArray1120 = { "citya", "citya", "citya", "citya", "citya", "citya" };
		assertArrayEquals(expectedSuperAbstractNamesArray1120, superAbstractNamesArray1120);
		Set<String> superLexicalVariableNames1120 = ((ReduceOperator) input112Operator).getSuperLexicals().keySet();
		String[] superLexicalVariableNamesArray1120 = new String[6];
		i = 0;
		for (String superLexicalVariableName : superLexicalVariableNames1120) {
			superLexicalVariableNamesArray1120[i] = superLexicalVariableName;
			i++;
		}
		String[] expectedSuperLexicalVariableNamesArray1120 = { "union2.union1.citya.namea", "union2.union1.citya.countrya",
				"union2.union1.citya.provincea", "union2.union1.citya.populationa", "union2.union1.citya.longitudea", "union2.union1.citya.latitudea" };
		assertArrayEquals(expectedSuperLexicalVariableNamesArray1120, superLexicalVariableNamesArray1120);

		assertNotNull(input112Operator.getResultType());
		ResultType resultType1120 = input112Operator.getResultType();
		assertEquals(6, resultType1120.getResultFields().size());
		String[] expectedResultFieldNamesArray1120 = { "union2.union1.citya.namea", "union2.union1.citya.countrya", "union2.union1.citya.provincea",
				"union2.union1.citya.populationa", "union2.union1.citya.longitudea", "union2.union1.citya.latitudea" };
		DataType[] expectedResultFieldTypesArray1120 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray1120 = { "namea", "countrya", "provincea", "populationa", "longitudea", "latitudea" };
		String[] exptectedParentCanonicalModelConstructNamesArray1120 = { "citya", "citya", "citya", "citya", "citya", "citya" };

		String[] actualResultFieldNamesArray1120 = new String[6];
		DataType[] actualResultFieldTypesArray1120 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray1120 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray1120 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields1120 = resultType1120.getResultFields();
		Set<String> resultFieldNames1120 = resultFields1120.keySet();
		for (String resultFieldName : resultFieldNames1120) {
			actualResultFieldNamesArray1120[i] = resultFieldName;
			actualResultFieldTypesArray1120[i] = resultFields1120.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray1120[i] = resultFields1120.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields1120.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray1120[i] = ((SuperLexical) resultFields1120.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray1120, actualResultFieldNamesArray1120);
		assertArrayEquals(expectedResultFieldTypesArray1120, actualResultFieldTypesArray1120);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray1120, actualCanonicalModelConstructNamesArray1120);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray1120, actualParentCanonicalModelConstructNamesArray1120);

		MappingOperator input1121Operator = input112Operator.getLhsInput();

		isInstanceOf(ScanOperator.class, input1121Operator);
		assertEquals("union2.union1.citya", input1121Operator.getVariableName());
		assertNull(input1121Operator.getLhsInput());
		assertNull(input1121Operator.getRhsInput());
		assertEquals("citya", ((ScanOperator) input1121Operator).getSuperAbstract().getName());
		assertNotNull(((ScanOperator) input1121Operator).getReconcilingExpression());
		assertEquals("union2.union1.citya.countrya = 'MA'", ((ScanOperator) input1121Operator).getReconcilingExpression().getExpression());

		assertNotNull(input1121Operator.getDataSource());
		assertEquals(mondialCityProvinceCountryContinentAfricaWithRenameDS, input1121Operator.getDataSource());

		assertEquals(1, ((ScanOperator) input1121Operator).getPredicates().size());
		Predicate predicate12 = ((ScanOperator) input1121Operator).getPredicates().iterator().next();
		assertEquals("countrya", predicate12.getSuperLexical1().getName());
		assertEquals("citya", predicate12.getSuperLexical1().getParentSuperAbstract().getName());
		assertEquals("=", predicate12.getOperator());
		assertEquals("'MA'", predicate12.getLiteral2());
		assertNull(predicate12.getLiteral1());
		assertNull(predicate12.getSuperLexical2());

		assertNotNull(input1121Operator.getResultType());
		ResultType resultType3 = input1121Operator.getResultType();
		assertEquals(6, resultType3.getResultFields().size());
		String[] expectedResultFieldNamesArray3 = { "union2.union1.citya.namea", "union2.union1.citya.countrya", "union2.union1.citya.provincea",
				"union2.union1.citya.populationa", "union2.union1.citya.longitudea", "union2.union1.citya.latitudea" };
		DataType[] expectedResultFieldTypesArray3 = { DataType.STRING, DataType.STRING, DataType.STRING, DataType.INTEGER, DataType.FLOAT,
				DataType.FLOAT };
		String[] expectedCanonicalModelConstructNamesArray3 = { "namea", "countrya", "provincea", "populationa", "longitudea", "latitudea" };
		String[] exptectedParentCanonicalModelConstructNamesArray3 = { "citya", "citya", "citya", "citya", "citya", "citya" };

		String[] actualResultFieldNamesArray3 = new String[6];
		DataType[] actualResultFieldTypesArray3 = new DataType[6];
		String[] actualCanonicalModelConstructNamesArray3 = new String[6];
		String[] actualParentCanonicalModelConstructNamesArray3 = new String[6];

		i = 0;
		Map<String, ResultField> resultFields3 = resultType3.getResultFields();
		Set<String> resultFieldNames3 = resultFields3.keySet();
		for (String resultFieldName : resultFieldNames3) {
			actualResultFieldNamesArray3[i] = resultFieldName;
			actualResultFieldTypesArray3[i] = resultFields3.get(resultFieldName).getFieldType();
			actualCanonicalModelConstructNamesArray3[i] = resultFields3.get(resultFieldName).getCanonicalModelConstruct().getName();
			isInstanceOf(SuperLexical.class, resultFields3.get(resultFieldName).getCanonicalModelConstruct());
			actualParentCanonicalModelConstructNamesArray3[i] = ((SuperLexical) resultFields3.get(resultFieldName).getCanonicalModelConstruct())
					.getParentSuperAbstract().getName();
			i++;
		}

		assertArrayEquals(expectedResultFieldNamesArray3, actualResultFieldNamesArray3);
		assertArrayEquals(expectedResultFieldTypesArray3, actualResultFieldTypesArray3);
		assertArrayEquals(expectedCanonicalModelConstructNamesArray3, actualCanonicalModelConstructNamesArray3);
		assertArrayEquals(exptectedParentCanonicalModelConstructNamesArray3, actualParentCanonicalModelConstructNamesArray3);
	}

}
